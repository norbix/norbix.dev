<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><script>(function(){const e=localStorage.getItem("theme"),t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches;e==="dark"||!e&&t?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark"),window.setTheme=function(e){localStorage.setItem("theme",e),document.documentElement.classList.toggle("dark",e==="dark")}})()</script><title>Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs | norbix.dev
</title><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs | norbix.dev - The log of my journey through code & software systems architecture</title>
<meta name=keywords content="go,saas,microservices,grpc,rest,graphql,websockets"><meta name=description content="Explore how to build SaaS-ready microservices in Go using REST, gRPC, GraphQL, and WebSockets. Learn the trade-offs, use cases, and tooling for each API style."><meta name=author content><link rel=canonical href=https://norbix.dev/posts/saas-microservices/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://norbix.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://norbix.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://norbix.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://norbix.dev/apple-touch-icon.png><link rel=mask-icon href=https://norbix.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://norbix.dev/posts/saas-microservices/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=canonical href=https://norbix.dev/posts/saas-microservices/><meta property="og:title" content="Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs"><meta property="og:url" content="https://norbix.dev/posts/saas-microservices/"><meta property="og:image" content="https://norbix.dev/saas-go-banner.jpg"><meta property="og:type" content="article"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs"><meta name=twitter:image content="https://norbix.dev/saas-go-banner.jpg"><script data-goatcounter=https://norbix.goatcounter.com/count async src=//gc.zgo.at/count.js></script><link rel=alternate type=application/rss+xml title="RSS Feed for norbix.dev" href=/index.xml><script src=https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js defer></script><script>document.addEventListener("DOMContentLoaded",function(){window.mermaid&&(document.querySelectorAll("code.language-mermaid").forEach(function(e){var n=e.parentElement,t=document.createElement("div");t.className="mermaid",t.textContent=e.textContent,n.replaceWith(t)}),mermaid.initialize({startOnLoad:!0}))})</script><link href=https://cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.3/css/lightbox.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.3/js/lightbox.min.js defer></script><meta property="og:title" content="Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs"><meta property="og:description" content="Explore how to build SaaS-ready microservices in Go using REST, gRPC, GraphQL, and WebSockets. Learn the trade-offs, use cases, and tooling for each API style."><meta property="og:type" content="article"><meta property="og:url" content="https://norbix.dev/posts/saas-microservices/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-22T21:00:00+02:00"><meta property="article:modified_time" content="2025-04-22T21:00:00+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs"><meta name=twitter:description content="Explore how to build SaaS-ready microservices in Go using REST, gRPC, GraphQL, and WebSockets. Learn the trade-offs, use cases, and tooling for each API style."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://norbix.dev/posts/"},{"@type":"ListItem","position":2,"name":"Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs","item":"https://norbix.dev/posts/saas-microservices/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs","name":"Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs","description":"Explore how to build SaaS-ready microservices in Go using REST, gRPC, GraphQL, and WebSockets. Learn the trade-offs, use cases, and tooling for each API style.","keywords":["go","saas","microservices","grpc","rest","graphql","websockets"],"articleBody":" â€œSaaS products scale with services that talk â€” efficiently, flexibly, and reliably.â€\nGo (Golang) has become a top-tier language for building scalable, cloud-native microservices â€” especially in the SaaS world. Its speed, simplicity, and rich concurrency model make it ideal for high-performance backends and multi-tenant systems.\nIn this article, weâ€™ll explore how to build SaaS microservices in Go, focusing on different API approaches â€” REST, gRPC, GraphQL, and WebSockets â€” and when to use each.\nğŸ—ï¸ Why Use Go for SaaS Microservices? âš¡ Performance: Native compilation, low memory usage, fast startup.\nğŸ§µ Concurrency: Goroutines + channels = lightweight multitasking.\nğŸ”§ Tooling: Rich stdlib, simple testing, static binaries, fast CI/CD.\nâ˜ï¸ Cloud Native: Ideal for containerization and Kubernetes deployments.\nGo hits the sweet spot between systems-level control and developer productivity.\nğŸ§± SaaS Architecture Essentials Service isolation (multi-tenant or multi-instance)\nStateless compute (for scalability)\nSecure authentication and authorization\nObservability (metrics, logs, traces)\nInter-service communication (APIs!)\nğŸŒ REST API: The Classic Workhorse âœ… Use When: You need browser and mobile-friendly APIs\nYour consumers prefer HTTP+JSON\nYou prioritize simplicity and developer ergonomics\nğŸ› ï¸ Go Libraries: net/http (stdlib)\ngin, chi, echo, fiber (routers)\nopenapi, swagger, goa (spec + docs)\nREST API is battle-tested, easy to cache, and easy to debug â€” ideal for public APIs or integrations.\nâš¡ gRPC API: High-Performance Internal Comms âœ… Use When: You need fast, efficient, binary communication\nYou control both client and server\nYouâ€™re building service-to-service comms in a large SaaS platform\nğŸ› ï¸ Go Libraries: google.golang.org/grpc\nProtocol Buffers (protoc, protoc-gen-go)\nEnvoy / gRPC-Gateway for REST interop\ngRPC API shines in polyglot, high-throughput microservice environments.\nğŸ” GraphQL: Flexible Queries for Frontend Teams âœ… Use When: Frontend teams need control over data shape\nYou want to reduce overfetching/underfetching\nYou serve multiple frontends with different needs\nğŸ› ï¸ Go Libraries: 99designs/gqlgen\ngraphql-go/graphql\nGraphQL API is great for B2B SaaS dashboards, admin panels, or multi-platform apps.\nğŸ”„ WebSockets: Real-Time, Bi-Directional APIs âœ… Use When: You need real-time updates (chat, collaboration, notifications)\nClients push and receive events\nğŸ› ï¸ Go Libraries: gorilla/websocket\nnhooyr/websocket\nWebSockets APIs are ideal for modern SaaS apps with live user interactions.\nğŸ“ CQRS: Separating Read and Write Paths The Command Query Responsibility Segregation (CQRS) pattern is often a great fit for SaaS microservices â€” especially when paired with event-driven architectures.\nâœ… Use When: You have complex domain logic or heavy reads vs light writes (or vice versa)\nYou want to decouple write models from read-optimized projections\nYouâ€™re building event-sourced systems\nâš™ï¸ Tools \u0026 Patterns in Go: Use separate structs/services for CommandHandlers and QueryHandlers\nEvent buses (e.g. go-nats, kafka-go, watermill)\nProjection stores (Postgres, Redis, Elasticsearch, etc.)\nCQRS enables scalability, flexibility, and clear separation of concerns â€” perfect for SaaS systems with evolving business logic and reporting needs.\nğŸ§© Putting It All Together In a real SaaS platform, youâ€™ll likely mix protocols:\nREST for public APIs and onboarding\ngRPC for internal service mesh\nGraphQL for flexible frontend backends\nWebSocket for interactive features\nUse each where it fits best â€” Go makes switching easy.\nğŸ› ï¸ Dev Stack for SaaS Microservices in Go API Gateways: Kong, Envoy, Traefik\nAuth: OAuth2, OIDC, JWT (with golang-jwt/jwt)\nService Discovery: Consul, etcd, Kubernetes\nObservability: Prometheus, OpenTelemetry, Grafana\nCI/CD: GitHub Actions, Drone, ArgoCD\nAPI GW Kong Example:\nflowchart LR Client[Client: Web, Mobile, Partner] --\u003e|HTTP/gRPC| Kong[Kong API Gateway] Kong --\u003e|Routing| Service1[Microservice A] Kong --\u003e|Routing| Service2[Microservice B] Kong --\u003e|Routing| Service3[Microservice C] Kong -.-\u003e|Auth, Rate Limit, Logging| Plugins[Plugins] Kong --\u003e Observability[Prometheus / Grafana / Logs] â˜ï¸ SaaS Microservices Examples ğŸ›’ E-commerce Platform User Service â€“ manages users, profiles, authentication data.\nCatalog Service â€“ product listings, categories, search.\nOrder Service â€“ order placement, status tracking.\nPayment Service â€“ handles credit cards, PayPal, Stripe.\nShipping Service â€“ shipping labels, delivery tracking.\nNotification Service â€“ emails, SMS, push notifications.\nğŸ¦ FinTech / Banking Customer Service â€“ KYC, customer info.\nAccount Service â€“ bank accounts, balances.\nTransaction Service â€“ transfers, deposits, withdrawals.\nFraud Detection Service â€“ anomaly detection.\nReporting Service â€“ statements, analytics.\nğŸ“± SaaS / Productivity App Auth Service â€“ login, OAuth2, JWT issuance (could be Keycloak).\nDocs Service â€“ document storage and editing.\nComments Service â€“ threaded discussions.\nBilling Service â€“ subscriptions, invoices.\nSearch Service â€“ full-text search across documents.\nğŸš— Mobility / Ride Sharing Driver Service â€“ driver registration, availability.\nRider Service â€“ customer profiles.\nRide Matching Service â€“ matches drivers â†” riders.\nPayment Service â€“ fare calculation + payment.\nLocation Service â€“ maps, GPS tracking.\nğŸ”§ How Kong fits in Kong sits at the edge and routes requests:\nflowchart TB Client[Mobile / Web Client] --\u003e Kong[Kong API Gateway] Kong --\u003e UserService[User Service] Kong --\u003e OrderService[Order Service] Kong --\u003e PaymentService[Payment Service] Kong --\u003e NotificationService[Notification Service] Kong -.-\u003e|Auth, Rate Limiting, JWT Validation| Keycloak[(Keycloak)] ğŸ¦ Kongâ€™s Role Kong sits as the API Gateway at the edge of your system. It acts as the single entry point for all clients (web apps, mobile apps, partner APIs).\nInstead of each client needing to know where every service lives, they all talk to Kong â€” and Kong handles:\nRouting â€“ decides which microservice should get the request.\nAuthentication \u0026 Authorization â€“ validates JWT tokens (from Keycloak, for example).\nRate Limiting â€“ prevents abuse (e.g., 100 requests/sec max).\nObservability â€“ logs, metrics, traces.\nTransformations â€“ rewrites headers, payloads, or even protocols.\nğŸ”„ Flow Example (Keycloak â†’ Kong â†’ Microservices) Client authenticates with Keycloak\nRedirects user to Keycloak login page.\nReceives a JWT access token (and optionally a refresh token).\nStores token locally (browser storage, app memory).\nClient sends request with JWT\n1 2 GET https://api.saas.com/docs/123 Authorization: Bearer Kong receives the request\nValidates JWT using OIDC plugin against Keycloakâ€™s public keys.\nApplies rate limiting plugin (e.g., 10 req/s per user).\nLogs the request (Prometheus/Grafana integration).\nKong routes the request\n/docs/* â†’ goes to Docs Service\n/billing/* â†’ goes to Billing Service\n/auth/* â†’ goes to Auth Service\nKong uses an internal service registry (DB or declarative YAML).\nMicroservice processes request\nDocs Service fetches document #123 from storage.\nIf it needs to notify the user, it may call Notification Service internally.\nResponse back to client\nKong passes the response through.\nOptionally adds headers, strips sensitive data, or transforms payloads.\nğŸ“Œ Visual Recap flowchart TB subgraph Auth[\"Keycloak Authentication\"] Keycloak[\"Keycloak OIDC Provider\"] end subgraph Observability[\"Observability \u0026 Logs\"] Logs[\"Prometheus / Grafana / ELK / Datadog\"] end Client[\"Web / Mobile App\"] --\u003e|\"Login \u0026 Fetch JWT\"| Keycloak Client --\u003e|\"Bearer JWT\"| Kong[\"Kong API Gateway\"] Kong --\u003e|\"Verify JWT\"| Keycloak Kong --\u003e Logs Kong --\u003e AuthService[\"Auth Service\"] Kong --\u003e DocsService[\"Docs Service\"] Kong --\u003e CommentsService[\"Comments Service\"] Kong --\u003e BillingService[\"Billing Service\"] Kong --\u003e NotificationsService[\"Notifications Service\"] Clients must fetch JWT from Keycloak in advance.\nKong validates JWT and enforces policies.\nMicroservices stay focused on business logic.\nRoutes traffic to the correct service.\nAdds cross-cutting features (logging, rate limiting, security).\nâœ… In short: Kong is the traffic cop + security guard + auditor in front of your microservices.\nNorthâ€“South vs Eastâ€“West Traffic The northâ€“south traffic refers to requests coming into the system from external clients (like web or mobile apps) and going out to them. This is typically handled by the API Gateway (Kong in our case).\nThe eastâ€“west traffic refers to communication between internal services within the system. This is where microservices talk to each other to fulfill requests, share data, or trigger actions.\nflowchart TB subgraph External[\"ğŸŒ External Clients\"] Client[\"ğŸ‘©â€ğŸ’» Web / ğŸ“± Mobile App\"] end subgraph DataCenter[\"ğŸ¢ Data Center / Cloud\"] Kong[\"ğŸ¦ API Gateway (Kong)\"] subgraph Services[\"Microservices\"] AuthService[\"ğŸ” Auth Service\"] DocsService[\"ğŸ“„ Docs Service\"] BillingService[\"ğŸ’³ Billing Service\"] NotificationService[\"ğŸ“¢ Notification Service\"] end end %% North-South traffic Client --\u003e|\"Northâ€“South Traffic\"| Kong %% Routing from Kong to services Kong --\u003e AuthService Kong --\u003e DocsService Kong --\u003e BillingService Kong --\u003e NotificationService %% East-West traffic inside services DocsService --\u003e|\"Eastâ€“West Traffic\"| BillingService BillingService --\u003e NotificationService â³ Eventual Consistency Challenge in SaaS Microservices When you split a SaaS platform into many independent services, you also split the data. That means synchronous strong consistency (like in a single SQL database) becomes hard â€” or impossible â€” to guarantee.\nInstead, many SaaS systems rely on eventual consistency:\nA user action triggers an event in one service.\nThat event propagates asynchronously to other services.\nDifferent services may see different states for a short time.\nEventually, all services converge to the same consistent state.\nâš ï¸ Why This Matters\nBilling vs Orders: a customerâ€™s order might be visible immediately, but billing might update a few seconds later.\nSearch vs Writes: you save a new document, but it doesnâ€™t show up in search until the indexer processes the event.\nNotifications: a user adds a comment, but notifications are sent asynchronously.\nğŸ› ï¸ How to Handle It\nIdempotency â€“ design APIs so that replaying messages doesnâ€™t create duplicates.\nRetries with backoff â€“ transient failures are normal in async flows.\nCompensating actions â€“ e.g., if payment fails, cancel the order (Saga pattern).\nUser experience cues â€“ show â€œprocessingâ€¦â€ states to set expectations.\nsequenceDiagram participant Client participant OrderService participant BillingService participant NotificationService Client-\u003e\u003eOrderService: Place Order OrderService--\u003e\u003eBillingService: Event: OrderCreated OrderService--\u003e\u003eNotificationService: Event: OrderCreated BillingService--\u003e\u003eNotificationService: Event: PaymentSucceeded Note over Client,NotificationService: Notifications \u0026 billing may lag behind the order creation, but system converges eventually âœ… Takeaway: In SaaS microservices, consistency is a spectrum. Accepting temporary inconsistency â€” and designing for it â€” is key to resilience and scalability.\nğŸ—„ï¸ Microservices + Databases: What Happens? Data Ownership\nEach microservice is responsible for its own schema.\nNo other service can directly query or update its DB.\nExample:\nOrder Service has orders table.\nBilling Service has invoices table.\nUser Service has users table.\nThis ensures loose coupling and independent evolution.\nThe Consistency Problem\nA single business transaction (e.g. â€œPlace Order and Charge Paymentâ€) now touches multiple DBs.\nDistributed transactions (2PC, XA) are rarely practical in cloud SaaS (complex, slow, brittle).\nInstead, we use eventual consistency.\nHow It Works\nOrder Service writes new order into its DB.\nIt publishes an OrderCreated event (via Kafka, NATS, RabbitMQ, etc.).\nBilling Service consumes the event and writes into its DB.\nNotification Service consumes the same event to send a message.\nAll services eventually agree, though not instantly.\nPatterns to Solve It\nEvent Sourcing â€“ source of truth is the event log, DBs are projections.\nCQRS â€“ separate command (writes) and query (reads) models.\nSaga Pattern â€“ long-running transactions split into steps with compensations if something fails.\nOutbox Pattern â€“ ensure DB writes and event publishes happen atomically (avoids lost events).\nExample Flow (Saga for Order + Billing)\nsequenceDiagram participant Client participant OrderService participant BillingService participant NotificationService Client-\u003e\u003eOrderService: Place Order OrderService-\u003e\u003eOrderDB: Insert Order(status=pending) OrderService--\u003e\u003eBillingService: Event(OrderCreated) BillingService-\u003e\u003eBillingDB: Create Invoice BillingService--\u003e\u003eOrderService: Event(PaymentSucceeded) OrderService-\u003e\u003eOrderDB: Update Order(status=confirmed) OrderService--\u003e\u003eNotificationService: Event(OrderConfirmed) NotificationService-\u003e\u003eNotificationDB: Send Confirmation âœ… Key takeaway:\nWhen each microservice has its own DB:\nYou trade immediate consistency for autonomy + scalability.\nYou must embrace eventual consistency and implement resilience patterns (Sagas, Outbox, CQRS).\nğŸ—„ï¸ Database Role in Microservices Microservice Owns the DB\nEach microservice has its own private database.\nNo other service can directly read/write it.\nDatabase is part of the serviceâ€™s implementation detail, not a shared integration layer.\nStored Procedures?\nIn modern SaaS microservices:\nâŒ Avoid heavy stored procedures, triggers, business logic in DB.\nâœ… Keep business logic in the service code (Go, Python, etc.).\nWhy?\nStored procedures reintroduce tight coupling to the DB vendor.\nHarder to test, version, and evolve in CI/CD pipelines.\nBreaks polyglot persistence (you canâ€™t easily switch DB type if all logic lives in the DB).\nWhat the DB Provides\nThe DBâ€™s main job is to guarantee ACID (within the boundary of a single microservice):\nAtomicity â€“ either a transaction fully succeeds or fails.\nConsistency â€“ constraints (foreign keys, uniqueness) remain valid.\nIsolation â€“ concurrent transactions donâ€™t corrupt each other.\nDurability â€“ once committed, data persists even after crashes.\nSo, the DB ensures local consistency for the serviceâ€™s own state. Global consistency across microservices is achieved via eventual consistency and patterns like Saga / Outbox / CQRS.\nPolyglot Persistence\nEach service can choose the best DB type for its domain:\nBilling â†’ PostgreSQL (ACID, strong transactions).\nAnalytics â†’ ClickHouse or BigQuery (fast aggregation).\nNotifications â†’ Redis (fast queues, ephemeral state).\nThis is possible only if business logic lives in services, not in DB stored procs.\nIn Practice\nâœ… Use DB for data storage, integrity, ACID.\nâœ… Service owns domain logic (validation, rules, workflows).\nâŒ Donâ€™t push domain logic into stored procedures.\nâŒ Donâ€™t let DB become the integration hub between services.\nâœ… Takeaway:\nIn microservices, the database is just a persistence layer. It gives you ACID for local service transactions, while business logic and cross-service coordination stay in the microservice code, not in the DB.\nğŸ“Œ Final Thoughts Go makes it easy to build fast, scalable, and maintainable SaaS microservices â€” no matter which API protocol youâ€™re working with. Understanding the strengths and trade-offs of REST, gRPC, GraphQL, WebSockets, and architectural patterns like CQRS helps you design the right interface for each part of your product.\nğŸš€ Follow me on norbix.dev for more insights on Go, Python, AI, system design, and engineering wisdom.\n","wordCount":"2145","inLanguage":"en","datePublished":"2025-04-22T21:00:00+02:00","dateModified":"2025-04-22T21:00:00+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://norbix.dev/posts/saas-microservices/"},"publisher":{"@type":"Organization","name":"norbix.dev - The log of my journey through code \u0026 software systems architecture","logo":{"@type":"ImageObject","url":"https://norbix.dev/favicon.ico"}}}</script></head><body><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://norbix.dev/ accesskey=h title="norbix.dev - The log of my journey through code & software systems architecture (Alt + H)">norbix.dev - The log of my journey through code & software systems architecture</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://norbix.dev/ title=Home><span>Home</span></a></li><li><a href=https://norbix.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://norbix.dev/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://norbix.dev/about/ title=About><span>About</span></a></li><li><a href=https://norbix.dev/index.xml title="ğŸ“¡ RSS"><span>ğŸ“¡ RSS</span></a></li></ul></nav></header><main><main id=main><article class=post-single><header class=post-header><h1 class=post-title>Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs</h1><span title='2025-04-22 21:00:00 +0200 +0200'>April 22, 2025</span></header><div class=post-content><nav class=table-of-contents><nav id=TableOfContents><ol><li><a href=#-why-use-go-for-saas-microservices>ğŸ—ï¸ Why Use Go for SaaS Microservices?</a></li><li><a href=#-saas-architecture-essentials>ğŸ§± SaaS Architecture Essentials</a></li><li><a href=#-rest-api-the-classic-workhorse>ğŸŒ <code>REST API</code>: The Classic Workhorse</a><ol><li><a href=#-use-when>âœ… Use When:</a></li><li><a href=#-go-libraries>ğŸ› ï¸ Go Libraries:</a></li></ol></li><li><a href=#-grpc-api-high-performance-internal-comms>âš¡ <code>gRPC API</code>: High-Performance Internal Comms</a><ol><li><a href=#-use-when-1>âœ… Use When:</a></li><li><a href=#-go-libraries-1>ğŸ› ï¸ Go Libraries:</a></li></ol></li><li><a href=#-graphql-flexible-queries-for-frontend-teams>ğŸ” GraphQL: Flexible Queries for Frontend Teams</a><ol><li><a href=#-use-when-2>âœ… Use When:</a></li><li><a href=#-go-libraries-2>ğŸ› ï¸ Go Libraries:</a></li></ol></li><li><a href=#-websockets-real-time-bi-directional-apis>ğŸ”„ WebSockets: Real-Time, Bi-Directional APIs</a><ol><li><a href=#-use-when-3>âœ… Use When:</a></li><li><a href=#-go-libraries-3>ğŸ› ï¸ Go Libraries:</a></li></ol></li><li><a href=#-cqrs-separating-read-and-write-paths>ğŸ“ CQRS: Separating Read and Write Paths</a><ol><li><a href=#-use-when-4>âœ… Use When:</a></li><li><a href=#-tools--patterns-in-go>âš™ï¸ Tools & Patterns in Go:</a></li></ol></li><li><a href=#-putting-it-all-together>ğŸ§© Putting It All Together</a></li><li><a href=#-dev-stack-for-saas-microservices-in-go>ğŸ› ï¸ Dev Stack for SaaS Microservices in Go</a></li><li><a href=#-saas-microservices-examples>â˜ï¸ SaaS Microservices Examples</a><ol><li><a href=#-e-commerce-platform>ğŸ›’ E-commerce Platform</a></li><li><a href=#-fintech--banking>ğŸ¦ FinTech / Banking</a></li><li><a href=#-saas--productivity-app>ğŸ“± SaaS / Productivity App</a></li><li><a href=#-mobility--ride-sharing>ğŸš— Mobility / Ride Sharing</a></li><li><a href=#-how-kong-fits-in>ğŸ”§ How Kong fits in</a></li></ol></li><li><a href=#-kongs-role>ğŸ¦ Kongâ€™s Role</a><ol><li><a href=#-flow-example-keycloak--kong--microservices>ğŸ”„ Flow Example (Keycloak â†’ Kong â†’ Microservices)</a></li><li><a href=#-visual-recap>ğŸ“Œ Visual Recap</a></li></ol></li><li><a href=#northsouth-vs-eastwest-traffic>Northâ€“South vs Eastâ€“West Traffic</a></li><li><a href=#-eventual-consistency-challenge-in-saas-microservices>â³ Eventual Consistency Challenge in SaaS Microservices</a></li><li><a href=#-microservices--databases-what-happens>ğŸ—„ï¸ Microservices + Databases: What Happens?</a></li><li><a href=#-database-role-in-microservices>ğŸ—„ï¸ Database Role in Microservices</a></li><li><a href=#-final-thoughts>ğŸ“Œ Final Thoughts</a></li></ol></nav></nav><p><img loading=lazy src=banner.jpg alt=banner></p><p><strong>&ldquo;SaaS products scale with services that talk â€” efficiently, flexibly, and reliably.&rdquo;</strong></p><p><code>Go (Golang)</code> has become a top-tier language for building scalable, cloud-native microservices â€” especially in the SaaS world. Its speed, simplicity, and rich concurrency model make it ideal for high-performance backends and multi-tenant systems.</p><p>In this article, weâ€™ll explore how to build <code>SaaS</code> microservices in Go, focusing on different API approaches â€” <code>REST</code>, <code>gRPC</code>, <code>GraphQL</code>, and <code>WebSockets</code> â€” and when to use each.</p><hr><h2 id=-why-use-go-for-saas-microservices>ğŸ—ï¸ Why Use Go for SaaS Microservices?</h2><ul><li><p>âš¡ Performance: Native compilation, low memory usage, fast startup.</p></li><li><p>ğŸ§µ Concurrency: Goroutines + channels = lightweight multitasking.</p></li><li><p>ğŸ”§ Tooling: Rich stdlib, simple testing, static binaries, fast CI/CD.</p></li><li><p>â˜ï¸ Cloud Native: Ideal for containerization and Kubernetes deployments.</p></li></ul><p><strong>Go hits the sweet spot between systems-level control and developer productivity.</strong></p><hr><h2 id=-saas-architecture-essentials>ğŸ§± SaaS Architecture Essentials</h2><ul><li><p>Service isolation (multi-tenant or multi-instance)</p></li><li><p>Stateless compute (for scalability)</p></li><li><p>Secure authentication and authorization</p></li><li><p>Observability (metrics, logs, traces)</p></li><li><p>Inter-service communication (APIs!)</p></li></ul><p><img loading=lazy src=saas.gif alt=saas></p><hr><h2 id=-rest-api-the-classic-workhorse>ğŸŒ <code>REST API</code>: The Classic Workhorse</h2><h3 id=-use-when>âœ… Use When:</h3><ul><li><p>You need browser and mobile-friendly APIs</p></li><li><p>Your consumers prefer HTTP+JSON</p></li><li><p>You prioritize simplicity and developer ergonomics</p></li></ul><h3 id=-go-libraries>ğŸ› ï¸ Go Libraries:</h3><ul><li><p>net/http (stdlib)</p></li><li><p><code>gin</code>, <code>chi</code>, <code>echo</code>, <code>fiber</code> (routers)</p></li><li><p><code>openapi</code>, <code>swagger</code>, <code>goa</code> (spec + docs)</p></li></ul><p><strong><code>REST API</code> is battle-tested, easy to cache, and easy to debug â€” ideal for public APIs or integrations.</strong></p><hr><h2 id=-grpc-api-high-performance-internal-comms>âš¡ <code>gRPC API</code>: High-Performance Internal Comms</h2><h3 id=-use-when-1>âœ… Use When:</h3><ul><li><p>You need fast, efficient, binary communication</p></li><li><p>You control both client and server</p></li><li><p>You&rsquo;re building service-to-service comms in a large SaaS platform</p></li></ul><h3 id=-go-libraries-1>ğŸ› ï¸ Go Libraries:</h3><ul><li><p>google.golang.org/grpc</p></li><li><p>Protocol Buffers (protoc, protoc-gen-go)</p></li><li><p>Envoy / gRPC-Gateway for REST interop</p></li></ul><p><strong><code>gRPC API</code> shines in <code>polyglot</code>, high-throughput microservice environments.</strong></p><hr><h2 id=-graphql-flexible-queries-for-frontend-teams>ğŸ” GraphQL: Flexible Queries for Frontend Teams</h2><h3 id=-use-when-2>âœ… Use When:</h3><ul><li><p>Frontend teams need control over data shape</p></li><li><p>You want to reduce overfetching/underfetching</p></li><li><p>You serve multiple frontends with different needs</p></li></ul><h3 id=-go-libraries-2>ğŸ› ï¸ Go Libraries:</h3><ul><li><p>99designs/gqlgen</p></li><li><p>graphql-go/graphql</p></li></ul><p><strong><code>GraphQL API</code> is great for B2B SaaS dashboards, admin panels, or multi-platform apps.</strong></p><hr><h2 id=-websockets-real-time-bi-directional-apis>ğŸ”„ WebSockets: Real-Time, Bi-Directional APIs</h2><h3 id=-use-when-3>âœ… Use When:</h3><ul><li><p>You need real-time updates (chat, collaboration, notifications)</p></li><li><p>Clients push and receive events</p></li></ul><h3 id=-go-libraries-3>ğŸ› ï¸ Go Libraries:</h3><ul><li><p>gorilla/websocket</p></li><li><p>nhooyr/websocket</p></li></ul><p><strong><code>WebSockets APIs</code> are ideal for modern SaaS apps with live user interactions.</strong></p><hr><h2 id=-cqrs-separating-read-and-write-paths>ğŸ“ CQRS: Separating Read and Write Paths</h2><p>The Command Query Responsibility Segregation (CQRS) pattern is often a great fit for SaaS microservices â€” especially when paired with event-driven architectures.</p><h3 id=-use-when-4>âœ… Use When:</h3><ul><li><p>You have complex domain logic or heavy reads vs light writes (or vice versa)</p></li><li><p>You want to decouple write models from read-optimized projections</p></li><li><p>You&rsquo;re building event-sourced systems</p></li></ul><h3 id=-tools--patterns-in-go>âš™ï¸ Tools & Patterns in Go:</h3><ul><li><p>Use separate structs/services for CommandHandlers and QueryHandlers</p></li><li><p>Event buses (e.g. go-nats, kafka-go, watermill)</p></li><li><p>Projection stores (Postgres, Redis, Elasticsearch, etc.)</p></li></ul><p><strong>CQRS enables scalability, flexibility, and clear separation of concerns â€” perfect for SaaS systems with evolving business logic and reporting needs.</strong></p><hr><h2 id=-putting-it-all-together>ğŸ§© Putting It All Together</h2><p>In a real SaaS platform, youâ€™ll likely mix protocols:</p><ul><li><p>REST for public APIs and onboarding</p></li><li><p>gRPC for internal service mesh</p></li><li><p>GraphQL for flexible frontend backends</p></li><li><p>WebSocket for interactive features</p></li></ul><p><strong>Use each where it fits best â€” Go makes switching easy.</strong></p><hr><h2 id=-dev-stack-for-saas-microservices-in-go>ğŸ› ï¸ Dev Stack for SaaS Microservices in Go</h2><ul><li><p><code>API Gateways</code>: Kong, Envoy, Traefik</p></li><li><p><code>Auth</code>: OAuth2, OIDC, JWT (with golang-jwt/jwt)</p></li><li><p><code>Service Discovery</code>: Consul, etcd, Kubernetes</p></li><li><p><code>Observability</code>: Prometheus, OpenTelemetry, Grafana</p></li><li><p><code>CI/CD</code>: GitHub Actions, Drone, ArgoCD</p></li></ul><p>API GW Kong Example:</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    Client[Client: Web, Mobile, Partner] --&gt;|HTTP/gRPC| Kong[Kong API Gateway]
    Kong --&gt;|Routing| Service1[Microservice A]
    Kong --&gt;|Routing| Service2[Microservice B]
    Kong --&gt;|Routing| Service3[Microservice C]

    Kong -.-&gt;|Auth, Rate Limit, Logging| Plugins[Plugins]
    Kong --&gt; Observability[Prometheus / Grafana / Logs]
</code></pre><hr><h2 id=-saas-microservices-examples>â˜ï¸ SaaS Microservices Examples</h2><h3 id=-e-commerce-platform>ğŸ›’ E-commerce Platform</h3><ul><li><p>User Service â€“ manages users, profiles, authentication data.</p></li><li><p>Catalog Service â€“ product listings, categories, search.</p></li><li><p>Order Service â€“ order placement, status tracking.</p></li><li><p>Payment Service â€“ handles credit cards, PayPal, Stripe.</p></li><li><p>Shipping Service â€“ shipping labels, delivery tracking.</p></li><li><p>Notification Service â€“ emails, SMS, push notifications.</p></li></ul><h3 id=-fintech--banking>ğŸ¦ FinTech / Banking</h3><ul><li><p>Customer Service â€“ KYC, customer info.</p></li><li><p>Account Service â€“ bank accounts, balances.</p></li><li><p>Transaction Service â€“ transfers, deposits, withdrawals.</p></li><li><p>Fraud Detection Service â€“ anomaly detection.</p></li><li><p>Reporting Service â€“ statements, analytics.</p></li></ul><h3 id=-saas--productivity-app>ğŸ“± SaaS / Productivity App</h3><ul><li><p>Auth Service â€“ login, OAuth2, JWT issuance (could be Keycloak).</p></li><li><p>Docs Service â€“ document storage and editing.</p></li><li><p>Comments Service â€“ threaded discussions.</p></li><li><p>Billing Service â€“ subscriptions, invoices.</p></li><li><p>Search Service â€“ full-text search across documents.</p></li></ul><h3 id=-mobility--ride-sharing>ğŸš— Mobility / Ride Sharing</h3><ul><li><p>Driver Service â€“ driver registration, availability.</p></li><li><p>Rider Service â€“ customer profiles.</p></li><li><p>Ride Matching Service â€“ matches drivers â†” riders.</p></li><li><p>Payment Service â€“ fare calculation + payment.</p></li><li><p>Location Service â€“ maps, GPS tracking.</p></li></ul><h3 id=-how-kong-fits-in>ğŸ”§ How Kong fits in</h3><p>Kong sits at the edge and routes requests:</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart TB
    Client[Mobile / Web Client] --&gt; Kong[Kong API Gateway]

    Kong --&gt; UserService[User Service]
    Kong --&gt; OrderService[Order Service]
    Kong --&gt; PaymentService[Payment Service]
    Kong --&gt; NotificationService[Notification Service]

    Kong -.-&gt;|Auth, Rate Limiting, JWT Validation| Keycloak[(Keycloak)]
</code></pre><hr><h2 id=-kongs-role>ğŸ¦ Kongâ€™s Role</h2><p>Kong sits as the API Gateway at the edge of your system.
It acts as the single entry point for all clients (web apps, mobile apps, partner APIs).</p><p>Instead of each client needing to know where every service lives, they all talk to Kong â€” and Kong handles:</p><p>Routing â€“ decides which microservice should get the request.</p><p>Authentication & Authorization â€“ validates JWT tokens (from Keycloak, for example).</p><p>Rate Limiting â€“ prevents abuse (e.g., 100 requests/sec max).</p><p>Observability â€“ logs, metrics, traces.</p><p>Transformations â€“ rewrites headers, payloads, or even protocols.</p><h3 id=-flow-example-keycloak--kong--microservices>ğŸ”„ Flow Example (Keycloak â†’ Kong â†’ Microservices)</h3><ol><li><p>Client authenticates with Keycloak</p><ul><li><p>Redirects user to Keycloak login page.</p></li><li><p>Receives a JWT access token (and optionally a refresh token).</p></li><li><p>Stores token locally (browser storage, app memory).</p></li></ul></li><li><p>Client sends request with JWT</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>GET https://api.saas.com/docs/123
</span></span><span class=line><span class=cl>Authorization: Bearer &lt;JWT from Keycloak&gt;
</span></span></code></pre></td></tr></table></div></div></li><li><p>Kong receives the request</p><ul><li><p>Validates JWT using OIDC plugin against Keycloakâ€™s public keys.</p></li><li><p>Applies rate limiting plugin (e.g., 10 req/s per user).</p></li><li><p>Logs the request (Prometheus/Grafana integration).</p></li></ul></li><li><p>Kong routes the request</p><ul><li><p>/docs/* â†’ goes to Docs Service</p></li><li><p>/billing/* â†’ goes to Billing Service</p></li><li><p>/auth/* â†’ goes to Auth Service</p></li><li><p>Kong uses an internal service registry (DB or declarative YAML).</p></li></ul></li><li><p>Microservice processes request</p><ul><li><p>Docs Service fetches document #123 from storage.</p></li><li><p>If it needs to notify the user, it may call Notification Service internally.</p></li></ul></li><li><p>Response back to client</p><ul><li><p>Kong passes the response through.</p></li><li><p>Optionally adds headers, strips sensitive data, or transforms payloads.</p></li></ul></li></ol><h3 id=-visual-recap>ğŸ“Œ Visual Recap</h3><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart TB
    subgraph Auth[&#34;Keycloak Authentication&#34;]
        Keycloak[&#34;Keycloak OIDC Provider&#34;]
    end

    subgraph Observability[&#34;Observability &amp; Logs&#34;]
        Logs[&#34;Prometheus / Grafana / ELK / Datadog&#34;]
    end

    Client[&#34;Web / Mobile App&#34;] --&gt;|&#34;Login &amp; Fetch JWT&#34;| Keycloak
    Client --&gt;|&#34;Bearer JWT&#34;| Kong[&#34;Kong API Gateway&#34;]

    Kong --&gt;|&#34;Verify JWT&#34;| Keycloak
    Kong --&gt; Logs

    Kong --&gt; AuthService[&#34;Auth Service&#34;]
    Kong --&gt; DocsService[&#34;Docs Service&#34;]
    Kong --&gt; CommentsService[&#34;Comments Service&#34;]
    Kong --&gt; BillingService[&#34;Billing Service&#34;]
    Kong --&gt; NotificationsService[&#34;Notifications Service&#34;]
</code></pre><ul><li><p>Clients must fetch JWT from Keycloak in advance.</p></li><li><p>Kong validates JWT and enforces policies.</p></li><li><p>Microservices stay focused on business logic.</p></li><li><p>Routes traffic to the correct service.</p></li><li><p>Adds cross-cutting features (logging, rate limiting, security).</p></li></ul><p>âœ… In short: Kong is the traffic cop + security guard + auditor in front of your microservices.</p><h2 id=northsouth-vs-eastwest-traffic>Northâ€“South vs Eastâ€“West Traffic</h2><p>The northâ€“south traffic refers to requests coming into the system from external clients (like web or mobile apps) and going out to them. This is typically handled by the API Gateway (Kong in our case).</p><p>The eastâ€“west traffic refers to communication between internal services within the system. This is where microservices talk to each other to fulfill requests, share data, or trigger actions.</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart TB
    subgraph External[&#34;ğŸŒ External Clients&#34;]
        Client[&#34;ğŸ‘©â€ğŸ’» Web / ğŸ“± Mobile App&#34;]
    end

    subgraph DataCenter[&#34;ğŸ¢ Data Center / Cloud&#34;]
        Kong[&#34;ğŸ¦ API Gateway (Kong)&#34;]

        subgraph Services[&#34;Microservices&#34;]
            AuthService[&#34;ğŸ” Auth Service&#34;]
            DocsService[&#34;ğŸ“„ Docs Service&#34;]
            BillingService[&#34;ğŸ’³ Billing Service&#34;]
            NotificationService[&#34;ğŸ“¢ Notification Service&#34;]
        end
    end

    %% North-South traffic
    Client --&gt;|&#34;Northâ€“South Traffic&#34;| Kong

    %% Routing from Kong to services
    Kong --&gt; AuthService
    Kong --&gt; DocsService
    Kong --&gt; BillingService
    Kong --&gt; NotificationService

    %% East-West traffic inside services
    DocsService --&gt;|&#34;Eastâ€“West Traffic&#34;| BillingService
    BillingService --&gt; NotificationService
</code></pre><hr><h2 id=-eventual-consistency-challenge-in-saas-microservices>â³ Eventual Consistency Challenge in SaaS Microservices</h2><p>When you split a SaaS platform into many independent services, you also split the data. That means synchronous strong consistency (like in a single SQL database) becomes hard â€” or impossible â€” to guarantee.</p><p>Instead, many SaaS systems rely on eventual consistency:</p><p>A user action triggers an event in one service.</p><p>That event propagates asynchronously to other services.</p><p>Different services may see different states for a short time.</p><p>Eventually, all services converge to the same consistent state.</p><p>âš ï¸ Why This Matters</p><p>Billing vs Orders: a customerâ€™s order might be visible immediately, but billing might update a few seconds later.</p><p>Search vs Writes: you save a new document, but it doesnâ€™t show up in search until the indexer processes the event.</p><p>Notifications: a user adds a comment, but notifications are sent asynchronously.</p><p>ğŸ› ï¸ How to Handle It</p><p>Idempotency â€“ design APIs so that replaying messages doesnâ€™t create duplicates.</p><p>Retries with backoff â€“ transient failures are normal in async flows.</p><p>Compensating actions â€“ e.g., if payment fails, cancel the order (Saga pattern).</p><p>User experience cues â€“ show â€œprocessingâ€¦â€ states to set expectations.</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>sequenceDiagram
    participant Client
    participant OrderService
    participant BillingService
    participant NotificationService

    Client-&gt;&gt;OrderService: Place Order
    OrderService--&gt;&gt;BillingService: Event: OrderCreated
    OrderService--&gt;&gt;NotificationService: Event: OrderCreated
    BillingService--&gt;&gt;NotificationService: Event: PaymentSucceeded
    Note over Client,NotificationService: Notifications &amp; billing may lag &lt;br/&gt; behind the order creation, &lt;br/&gt; but system converges eventually
</code></pre><p>âœ… Takeaway: In SaaS microservices, consistency is a spectrum. Accepting temporary inconsistency â€” and designing for it â€” is key to resilience and scalability.</p><h2 id=-microservices--databases-what-happens>ğŸ—„ï¸ Microservices + Databases: What Happens?</h2><ol><li><p>Data Ownership</p><ul><li><p>Each microservice is responsible for its own schema.</p></li><li><p>No other service can directly query or update its DB.</p></li><li><p>Example:</p><ul><li><p>Order Service has orders table.</p></li><li><p>Billing Service has invoices table.</p></li><li><p>User Service has users table.</p></li></ul></li></ul><p>This ensures loose coupling and independent evolution.</p></li><li><p>The Consistency Problem</p><ul><li><p>A single business transaction (e.g. â€œPlace Order and Charge Paymentâ€) now touches multiple DBs.</p></li><li><p>Distributed transactions (2PC, XA) are rarely practical in cloud SaaS (complex, slow, brittle).</p></li><li><p>Instead, we use eventual consistency.</p></li></ul></li><li><p>How It Works</p><ul><li><p>Order Service writes new order into its DB.</p></li><li><p>It publishes an OrderCreated event (via Kafka, NATS, RabbitMQ, etc.).</p></li><li><p>Billing Service consumes the event and writes into its DB.</p></li><li><p>Notification Service consumes the same event to send a message.</p></li><li><p>All services eventually agree, though not instantly.</p></li></ul></li><li><p>Patterns to Solve It</p><ul><li><p>Event Sourcing â€“ source of truth is the event log, DBs are projections.</p></li><li><p>CQRS â€“ separate command (writes) and query (reads) models.</p></li><li><p>Saga Pattern â€“ long-running transactions split into steps with compensations if something fails.</p></li><li><p>Outbox Pattern â€“ ensure DB writes and event publishes happen atomically (avoids lost events).</p></li></ul></li><li><p>Example Flow (Saga for Order + Billing)</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>sequenceDiagram
 participant Client
 participant OrderService
 participant BillingService
 participant NotificationService

 Client-&gt;&gt;OrderService: Place Order
 OrderService-&gt;&gt;OrderDB: Insert Order(status=pending)
 OrderService--&gt;&gt;BillingService: Event(OrderCreated)

 BillingService-&gt;&gt;BillingDB: Create Invoice
 BillingService--&gt;&gt;OrderService: Event(PaymentSucceeded)

 OrderService-&gt;&gt;OrderDB: Update Order(status=confirmed)
 OrderService--&gt;&gt;NotificationService: Event(OrderConfirmed)
 NotificationService-&gt;&gt;NotificationDB: Send Confirmation
</code></pre></li></ol><p>âœ… Key takeaway:</p><p>When each microservice has its own DB:</p><ul><li><p>You trade immediate consistency for autonomy + scalability.</p></li><li><p>You must embrace eventual consistency and implement resilience patterns (Sagas, Outbox, CQRS).</p></li></ul><hr><h2 id=-database-role-in-microservices>ğŸ—„ï¸ Database Role in Microservices</h2><ol><li><p>Microservice Owns the DB</p><ul><li><p>Each microservice has its own private database.</p></li><li><p>No other service can directly read/write it.</p></li><li><p>Database is part of the serviceâ€™s implementation detail, not a shared integration layer.</p></li></ul></li><li><p>Stored Procedures?</p><ul><li><p>In modern SaaS microservices:</p><ul><li><p>âŒ Avoid heavy stored procedures, triggers, business logic in DB.</p></li><li><p>âœ… Keep business logic in the service code (Go, Python, etc.).</p></li></ul></li><li><p>Why?</p><ul><li><p>Stored procedures reintroduce tight coupling to the DB vendor.</p></li><li><p>Harder to test, version, and evolve in CI/CD pipelines.</p></li><li><p>Breaks polyglot persistence (you canâ€™t easily switch DB type if all logic lives in the DB).</p></li></ul></li></ul></li><li><p>What the DB Provides</p></li></ol><p>The DBâ€™s main job is to guarantee ACID (within the boundary of a single microservice):</p><p><code>Atomicity</code> â€“ either a transaction fully succeeds or fails.</p><p><code>Consistency</code> â€“ constraints (foreign keys, uniqueness) remain valid.</p><p><code>Isolation</code> â€“ concurrent transactions donâ€™t corrupt each other.</p><p><code>Durability</code> â€“ once committed, data persists even after crashes.</p><p>So, the DB ensures local consistency for the serviceâ€™s own state.
Global consistency across microservices is achieved via eventual consistency and patterns like Saga / Outbox / CQRS.</p><ol><li><p>Polyglot Persistence</p><ul><li><p>Each service can choose the best DB type for its domain:</p><ul><li><p>Billing â†’ PostgreSQL (ACID, strong transactions).</p></li><li><p>Analytics â†’ ClickHouse or BigQuery (fast aggregation).</p></li><li><p>Notifications â†’ Redis (fast queues, ephemeral state).</p></li></ul></li><li><p>This is possible only if business logic lives in services, not in DB stored procs.</p></li></ul></li><li><p>In Practice</p><ul><li><p>âœ… Use DB for data storage, integrity, ACID.</p></li><li><p>âœ… Service owns domain logic (validation, rules, workflows).</p></li><li><p>âŒ Donâ€™t push domain logic into stored procedures.</p></li><li><p>âŒ Donâ€™t let DB become the integration hub between services.</p></li></ul></li></ol><p>âœ… Takeaway:</p><p>In microservices, the database is just a persistence layer.
It gives you ACID for local service transactions, while business logic and cross-service coordination stay in the microservice code, not in the DB.</p><hr><h2 id=-final-thoughts>ğŸ“Œ Final Thoughts</h2><p>Go makes it easy to build fast, scalable, and maintainable SaaS microservices â€” no matter which API protocol you&rsquo;re working with. Understanding the strengths and trade-offs of REST, gRPC, GraphQL, WebSockets, and architectural patterns like CQRS helps you design the right interface for each part of your product.</p><hr><p>ğŸš€ Follow me on <a href=https://norbix.dev>norbix.dev</a> for more insights on Go, Python, AI, system design, and engineering wisdom.</p></div><div class=post-subscribe><style>.subscribe-form{display:flex;gap:.5rem;margin-top:1rem;align-items:center}.subscribe-form input[type=email]{padding:.5rem;border-radius:6px;border:1px solid #ccc;background-color:#1f1f1f;color:#fff}.subscribe-form input[type=submit],.subscribe-form button{padding:.5rem 1rem;border-radius:6px;background-color:#facc15;color:#000;border:none;cursor:pointer;font-weight:700}.subscribe-form input[type=submit]:hover{background-color:#fcd34d}</style><form action=https://buttondown.email/api/emails/embed-subscribe/norbix method=post target=popupwindow onsubmit='window.open("https://buttondown.email/norbix","popupwindow")' class=subscribe-form><input type=email name=email placeholder="Enter your email" required>
<input type=submit value=Subscribe></form><p style=font-size:.875rem;opacity:.6>Powered by Buttondown.</p></div><div class=post-comments><script src=https://giscus.app/client.js data-repo=norbix/norbix.dev data-repo-id=R_kgDOOV_xMQ data-category=Announcements data-category-id=DIC_kwDOOV_xMc4CpF5M data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=dark data-lang=en crossorigin=anonymous async></script></div><nav class=paginav><a class=prev href=https://norbix.dev/posts/platform-engineering/><span class=title>Â« Prev</span><br><span>Platform Engineering: The DevOps You Productize</span>
</a><a class=next href=https://norbix.dev/posts/databases/><span class=title>Next Â»</span><br><span>Understanding Databases: B-Trees, SQL, NoSQL, ACID, and Normalization</span></a></nav></article></main></main><footer class=footer><span>&copy; 2025 <a href=https://norbix.dev/>norbix.dev - The log of my journey through code & software systems architecture</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script src=https://platform.linkedin.com/badges/js/profile.js async defer type=text/javascript></script></body></html>
<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><script>(function(){const e=localStorage.getItem("theme"),t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches;e==="dark"||!e&&t?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark"),window.setTheme=function(e){localStorage.setItem("theme",e),document.documentElement.classList.toggle("dark",e==="dark")}})()</script><title>Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs | norbix.dev
</title><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs | norbix.dev - The log of my journey through code & software systems architecture</title>
<meta name=keywords content="go,saas,microservices,grpc,rest,graphql,websockets"><meta name=description content="Explore how to build SaaS-ready microservices in Go using REST, gRPC, GraphQL, and WebSockets. Learn the trade-offs, use cases, and tooling for each API style."><meta name=author content><link rel=canonical href=https://norbix.dev/posts/saas-microservices/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://norbix.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://norbix.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://norbix.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://norbix.dev/apple-touch-icon.png><link rel=mask-icon href=https://norbix.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://norbix.dev/posts/saas-microservices/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=canonical href=https://norbix.dev/posts/saas-microservices/><meta property="og:title" content="Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs"><meta property="og:url" content="https://norbix.dev/posts/saas-microservices/"><meta property="og:image" content="https://norbix.dev/saas-go-banner.jpg"><meta property="og:type" content="article"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs"><meta name=twitter:image content="https://norbix.dev/saas-go-banner.jpg"><script data-goatcounter=https://norbix.goatcounter.com/count async src=//gc.zgo.at/count.js></script><link rel=alternate type=application/rss+xml title="RSS Feed for norbix.dev" href=/index.xml><script src=https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js defer></script><script>document.addEventListener("DOMContentLoaded",function(){window.mermaid&&(document.querySelectorAll("code.language-mermaid").forEach(function(e){var n=e.parentElement,t=document.createElement("div");t.className="mermaid",t.textContent=e.textContent,n.replaceWith(t)}),mermaid.initialize({startOnLoad:!0}))})</script><link href=https://cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.3/css/lightbox.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.3/js/lightbox.min.js defer></script><meta property="og:title" content="Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs"><meta property="og:description" content="Explore how to build SaaS-ready microservices in Go using REST, gRPC, GraphQL, and WebSockets. Learn the trade-offs, use cases, and tooling for each API style."><meta property="og:type" content="article"><meta property="og:url" content="https://norbix.dev/posts/saas-microservices/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-22T21:00:00+02:00"><meta property="article:modified_time" content="2025-04-22T21:00:00+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs"><meta name=twitter:description content="Explore how to build SaaS-ready microservices in Go using REST, gRPC, GraphQL, and WebSockets. Learn the trade-offs, use cases, and tooling for each API style."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://norbix.dev/posts/"},{"@type":"ListItem","position":2,"name":"Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs","item":"https://norbix.dev/posts/saas-microservices/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs","name":"Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs","description":"Explore how to build SaaS-ready microservices in Go using REST, gRPC, GraphQL, and WebSockets. Learn the trade-offs, use cases, and tooling for each API style.","keywords":["go","saas","microservices","grpc","rest","graphql","websockets"],"articleBody":" ‚ÄúSaaS products scale with services that talk ‚Äî efficiently, flexibly, and reliably.‚Äù\nGo (Golang) has become a top-tier language for building scalable, cloud-native microservices ‚Äî especially in the SaaS world. Its speed, simplicity, and rich concurrency model make it ideal for high-performance backends and multi-tenant systems.\nIn this article, we‚Äôll explore how to build SaaS microservices in Go, focusing on different API approaches ‚Äî REST, gRPC, GraphQL, and WebSockets ‚Äî and when to use each.\nüèóÔ∏è Why Use Go for SaaS Microservices? ‚ö° Performance: Native compilation, low memory usage, fast startup.\nüßµ Concurrency: Goroutines + channels = lightweight multitasking.\nüîß Tooling: Rich stdlib, simple testing, static binaries, fast CI/CD.\n‚òÅÔ∏è Cloud Native: Ideal for containerization and Kubernetes deployments.\nGo hits the sweet spot between systems-level control and developer productivity.\nüß± SaaS Architecture Essentials Service isolation (multi-tenant or multi-instance)\nStateless compute (for scalability)\nSecure authentication and authorization\nObservability (metrics, logs, traces)\nInter-service communication (APIs!)\nüåê REST API: The Classic Workhorse ‚úÖ Use When: You need browser and mobile-friendly APIs\nYour consumers prefer HTTP+JSON\nYou prioritize simplicity and developer ergonomics\nüõ†Ô∏è Go Libraries: net/http (stdlib)\ngin, chi, echo, fiber (routers)\nopenapi, swagger, goa (spec + docs)\nREST API is battle-tested, easy to cache, and easy to debug ‚Äî ideal for public APIs or integrations.\n‚ö° gRPC API: High-Performance Internal Comms ‚úÖ Use When: You need fast, efficient, binary communication\nYou control both client and server\nYou‚Äôre building service-to-service comms in a large SaaS platform\nüõ†Ô∏è Go Libraries: google.golang.org/grpc\nProtocol Buffers (protoc, protoc-gen-go)\nEnvoy / gRPC-Gateway for REST interop\ngRPC API shines in polyglot, high-throughput microservice environments.\nüîç GraphQL: Flexible Queries for Frontend Teams ‚úÖ Use When: Frontend teams need control over data shape\nYou want to reduce overfetching/underfetching\nYou serve multiple frontends with different needs\nüõ†Ô∏è Go Libraries: 99designs/gqlgen\ngraphql-go/graphql\nGraphQL API is great for B2B SaaS dashboards, admin panels, or multi-platform apps.\nüîÑ WebSockets: Real-Time, Bi-Directional APIs ‚úÖ Use When: You need real-time updates (chat, collaboration, notifications)\nClients push and receive events\nüõ†Ô∏è Go Libraries: gorilla/websocket\nnhooyr/websocket\nWebSockets APIs are ideal for modern SaaS apps with live user interactions.\nüìê CQRS: Separating Read and Write Paths The Command Query Responsibility Segregation (CQRS) pattern is often a great fit for SaaS microservices ‚Äî especially when paired with event-driven architectures.\n‚úÖ Use When: You have complex domain logic or heavy reads vs light writes (or vice versa)\nYou want to decouple write models from read-optimized projections\nYou‚Äôre building event-sourced systems\n‚öôÔ∏è Tools \u0026 Patterns in Go: Use separate structs/services for CommandHandlers and QueryHandlers\nEvent buses (e.g. go-nats, kafka-go, watermill)\nProjection stores (Postgres, Redis, Elasticsearch, etc.)\nCQRS enables scalability, flexibility, and clear separation of concerns ‚Äî perfect for SaaS systems with evolving business logic and reporting needs.\nüß© Putting It All Together In a real SaaS platform, you‚Äôll likely mix protocols:\nREST for public APIs and onboarding\ngRPC for internal service mesh\nGraphQL for flexible frontend backends\nWebSocket for interactive features\nUse each where it fits best ‚Äî Go makes switching easy.\nüõ†Ô∏è Dev Stack for SaaS Microservices in Go API Gateways: Kong, Envoy, Traefik\nAuth: OAuth2, OIDC, JWT (with golang-jwt/jwt)\nService Discovery: Consul, etcd, Kubernetes\nObservability: Prometheus, OpenTelemetry, Grafana\nCI/CD: GitHub Actions, Drone, ArgoCD\nAPI GW Kong Example:\nflowchart LR Client[Client: Web, Mobile, Partner] --\u003e|HTTP/gRPC| Kong[Kong API Gateway] Kong --\u003e|Routing| Service1[Microservice A] Kong --\u003e|Routing| Service2[Microservice B] Kong --\u003e|Routing| Service3[Microservice C] Kong -.-\u003e|Auth, Rate Limit, Logging| Plugins[Plugins] Kong --\u003e Observability[Prometheus / Grafana / Logs] ‚òÅÔ∏è SaaS Microservices Examples üõí E-commerce Platform User Service ‚Äì manages users, profiles, authentication data.\nCatalog Service ‚Äì product listings, categories, search.\nOrder Service ‚Äì order placement, status tracking.\nPayment Service ‚Äì handles credit cards, PayPal, Stripe.\nShipping Service ‚Äì shipping labels, delivery tracking.\nNotification Service ‚Äì emails, SMS, push notifications.\nüè¶ FinTech / Banking Customer Service ‚Äì KYC, customer info.\nAccount Service ‚Äì bank accounts, balances.\nTransaction Service ‚Äì transfers, deposits, withdrawals.\nFraud Detection Service ‚Äì anomaly detection.\nReporting Service ‚Äì statements, analytics.\nüì± SaaS / Productivity App Auth Service ‚Äì login, OAuth2, JWT issuance (could be Keycloak).\nDocs Service ‚Äì document storage and editing.\nComments Service ‚Äì threaded discussions.\nBilling Service ‚Äì subscriptions, invoices.\nSearch Service ‚Äì full-text search across documents.\nüöó Mobility / Ride Sharing Driver Service ‚Äì driver registration, availability.\nRider Service ‚Äì customer profiles.\nRide Matching Service ‚Äì matches drivers ‚Üî riders.\nPayment Service ‚Äì fare calculation + payment.\nLocation Service ‚Äì maps, GPS tracking.\nüîß How Kong fits in Kong sits at the edge and routes requests:\nflowchart TB Client[Mobile / Web Client] --\u003e Kong[Kong API Gateway] Kong --\u003e UserService[User Service] Kong --\u003e OrderService[Order Service] Kong --\u003e PaymentService[Payment Service] Kong --\u003e NotificationService[Notification Service] Kong -.-\u003e|Auth, Rate Limiting, JWT Validation| Keycloak[(Keycloak)] ü¶ç Kong‚Äôs Role Kong sits as the API Gateway at the edge of your system. It acts as the single entry point for all clients (web apps, mobile apps, partner APIs).\nInstead of each client needing to know where every service lives, they all talk to Kong ‚Äî and Kong handles:\nRouting ‚Äì decides which microservice should get the request.\nAuthentication \u0026 Authorization ‚Äì validates JWT tokens (from Keycloak, for example).\nRate Limiting ‚Äì prevents abuse (e.g., 100 requests/sec max).\nObservability ‚Äì logs, metrics, traces.\nTransformations ‚Äì rewrites headers, payloads, or even protocols.\nüîÑ Flow Example (Keycloak ‚Üí Kong ‚Üí Microservices) Client authenticates with Keycloak\nRedirects user to Keycloak login page.\nReceives a JWT access token (and optionally a refresh token).\nStores token locally (browser storage, app memory).\nClient sends request with JWT\n1 2 GET https://api.saas.com/docs/123 Authorization: Bearer Kong receives the request\nValidates JWT using OIDC plugin against Keycloak‚Äôs public keys.\nApplies rate limiting plugin (e.g., 10 req/s per user).\nLogs the request (Prometheus/Grafana integration).\nKong routes the request\n/docs/* ‚Üí goes to Docs Service\n/billing/* ‚Üí goes to Billing Service\n/auth/* ‚Üí goes to Auth Service\nKong uses an internal service registry (DB or declarative YAML).\nMicroservice processes request\nDocs Service fetches document #123 from storage.\nIf it needs to notify the user, it may call Notification Service internally.\nResponse back to client\nKong passes the response through.\nOptionally adds headers, strips sensitive data, or transforms payloads.\nüìå Visual Recap flowchart TB subgraph Auth[\"Keycloak Authentication\"] Keycloak[\"Keycloak OIDC Provider\"] end Client[\"Web / Mobile App\"] --\u003e|\"Login \u0026 Fetch JWT\"| Keycloak Client --\u003e|\"Bearer JWT\"| Kong[\"Kong API Gateway\"] Kong --\u003e AuthService[\"Auth Service\"] Kong --\u003e DocsService[\"Docs Service\"] Kong --\u003e CommentsService[\"Comments Service\"] Kong --\u003e BillingService[\"Billing Service\"] Kong --\u003e NotificationsService[\"Notifications Service\"] Clients must fetch JWT from Keycloak in advance.\nKong validates JWT and enforces policies.\nMicroservices stay focused on business logic.\nRoutes traffic to the correct service.\nAdds cross-cutting features (logging, rate limiting, security).\n‚úÖ In short: Kong is the traffic cop + security guard + auditor in front of your microservices.\nüìå Final Thoughts Go makes it easy to build fast, scalable, and maintainable SaaS microservices ‚Äî no matter which API protocol you‚Äôre working with. Understanding the strengths and trade-offs of REST, gRPC, GraphQL, WebSockets, and architectural patterns like CQRS helps you design the right interface for each part of your product.\nüöÄ Follow me on norbix.dev for more insights on Go, Python, AI, system design, and engineering wisdom.\n","wordCount":"1184","inLanguage":"en","datePublished":"2025-04-22T21:00:00+02:00","dateModified":"2025-04-22T21:00:00+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://norbix.dev/posts/saas-microservices/"},"publisher":{"@type":"Organization","name":"norbix.dev - The log of my journey through code \u0026 software systems architecture","logo":{"@type":"ImageObject","url":"https://norbix.dev/favicon.ico"}}}</script></head><body><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://norbix.dev/ accesskey=h title="norbix.dev - The log of my journey through code & software systems architecture (Alt + H)">norbix.dev - The log of my journey through code & software systems architecture</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://norbix.dev/ title=Home><span>Home</span></a></li><li><a href=https://norbix.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://norbix.dev/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://norbix.dev/about/ title=About><span>About</span></a></li><li><a href=https://norbix.dev/index.xml title="üì° RSS"><span>üì° RSS</span></a></li></ul></nav></header><main><main id=main><article class=post-single><header class=post-header><h1 class=post-title>Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs</h1><span title='2025-04-22 21:00:00 +0200 +0200'>April 22, 2025</span></header><div class=post-content><nav class=table-of-contents><nav id=TableOfContents><ul><li><a href=#-why-use-go-for-saas-microservices>üèóÔ∏è Why Use Go for SaaS Microservices?</a></li><li><a href=#-saas-architecture-essentials>üß± SaaS Architecture Essentials</a></li><li><a href=#-rest-api-the-classic-workhorse>üåê <code>REST API</code>: The Classic Workhorse</a><ul><li><a href=#-use-when>‚úÖ Use When:</a></li><li><a href=#-go-libraries>üõ†Ô∏è Go Libraries:</a></li></ul></li><li><a href=#-grpc-api-high-performance-internal-comms>‚ö° <code>gRPC API</code>: High-Performance Internal Comms</a><ul><li><a href=#-use-when-1>‚úÖ Use When:</a></li><li><a href=#-go-libraries-1>üõ†Ô∏è Go Libraries:</a></li></ul></li><li><a href=#-graphql-flexible-queries-for-frontend-teams>üîç GraphQL: Flexible Queries for Frontend Teams</a><ul><li><a href=#-use-when-2>‚úÖ Use When:</a></li><li><a href=#-go-libraries-2>üõ†Ô∏è Go Libraries:</a></li></ul></li><li><a href=#-websockets-real-time-bi-directional-apis>üîÑ WebSockets: Real-Time, Bi-Directional APIs</a><ul><li><a href=#-use-when-3>‚úÖ Use When:</a></li><li><a href=#-go-libraries-3>üõ†Ô∏è Go Libraries:</a></li></ul></li><li><a href=#-cqrs-separating-read-and-write-paths>üìê CQRS: Separating Read and Write Paths</a><ul><li><a href=#-use-when-4>‚úÖ Use When:</a></li><li><a href=#-tools--patterns-in-go>‚öôÔ∏è Tools & Patterns in Go:</a></li></ul></li><li><a href=#-putting-it-all-together>üß© Putting It All Together</a></li><li><a href=#-dev-stack-for-saas-microservices-in-go>üõ†Ô∏è Dev Stack for SaaS Microservices in Go</a></li><li><a href=#-saas-microservices-examples>‚òÅÔ∏è SaaS Microservices Examples</a><ul><li><a href=#-e-commerce-platform>üõí E-commerce Platform</a></li><li><a href=#-fintech--banking>üè¶ FinTech / Banking</a></li><li><a href=#-saas--productivity-app>üì± SaaS / Productivity App</a></li><li><a href=#-mobility--ride-sharing>üöó Mobility / Ride Sharing</a></li><li><a href=#-how-kong-fits-in>üîß How Kong fits in</a></li></ul></li><li><a href=#-kongs-role>ü¶ç Kong‚Äôs Role</a><ul><li><a href=#-flow-example-keycloak--kong--microservices>üîÑ Flow Example (Keycloak ‚Üí Kong ‚Üí Microservices)</a></li><li><a href=#-visual-recap>üìå Visual Recap</a></li></ul></li><li><a href=#-final-thoughts>üìå Final Thoughts</a></li></ul></nav></nav><p><img loading=lazy src=banner.jpg alt=banner></p><p><strong>&ldquo;SaaS products scale with services that talk ‚Äî efficiently, flexibly, and reliably.&rdquo;</strong></p><p><code>Go (Golang)</code> has become a top-tier language for building scalable, cloud-native microservices ‚Äî especially in the SaaS world. Its speed, simplicity, and rich concurrency model make it ideal for high-performance backends and multi-tenant systems.</p><p>In this article, we‚Äôll explore how to build <code>SaaS</code> microservices in Go, focusing on different API approaches ‚Äî <code>REST</code>, <code>gRPC</code>, <code>GraphQL</code>, and <code>WebSockets</code> ‚Äî and when to use each.</p><hr><h2 id=-why-use-go-for-saas-microservices>üèóÔ∏è Why Use Go for SaaS Microservices?</h2><ul><li><p>‚ö° Performance: Native compilation, low memory usage, fast startup.</p></li><li><p>üßµ Concurrency: Goroutines + channels = lightweight multitasking.</p></li><li><p>üîß Tooling: Rich stdlib, simple testing, static binaries, fast CI/CD.</p></li><li><p>‚òÅÔ∏è Cloud Native: Ideal for containerization and Kubernetes deployments.</p></li></ul><p><strong>Go hits the sweet spot between systems-level control and developer productivity.</strong></p><hr><h2 id=-saas-architecture-essentials>üß± SaaS Architecture Essentials</h2><ul><li><p>Service isolation (multi-tenant or multi-instance)</p></li><li><p>Stateless compute (for scalability)</p></li><li><p>Secure authentication and authorization</p></li><li><p>Observability (metrics, logs, traces)</p></li><li><p>Inter-service communication (APIs!)</p></li></ul><hr><h2 id=-rest-api-the-classic-workhorse>üåê <code>REST API</code>: The Classic Workhorse</h2><h3 id=-use-when>‚úÖ Use When:</h3><ul><li><p>You need browser and mobile-friendly APIs</p></li><li><p>Your consumers prefer HTTP+JSON</p></li><li><p>You prioritize simplicity and developer ergonomics</p></li></ul><h3 id=-go-libraries>üõ†Ô∏è Go Libraries:</h3><ul><li><p>net/http (stdlib)</p></li><li><p><code>gin</code>, <code>chi</code>, <code>echo</code>, <code>fiber</code> (routers)</p></li><li><p><code>openapi</code>, <code>swagger</code>, <code>goa</code> (spec + docs)</p></li></ul><p><strong><code>REST API</code> is battle-tested, easy to cache, and easy to debug ‚Äî ideal for public APIs or integrations.</strong></p><hr><h2 id=-grpc-api-high-performance-internal-comms>‚ö° <code>gRPC API</code>: High-Performance Internal Comms</h2><h3 id=-use-when-1>‚úÖ Use When:</h3><ul><li><p>You need fast, efficient, binary communication</p></li><li><p>You control both client and server</p></li><li><p>You&rsquo;re building service-to-service comms in a large SaaS platform</p></li></ul><h3 id=-go-libraries-1>üõ†Ô∏è Go Libraries:</h3><ul><li><p>google.golang.org/grpc</p></li><li><p>Protocol Buffers (protoc, protoc-gen-go)</p></li><li><p>Envoy / gRPC-Gateway for REST interop</p></li></ul><p><strong><code>gRPC API</code> shines in <code>polyglot</code>, high-throughput microservice environments.</strong></p><hr><h2 id=-graphql-flexible-queries-for-frontend-teams>üîç GraphQL: Flexible Queries for Frontend Teams</h2><h3 id=-use-when-2>‚úÖ Use When:</h3><ul><li><p>Frontend teams need control over data shape</p></li><li><p>You want to reduce overfetching/underfetching</p></li><li><p>You serve multiple frontends with different needs</p></li></ul><h3 id=-go-libraries-2>üõ†Ô∏è Go Libraries:</h3><ul><li><p>99designs/gqlgen</p></li><li><p>graphql-go/graphql</p></li></ul><p><strong><code>GraphQL API</code> is great for B2B SaaS dashboards, admin panels, or multi-platform apps.</strong></p><hr><h2 id=-websockets-real-time-bi-directional-apis>üîÑ WebSockets: Real-Time, Bi-Directional APIs</h2><h3 id=-use-when-3>‚úÖ Use When:</h3><ul><li><p>You need real-time updates (chat, collaboration, notifications)</p></li><li><p>Clients push and receive events</p></li></ul><h3 id=-go-libraries-3>üõ†Ô∏è Go Libraries:</h3><ul><li><p>gorilla/websocket</p></li><li><p>nhooyr/websocket</p></li></ul><p><strong><code>WebSockets APIs</code> are ideal for modern SaaS apps with live user interactions.</strong></p><hr><h2 id=-cqrs-separating-read-and-write-paths>üìê CQRS: Separating Read and Write Paths</h2><p>The Command Query Responsibility Segregation (CQRS) pattern is often a great fit for SaaS microservices ‚Äî especially when paired with event-driven architectures.</p><h3 id=-use-when-4>‚úÖ Use When:</h3><ul><li><p>You have complex domain logic or heavy reads vs light writes (or vice versa)</p></li><li><p>You want to decouple write models from read-optimized projections</p></li><li><p>You&rsquo;re building event-sourced systems</p></li></ul><h3 id=-tools--patterns-in-go>‚öôÔ∏è Tools & Patterns in Go:</h3><ul><li><p>Use separate structs/services for CommandHandlers and QueryHandlers</p></li><li><p>Event buses (e.g. go-nats, kafka-go, watermill)</p></li><li><p>Projection stores (Postgres, Redis, Elasticsearch, etc.)</p></li></ul><p><strong>CQRS enables scalability, flexibility, and clear separation of concerns ‚Äî perfect for SaaS systems with evolving business logic and reporting needs.</strong></p><hr><h2 id=-putting-it-all-together>üß© Putting It All Together</h2><p>In a real SaaS platform, you‚Äôll likely mix protocols:</p><ul><li><p>REST for public APIs and onboarding</p></li><li><p>gRPC for internal service mesh</p></li><li><p>GraphQL for flexible frontend backends</p></li><li><p>WebSocket for interactive features</p></li></ul><p><strong>Use each where it fits best ‚Äî Go makes switching easy.</strong></p><hr><h2 id=-dev-stack-for-saas-microservices-in-go>üõ†Ô∏è Dev Stack for SaaS Microservices in Go</h2><ul><li><p><code>API Gateways</code>: Kong, Envoy, Traefik</p></li><li><p><code>Auth</code>: OAuth2, OIDC, JWT (with golang-jwt/jwt)</p></li><li><p><code>Service Discovery</code>: Consul, etcd, Kubernetes</p></li><li><p><code>Observability</code>: Prometheus, OpenTelemetry, Grafana</p></li><li><p><code>CI/CD</code>: GitHub Actions, Drone, ArgoCD</p></li></ul><p>API GW Kong Example:</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    Client[Client: Web, Mobile, Partner] --&gt;|HTTP/gRPC| Kong[Kong API Gateway]
    Kong --&gt;|Routing| Service1[Microservice A]
    Kong --&gt;|Routing| Service2[Microservice B]
    Kong --&gt;|Routing| Service3[Microservice C]

    Kong -.-&gt;|Auth, Rate Limit, Logging| Plugins[Plugins]
    Kong --&gt; Observability[Prometheus / Grafana / Logs]
</code></pre><hr><h2 id=-saas-microservices-examples>‚òÅÔ∏è SaaS Microservices Examples</h2><h3 id=-e-commerce-platform>üõí E-commerce Platform</h3><ul><li><p>User Service ‚Äì manages users, profiles, authentication data.</p></li><li><p>Catalog Service ‚Äì product listings, categories, search.</p></li><li><p>Order Service ‚Äì order placement, status tracking.</p></li><li><p>Payment Service ‚Äì handles credit cards, PayPal, Stripe.</p></li><li><p>Shipping Service ‚Äì shipping labels, delivery tracking.</p></li><li><p>Notification Service ‚Äì emails, SMS, push notifications.</p></li></ul><h3 id=-fintech--banking>üè¶ FinTech / Banking</h3><ul><li><p>Customer Service ‚Äì KYC, customer info.</p></li><li><p>Account Service ‚Äì bank accounts, balances.</p></li><li><p>Transaction Service ‚Äì transfers, deposits, withdrawals.</p></li><li><p>Fraud Detection Service ‚Äì anomaly detection.</p></li><li><p>Reporting Service ‚Äì statements, analytics.</p></li></ul><h3 id=-saas--productivity-app>üì± SaaS / Productivity App</h3><ul><li><p>Auth Service ‚Äì login, OAuth2, JWT issuance (could be Keycloak).</p></li><li><p>Docs Service ‚Äì document storage and editing.</p></li><li><p>Comments Service ‚Äì threaded discussions.</p></li><li><p>Billing Service ‚Äì subscriptions, invoices.</p></li><li><p>Search Service ‚Äì full-text search across documents.</p></li></ul><h3 id=-mobility--ride-sharing>üöó Mobility / Ride Sharing</h3><ul><li><p>Driver Service ‚Äì driver registration, availability.</p></li><li><p>Rider Service ‚Äì customer profiles.</p></li><li><p>Ride Matching Service ‚Äì matches drivers ‚Üî riders.</p></li><li><p>Payment Service ‚Äì fare calculation + payment.</p></li><li><p>Location Service ‚Äì maps, GPS tracking.</p></li></ul><h3 id=-how-kong-fits-in>üîß How Kong fits in</h3><p>Kong sits at the edge and routes requests:</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart TB
    Client[Mobile / Web Client] --&gt; Kong[Kong API Gateway]

    Kong --&gt; UserService[User Service]
    Kong --&gt; OrderService[Order Service]
    Kong --&gt; PaymentService[Payment Service]
    Kong --&gt; NotificationService[Notification Service]

    Kong -.-&gt;|Auth, Rate Limiting, JWT Validation| Keycloak[(Keycloak)]
</code></pre><hr><h2 id=-kongs-role>ü¶ç Kong‚Äôs Role</h2><p>Kong sits as the API Gateway at the edge of your system.
It acts as the single entry point for all clients (web apps, mobile apps, partner APIs).</p><p>Instead of each client needing to know where every service lives, they all talk to Kong ‚Äî and Kong handles:</p><p>Routing ‚Äì decides which microservice should get the request.</p><p>Authentication & Authorization ‚Äì validates JWT tokens (from Keycloak, for example).</p><p>Rate Limiting ‚Äì prevents abuse (e.g., 100 requests/sec max).</p><p>Observability ‚Äì logs, metrics, traces.</p><p>Transformations ‚Äì rewrites headers, payloads, or even protocols.</p><h3 id=-flow-example-keycloak--kong--microservices>üîÑ Flow Example (Keycloak ‚Üí Kong ‚Üí Microservices)</h3><ol><li><p>Client authenticates with Keycloak</p><ul><li><p>Redirects user to Keycloak login page.</p></li><li><p>Receives a JWT access token (and optionally a refresh token).</p></li><li><p>Stores token locally (browser storage, app memory).</p></li></ul></li><li><p>Client sends request with JWT</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>GET https://api.saas.com/docs/123
</span></span><span class=line><span class=cl>Authorization: Bearer &lt;JWT from Keycloak&gt;
</span></span></code></pre></td></tr></table></div></div></li><li><p>Kong receives the request</p><ul><li><p>Validates JWT using OIDC plugin against Keycloak‚Äôs public keys.</p></li><li><p>Applies rate limiting plugin (e.g., 10 req/s per user).</p></li><li><p>Logs the request (Prometheus/Grafana integration).</p></li></ul></li><li><p>Kong routes the request</p><ul><li><p>/docs/* ‚Üí goes to Docs Service</p></li><li><p>/billing/* ‚Üí goes to Billing Service</p></li><li><p>/auth/* ‚Üí goes to Auth Service</p></li><li><p>Kong uses an internal service registry (DB or declarative YAML).</p></li></ul></li><li><p>Microservice processes request</p><ul><li><p>Docs Service fetches document #123 from storage.</p></li><li><p>If it needs to notify the user, it may call Notification Service internally.</p></li></ul></li><li><p>Response back to client</p><ul><li><p>Kong passes the response through.</p></li><li><p>Optionally adds headers, strips sensitive data, or transforms payloads.</p></li></ul></li></ol><h3 id=-visual-recap>üìå Visual Recap</h3><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart TB
    subgraph Auth[&#34;Keycloak Authentication&#34;]
        Keycloak[&#34;Keycloak OIDC Provider&#34;]
    end

    Client[&#34;Web / Mobile App&#34;] --&gt;|&#34;Login &amp; Fetch JWT&#34;| Keycloak
    Client --&gt;|&#34;Bearer JWT&#34;| Kong[&#34;Kong API Gateway&#34;]

    Kong --&gt; AuthService[&#34;Auth Service&#34;]
    Kong --&gt; DocsService[&#34;Docs Service&#34;]
    Kong --&gt; CommentsService[&#34;Comments Service&#34;]
    Kong --&gt; BillingService[&#34;Billing Service&#34;]
    Kong --&gt; NotificationsService[&#34;Notifications Service&#34;]
</code></pre><ul><li><p>Clients must fetch JWT from Keycloak in advance.</p></li><li><p>Kong validates JWT and enforces policies.</p></li><li><p>Microservices stay focused on business logic.</p></li><li><p>Routes traffic to the correct service.</p></li><li><p>Adds cross-cutting features (logging, rate limiting, security).</p></li></ul><p>‚úÖ In short: Kong is the traffic cop + security guard + auditor in front of your microservices.</p><hr><h2 id=-final-thoughts>üìå Final Thoughts</h2><p>Go makes it easy to build fast, scalable, and maintainable SaaS microservices ‚Äî no matter which API protocol you&rsquo;re working with. Understanding the strengths and trade-offs of REST, gRPC, GraphQL, WebSockets, and architectural patterns like CQRS helps you design the right interface for each part of your product.</p><hr><p>üöÄ Follow me on <a href=https://norbix.dev>norbix.dev</a> for more insights on Go, Python, AI, system design, and engineering wisdom.</p></div><div class=post-subscribe><style>.subscribe-form{display:flex;gap:.5rem;margin-top:1rem;align-items:center}.subscribe-form input[type=email]{padding:.5rem;border-radius:6px;border:1px solid #ccc;background-color:#1f1f1f;color:#fff}.subscribe-form input[type=submit],.subscribe-form button{padding:.5rem 1rem;border-radius:6px;background-color:#facc15;color:#000;border:none;cursor:pointer;font-weight:700}.subscribe-form input[type=submit]:hover{background-color:#fcd34d}</style><form action=https://buttondown.email/api/emails/embed-subscribe/norbix method=post target=popupwindow onsubmit='window.open("https://buttondown.email/norbix","popupwindow")' class=subscribe-form><input type=email name=email placeholder="Enter your email" required>
<input type=submit value=Subscribe></form><p style=font-size:.875rem;opacity:.6>Powered by Buttondown.</p></div><div class=post-comments><script src=https://giscus.app/client.js data-repo=norbix/norbix.dev data-repo-id=R_kgDOOV_xMQ data-category=Announcements data-category-id=DIC_kwDOOV_xMc4CpF5M data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=dark data-lang=en crossorigin=anonymous async></script></div><nav class=paginav><a class=prev href=https://norbix.dev/posts/platform-engineering/><span class=title>¬´ Prev</span><br><span>Platform Engineering: The DevOps You Productize</span>
</a><a class=next href=https://norbix.dev/posts/databases/><span class=title>Next ¬ª</span><br><span>Understanding Databases: B-Trees, SQL, NoSQL, ACID, and Normalization</span></a></nav></article></main></main><footer class=footer><span>&copy; 2025 <a href=https://norbix.dev/>norbix.dev - The log of my journey through code & software systems architecture</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script src=https://platform.linkedin.com/badges/js/profile.js async defer type=text/javascript></script></body></html>
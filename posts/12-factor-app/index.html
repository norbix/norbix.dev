<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><script>(function(){const e=localStorage.getItem("theme"),t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches;e==="dark"||!e&&t?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark"),window.setTheme=function(e){localStorage.setItem("theme",e),document.documentElement.classList.toggle("dark",e==="dark")}})()</script><title>The Twelve-Factor App â€” Timeless Principles for Modern Software | norbix.dev
</title><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The Twelve-Factor App â€” Timeless Principles for Modern Software | norbix.dev - The log of my journey through code & software systems architecture</title>
<meta name=keywords content="Cloud,DevOps,Go,Docker,Kubernetes,Software Architecture"><meta name=description content="Revisiting the Twelve-Factor App principles in the context of modern Go, Docker, and Kubernetes setups."><meta name=author content><link rel=canonical href=https://norbix.dev/posts/12-factor-app/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://norbix.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://norbix.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://norbix.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://norbix.dev/apple-touch-icon.png><link rel=mask-icon href=https://norbix.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://norbix.dev/posts/12-factor-app/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=canonical href=https://norbix.dev/posts/12-factor-app/><meta property="og:title" content="The Twelve-Factor App â€” Timeless Principles for Modern Software"><meta property="og:url" content="https://norbix.dev/posts/12-factor-app/"><meta property="og:image" content="https://norbix.dev/banner.jpg"><meta property="og:type" content="article"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="The Twelve-Factor App â€” Timeless Principles for Modern Software"><meta name=twitter:image content="https://norbix.dev/banner.jpg"><script data-goatcounter=https://norbix.goatcounter.com/count async src=//gc.zgo.at/count.js></script><link rel=alternate type=application/rss+xml title="RSS Feed for norbix.dev" href=/index.xml><script src=https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js defer></script><script>document.addEventListener("DOMContentLoaded",function(){window.mermaid&&(document.querySelectorAll("code.language-mermaid").forEach(function(e){var n=e.parentElement,t=document.createElement("div");t.className="mermaid",t.textContent=e.textContent,n.replaceWith(t)}),mermaid.initialize({startOnLoad:!0}))})</script><link href=https://cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.3/css/lightbox.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.3/js/lightbox.min.js defer></script><meta property="og:title" content="The Twelve-Factor App â€” Timeless Principles for Modern Software"><meta property="og:description" content="Revisiting the Twelve-Factor App principles in the context of modern Go, Docker, and Kubernetes setups."><meta property="og:type" content="article"><meta property="og:url" content="https://norbix.dev/posts/12-factor-app/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-03T00:00:00+00:00"><meta property="article:modified_time" content="2025-11-03T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="The Twelve-Factor App â€” Timeless Principles for Modern Software"><meta name=twitter:description content="Revisiting the Twelve-Factor App principles in the context of modern Go, Docker, and Kubernetes setups."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://norbix.dev/posts/"},{"@type":"ListItem","position":2,"name":"The Twelve-Factor App â€” Timeless Principles for Modern Software","item":"https://norbix.dev/posts/12-factor-app/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The Twelve-Factor App â€” Timeless Principles for Modern Software","name":"The Twelve-Factor App â€” Timeless Principles for Modern Software","description":"Revisiting the Twelve-Factor App principles in the context of modern Go, Docker, and Kubernetes setups.","keywords":["Cloud","DevOps","Go","Docker","Kubernetes","Software Architecture"],"articleBody":" ğŸ§­ Why the Twelve Factors Still Matter The Twelve-Factor App methodology, first published by Heroku engineers, remains one of the most practical blueprints for designing cloud-native, maintainable, and scalable applications.\nEven though the document is over a decade old, the principles apply perfectly to containerized and microservice architectures â€” especially when using Go, Docker, and Kubernetes.\nLetâ€™s break them down with a modern engineering lens.\nâš™ï¸ 1. Codebase One codebase tracked in revision control, many deploys.\nA single codebase represents one application. Multiple environments â€” development, staging, production â€” should all be deployed from that same repository.\nThis prevents divergence between environments and simplifies automation.\nA codebase should live in a version control system like Git. For Go, it might be a monorepo structured by packages (/internal, /cmd, /pkg) or a polyrepo setup with each microservice as a standalone repository.\nModern workflows use:\nGitHub Actions or Jenkins pipelines to automate builds. Trunk-based development to reduce merge friction. Feature flags to deploy safely across multiple environments from the same codebase. ğŸ’¡ In short: if you have multiple codebases for the same app, itâ€™s not one app â€” itâ€™s multiple.\nğŸ”‘ 2. Dependencies Explicitly declare and isolate dependencies.\nEvery dependency your app uses â€” libraries, runtime versions, or CLI tools â€” should be declared explicitly.\nGo does this via go.mod; Python via requirements.txt; Node via package.json. Never rely on system-wide packages.\nIn Docker, this means:\n1 2 3 FROM golang:1.23 AS builder COPY go.mod go.sum ./ RUN go mod download This ensures a reproducible environment across machines and CI/CD agents.\nDependency isolation can be achieved with:\nDocker containers (each container has its own dependency graph).\nVirtual environments (for non-containerized setups).\nSBOM (Software Bill of Materials) generation for security compliance.\nExplicit dependencies make your build deterministic â€” a cornerstone of DevSecOps.\nğŸ§© 3. Config Store config in the environment.\nConfiguration changes across deployments (e.g., credentials, ports, URLs) should not require code changes. Use environment variables, .env files, or configuration management systems (Vault, AWS SSM, Kubernetes Secrets).\nExample .env:\nDATABASE_URL=postgres://user:pass@db:5432/app PORT=8080 LOG_LEVEL=info Then inject them via your Docker Compose or Kubernetes manifests. This approach improves separation of code and configuration â€” allowing you to promote the same image across environments simply by changing environment variables.\nğŸ’¡ Never commit secrets to Git. Instead, use sealed secrets or secret managers.\nğŸ›  4. Backing Services Treat backing services as attached resources.\nDatabases, message brokers, caches, or external APIs are replaceable services. Your app should treat them as external and configurable via URLs or connection strings.\nFor example:\nDATABASE_URL=postgres://user:pass@localhost:5432/app REDIS_URL=redis://localhost:6379 If you migrate from PostgreSQL to CloudSQL or from Redis to ElastiCache, no code should change â€” just the configuration.\nThis abstraction supports portability and disaster recovery because you can switch providers without redeploying code.\nğŸ“¦ 5. Build, Release, Run Strictly separate build and run stages.\nEach deployment should follow three immutable stages:\nBuild: Compile code, install dependencies, and produce a deployable artifact (e.g., Docker image or binary).\nRelease: Combine the build artifact with environment configuration to form a release.\nRun: Execute the app in one or more environments.\nIn CI/CD terms:\n1 2 3 4 stages: - build - release - deploy Build artifacts should be immutable and tagged (myapp:v1.2.3). Never rebuild an artifact during promotion between environments â€” it breaks reproducibility and traceability.\nâš¡ï¸ 6. Processes Execute the app as one or more stateless processes.\nYour application should not depend on local state or session memory between requests. Use external stores for persistence â€” databases, Redis, or object storage.\nExample in Go:\n1 2 3 4 func handler(w http.ResponseWriter, r *http.Request) { user := cache.Get(\"user\") // external store fmt.Fprintf(w, \"Hello %s\", user) } Stateless processes make your system horizontally scalable and resilient to container restarts â€” crucial in Kubernetes where pods are ephemeral.\nğŸ’¡ Never write to /tmp or the local filesystem expecting it to persist.\nğŸ“‚ 7. Port Binding Export services via port binding.\nAn app should self-contain its web server and expose it via a port, rather than depending on a host container like Apache or Tomcat.\nIn Go, this is trivial:\n1 log.Fatal(http.ListenAndServe(\":8080\", router)) This model allows easy containerization:\n1 2 3 # Hint only - it doesn't expose ports automatically EXPOSE 8080 CMD [\"./server\"] By following this principle, the app becomes portable across Docker, Kubernetes, and PaaS environments, since all it needs to run is a port and a network.\nğŸ”„ 8. Concurrency Scale out via the process model.\nInstead of scaling â€œupâ€ by adding threads or CPU cores, scale â€œoutâ€ by spawning multiple processes or containers.\nUse goroutines or worker pools for concurrency inside one process.\nUse multiple replicas in Kubernetes to scale horizontally.\nUse queue-based workloads for background jobs.\nExample Kubernetes manifest:\n1 2 spec: replicas: 4 The Twelve-Factor principle aligns perfectly with container orchestration, allowing dynamic scaling per workload type.\nğŸ§  9. Disposability Maximize robustness with fast startup and graceful shutdown.\nProcesses should start quickly and stop gracefully. Fast startup improves elasticity; graceful shutdown prevents data loss.\nIn Go:\n1 2 ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM) defer cancel() This pattern ensures that in Kubernetes, your pod responds correctly to SIGTERM, allowing a few seconds to finish requests before being killed.\nğŸ’¡ Disposability = resilience. You can recycle containers without hurting availability.\nğŸ§° 10. Dev/Prod Parity Keep development, staging, and production as similar as possible.\nThe closer your dev environment mirrors production, the fewer deployment surprises youâ€™ll face. Using Docker Compose, Taskfile, or Minikube, developers can reproduce the production stack locally.\nFor example:\n1 docker compose -f docker-compose.prod.yml up Keep:\nThe same OS base image (e.g., Alpine, Debian).\nThe same database version.\nThe same config format (ENV).\nğŸ’¡ Continuous delivery pipelines help maintain this parity automatically.\nğŸ§¾ 11. Logs Treat logs as event streams.\nInstead of managing log files on disk, write all logs to stdout and let the environment aggregate them. This enables observability tools like Loki, ELK, or CloudWatch to handle them consistently.\nExample in Go:\n1 log.Printf(\"INFO: user %s logged in\", userID) Your containers stay stateless, and logs become part of a centralized event stream â€” not stored locally.\nThis design simplifies debugging, auditing, and monitoring in distributed environments.\nğŸ” 12. Admin Processes Run admin tasks as one-off processes.\nMaintenance tasks like data migrations or cleanup scripts should run in the same runtime and configuration as the app.\nExample (Go migration runner):\n1 docker run --rm myapp:latest migrate up Or in Kubernetes:\n1 kubectl run migrate --image=myapp:latest --restart=Never --command -- migrate up This guarantees consistency between environments and prevents configuration drift.\nNever run migrations manually from a developer laptop.\nğŸš€ Modern Alignment Factor Modern Equivalent Config .env, Secrets, ConfigMaps Build/Run Docker, CI/CD, GitHub Actions Logs Loki, ELK, CloudWatch Processes Kubernetes Pods, Deployments Dev/Prod Parity Docker Compose + Minikube ğŸ§­ Lifecycle Overview Below is a simplified flow of how the Twelve-Factor App lifecycle maps onto modern CI/CD pipelines:\nflowchart LR A[Build Stage] --\u003e B[Release Stage] B --\u003e C[Run Stage] C --\u003e D[Monitor \u0026 Logs] D --\u003e A style A fill:#f9f,stroke:#333,stroke-width:1px style B fill:#9ff,stroke:#333,stroke-width:1px style C fill:#aff,stroke:#333,stroke-width:1px style D fill:#ffc,stroke:#333,stroke-width:1px ğŸ§© Summary The Twelve Factors arenâ€™t outdated â€” theyâ€™re timeless. In fact, theyâ€™ve quietly become the core philosophy of modern DevOps and container-native design.\nThey remind us to:\nIsolate code and configuration,\nDesign stateless, disposable processes,\nKeep environments consistent,\nAnd automate everything reproducibly.\nğŸš€ Follow me on norbix.dev for more insights on Go, Python, AI, system design, and engineering wisdom.\n","wordCount":"1232","inLanguage":"en","datePublished":"2025-11-03T00:00:00Z","dateModified":"2025-11-03T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://norbix.dev/posts/12-factor-app/"},"publisher":{"@type":"Organization","name":"norbix.dev - The log of my journey through code \u0026 software systems architecture","logo":{"@type":"ImageObject","url":"https://norbix.dev/favicon.ico"}}}</script></head><body><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://norbix.dev/ accesskey=h title="norbix.dev - The log of my journey through code & software systems architecture (Alt + H)">norbix.dev - The log of my journey through code & software systems architecture</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://norbix.dev/ title=Home><span>Home</span></a></li><li><a href=https://norbix.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://norbix.dev/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://norbix.dev/about/ title=About><span>About</span></a></li><li><a href=https://norbix.dev/index.xml title="ğŸ“¡ RSS"><span>ğŸ“¡ RSS</span></a></li></ul></nav></header><main><main id=main><article class=post-single><header class=post-header><h1 class=post-title>The Twelve-Factor App â€” Timeless Principles for Modern Software</h1><span title='2025-11-03 00:00:00 +0000 UTC'>November 3, 2025</span></header><div class=post-content><nav class=table-of-contents><nav id=TableOfContents><ul><li><a href=#-why-the-twelve-factors-still-matter>ğŸ§­ Why the Twelve Factors Still Matter</a></li><li><a href=#-1-codebase>âš™ï¸ 1. Codebase</a></li><li><a href=#-2-dependencies>ğŸ”‘ 2. Dependencies</a></li><li><a href=#-3-config>ğŸ§© 3. Config</a></li><li><a href=#-4-backing-services>ğŸ›  4. Backing Services</a></li><li><a href=#-5-build-release-run>ğŸ“¦ 5. Build, Release, Run</a></li><li><a href=#-6-processes>âš¡ï¸ 6. Processes</a></li><li><a href=#-7-port-binding>ğŸ“‚ 7. Port Binding</a></li><li><a href=#-8-concurrency>ğŸ”„ 8. Concurrency</a></li><li><a href=#-9-disposability>ğŸ§  9. Disposability</a></li><li><a href=#-10-devprod-parity>ğŸ§° 10. Dev/Prod Parity</a></li><li><a href=#-11-logs>ğŸ§¾ 11. Logs</a></li><li><a href=#-12-admin-processes>ğŸ” 12. Admin Processes</a></li><li><a href=#-modern-alignment>ğŸš€ Modern Alignment</a></li><li><a href=#-lifecycle-overview>ğŸ§­ Lifecycle Overview</a></li><li><a href=#-summary>ğŸ§© Summary</a></li></ul></nav></nav><p><img loading=lazy src=banner.jpg alt=banner></p><h2 id=-why-the-twelve-factors-still-matter>ğŸ§­ Why the Twelve Factors Still Matter</h2><p>The <a href=https://12factor.net>Twelve-Factor App</a> methodology, first published by Heroku engineers, remains one of the most practical blueprints for designing <strong>cloud-native, maintainable, and scalable applications</strong>.</p><p>Even though the document is over a decade old, the principles apply perfectly to <strong>containerized and microservice architectures</strong> â€” especially when using <strong>Go, Docker, and Kubernetes</strong>.</p><p>Letâ€™s break them down with a modern engineering lens.</p><hr><h2 id=-1-codebase>âš™ï¸ 1. Codebase</h2><blockquote><p>One codebase tracked in revision control, many deploys.</p></blockquote><p>A single codebase represents one application. Multiple environments â€” development, staging, production â€” should all be deployed from that same repository.<br>This prevents divergence between environments and simplifies automation.</p><p>A codebase should live in <strong>a version control system</strong> like Git. For Go, it might be a monorepo structured by packages (<code>/internal</code>, <code>/cmd</code>, <code>/pkg</code>) or a polyrepo setup with each microservice as a standalone repository.</p><p>Modern workflows use:</p><ul><li><strong>GitHub Actions or Jenkins</strong> pipelines to automate builds.</li><li><strong>Trunk-based development</strong> to reduce merge friction.</li><li><strong>Feature flags</strong> to deploy safely across multiple environments from the same codebase.</li></ul><p>ğŸ’¡ In short: if you have multiple codebases for the same app, itâ€™s not one app â€” itâ€™s multiple.</p><hr><h2 id=-2-dependencies>ğŸ”‘ 2. Dependencies</h2><blockquote><p>Explicitly declare and isolate dependencies.</p></blockquote><p>Every dependency your app uses â€” libraries, runtime versions, or CLI tools â€” should be <strong>declared explicitly</strong>.<br>Go does this via <code>go.mod</code>; Python via <code>requirements.txt</code>; Node via <code>package.json</code>. Never rely on system-wide packages.</p><p>In Docker, this means:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> golang:1.23 AS builder</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> go.mod go.sum ./<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> go mod download<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>This ensures a reproducible environment across machines and CI/CD agents.</p><p>Dependency isolation can be achieved with:</p><ul><li><p>Docker containers (each container has its own dependency graph).</p></li><li><p>Virtual environments (for non-containerized setups).</p></li><li><p>SBOM (Software Bill of Materials) generation for security compliance.</p></li></ul><p>Explicit dependencies make your build deterministic â€” a cornerstone of DevSecOps.</p><hr><h2 id=-3-config>ğŸ§© 3. Config</h2><blockquote><p>Store config in the environment.</p></blockquote><p>Configuration changes across deployments (e.g., credentials, ports, URLs) should not require code changes.
Use environment variables, .env files, or configuration management systems (Vault, AWS SSM, Kubernetes Secrets).</p><p>Example .env:</p><pre tabindex=0><code class=language-dotenv data-lang=dotenv>DATABASE_URL=postgres://user:pass@db:5432/app
PORT=8080
LOG_LEVEL=info
</code></pre><p>Then inject them via your Docker Compose or Kubernetes manifests.
This approach improves separation of code and configuration â€” allowing you to promote the same image across environments simply by changing environment variables.</p><p>ğŸ’¡ Never commit secrets to Git. Instead, use sealed secrets or secret managers.</p><hr><h2 id=-4-backing-services>ğŸ›  4. Backing Services</h2><blockquote><p>Treat backing services as attached resources.</p></blockquote><p>Databases, message brokers, caches, or external APIs are replaceable services.
Your app should treat them as external and configurable via URLs or connection strings.</p><p>For example:</p><pre tabindex=0><code class=language-dotenv data-lang=dotenv>DATABASE_URL=postgres://user:pass@localhost:5432/app
REDIS_URL=redis://localhost:6379
</code></pre><p>If you migrate from PostgreSQL to CloudSQL or from Redis to ElastiCache, no code should change â€” just the configuration.</p><p>This abstraction supports portability and disaster recovery because you can switch providers without redeploying code.</p><hr><h2 id=-5-build-release-run>ğŸ“¦ 5. Build, Release, Run</h2><blockquote><p>Strictly separate build and run stages.</p></blockquote><ol><li><p>Each deployment should follow three immutable stages:</p></li><li><p>Build: Compile code, install dependencies, and produce a deployable artifact (e.g., Docker image or binary).</p></li><li><p>Release: Combine the build artifact with environment configuration to form a release.</p></li></ol><p>Run: Execute the app in one or more environments.</p><p>In CI/CD terms:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>stages</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=l>build</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=l>release</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=l>deploy</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Build artifacts should be immutable and tagged (myapp:v1.2.3).
Never rebuild an artifact during promotion between environments â€” it breaks reproducibility and traceability.</p><hr><h2 id=-6-processes>âš¡ï¸ 6. Processes</h2><blockquote><p>Execute the app as one or more stateless processes.</p></blockquote><p>Your application should not depend on local state or session memory between requests.
Use external stores for persistence â€” databases, Redis, or object storage.</p><p>Example in Go:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>handler</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>user</span> <span class=o>:=</span> <span class=nx>cache</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=s>&#34;user&#34;</span><span class=p>)</span> <span class=c1>// external store</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Fprintf</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=s>&#34;Hello %s&#34;</span><span class=p>,</span> <span class=nx>user</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Stateless processes make your system horizontally scalable and resilient to container restarts â€” crucial in Kubernetes where pods are ephemeral.</p><p>ğŸ’¡ Never write to /tmp or the local filesystem expecting it to persist.</p><hr><h2 id=-7-port-binding>ğŸ“‚ 7. Port Binding</h2><blockquote><p>Export services via port binding.</p></blockquote><p>An app should self-contain its web server and expose it via a port, rather than depending on a host container like Apache or Tomcat.</p><p>In Go, this is trivial:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>(</span><span class=s>&#34;:8080&#34;</span><span class=p>,</span> <span class=nx>router</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>This model allows easy containerization:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># Hint only - it doesn&#39;t expose ports automatically</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>EXPOSE</span><span class=s> 8080</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;./server&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>By following this principle, the app becomes portable across Docker, Kubernetes, and PaaS environments, since all it needs to run is a port and a network.</p><hr><h2 id=-8-concurrency>ğŸ”„ 8. Concurrency</h2><blockquote><p>Scale out via the process model.</p></blockquote><p>Instead of scaling â€œupâ€ by adding threads or CPU cores, scale â€œoutâ€ by spawning multiple processes or containers.</p><ul><li><p>Use goroutines or worker pools for concurrency inside one process.</p></li><li><p>Use multiple replicas in Kubernetes to scale horizontally.</p></li><li><p>Use queue-based workloads for background jobs.</p></li></ul><p>Example Kubernetes manifest:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>replicas</span><span class=p>:</span><span class=w> </span><span class=m>4</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The Twelve-Factor principle aligns perfectly with container orchestration, allowing dynamic scaling per workload type.</p><hr><h2 id=-9-disposability>ğŸ§  9. Disposability</h2><blockquote><p>Maximize robustness with fast startup and graceful shutdown.</p></blockquote><p>Processes should start quickly and stop gracefully.
Fast startup improves elasticity; graceful shutdown prevents data loss.</p><p>In Go:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>signal</span><span class=p>.</span><span class=nf>NotifyContext</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Interrupt</span><span class=p>,</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>SIGTERM</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>defer</span> <span class=nf>cancel</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><p>This pattern ensures that in Kubernetes, your pod responds correctly to SIGTERM, allowing a few seconds to finish requests before being killed.</p><p>ğŸ’¡ Disposability = resilience. You can recycle containers without hurting availability.</p><hr><h2 id=-10-devprod-parity>ğŸ§° 10. Dev/Prod Parity</h2><blockquote><p>Keep development, staging, and production as similar as possible.</p></blockquote><p>The closer your dev environment mirrors production, the fewer deployment surprises youâ€™ll face.
Using Docker Compose, Taskfile, or Minikube, developers can reproduce the production stack locally.</p><p>For example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>docker compose -f docker-compose.prod.yml up
</span></span></code></pre></td></tr></table></div></div><p>Keep:</p><ul><li><p>The same OS base image (e.g., Alpine, Debian).</p></li><li><p>The same database version.</p></li><li><p>The same config format (ENV).</p></li></ul><p>ğŸ’¡ Continuous delivery pipelines help maintain this parity automatically.</p><hr><h2 id=-11-logs>ğŸ§¾ 11. Logs</h2><blockquote><p>Treat logs as event streams.</p></blockquote><p>Instead of managing log files on disk, write all logs to stdout and let the environment aggregate them.
This enables observability tools like Loki, ELK, or CloudWatch to handle them consistently.</p><p>Example in Go:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;INFO: user %s logged in&#34;</span><span class=p>,</span> <span class=nx>userID</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Your containers stay stateless, and logs become part of a centralized event stream â€” not stored locally.</p><p>This design simplifies debugging, auditing, and monitoring in distributed environments.</p><hr><h2 id=-12-admin-processes>ğŸ” 12. Admin Processes</h2><blockquote><p>Run admin tasks as one-off processes.</p></blockquote><p>Maintenance tasks like data migrations or cleanup scripts should run in the same runtime and configuration as the app.</p><p>Example (Go migration runner):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>docker run --rm myapp:latest migrate up
</span></span></code></pre></td></tr></table></div></div><p>Or in Kubernetes:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl run migrate --image<span class=o>=</span>myapp:latest --restart<span class=o>=</span>Never --command -- migrate up
</span></span></code></pre></td></tr></table></div></div><p>This guarantees consistency between environments and prevents configuration drift.</p><p>Never run migrations manually from a developer laptop.</p><hr><h2 id=-modern-alignment>ğŸš€ Modern Alignment</h2><table><thead><tr><th>Factor</th><th>Modern Equivalent</th></tr></thead><tbody><tr><td>Config</td><td><code>.env</code>, Secrets, ConfigMaps</td></tr><tr><td>Build/Run</td><td>Docker, CI/CD, GitHub Actions</td></tr><tr><td>Logs</td><td>Loki, ELK, CloudWatch</td></tr><tr><td>Processes</td><td>Kubernetes Pods, Deployments</td></tr><tr><td>Dev/Prod Parity</td><td>Docker Compose + Minikube</td></tr></tbody></table><hr><h2 id=-lifecycle-overview>ğŸ§­ Lifecycle Overview</h2><p>Below is a simplified flow of how the <strong>Twelve-Factor App lifecycle</strong> maps onto modern CI/CD pipelines:</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    A[Build Stage] --&gt; B[Release Stage]
    B --&gt; C[Run Stage]
    C --&gt; D[Monitor &amp; Logs]
    D --&gt; A
    style A fill:#f9f,stroke:#333,stroke-width:1px
    style B fill:#9ff,stroke:#333,stroke-width:1px
    style C fill:#aff,stroke:#333,stroke-width:1px
    style D fill:#ffc,stroke:#333,stroke-width:1px
</code></pre><hr><h2 id=-summary>ğŸ§© Summary</h2><p>The Twelve Factors arenâ€™t outdated â€” theyâ€™re timeless.
In fact, theyâ€™ve quietly become the core philosophy of modern DevOps and container-native design.</p><p>They remind us to:</p><ul><li><p>Isolate code and configuration,</p></li><li><p>Design stateless, disposable processes,</p></li><li><p>Keep environments consistent,</p></li><li><p>And automate everything reproducibly.</p></li></ul><hr><p>ğŸš€ Follow me on <a href=https://norbix.dev>norbix.dev</a> for more insights on Go, Python, AI, system design, and engineering wisdom.</p></div><div class=post-subscribe><style>.subscribe-form{display:flex;gap:.5rem;margin-top:1rem;align-items:center}.subscribe-form input[type=email]{padding:.5rem;border-radius:6px;border:1px solid #ccc;background-color:#1f1f1f;color:#fff}.subscribe-form input[type=submit],.subscribe-form button{padding:.5rem 1rem;border-radius:6px;background-color:#facc15;color:#000;border:none;cursor:pointer;font-weight:700}.subscribe-form input[type=submit]:hover{background-color:#fcd34d}</style><form action=https://buttondown.email/api/emails/embed-subscribe/norbix method=post target=popupwindow onsubmit='window.open("https://buttondown.email/norbix","popupwindow")' class=subscribe-form><input type=email name=email placeholder="Enter your email" required>
<input type=submit value=Subscribe></form><p style=font-size:.875rem;opacity:.6>Powered by Buttondown.</p></div><div class=post-comments><script src=https://giscus.app/client.js data-repo=norbix/norbix.dev data-repo-id=R_kgDOOV_xMQ data-category=Announcements data-category-id=DIC_kwDOOV_xMc4CpF5M data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=dark data-lang=en crossorigin=anonymous async></script></div><nav class=paginav><a class=prev href=https://norbix.dev/posts/kubernetes-operators-in-go/><span class=title>Â« Prev</span><br><span>Kubernetes Operators in Go</span></a></nav></article></main></main><footer class=footer><span>&copy; 2025 <a href=https://norbix.dev/>norbix.dev - The log of my journey through code & software systems architecture</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script src=https://platform.linkedin.com/badges/js/profile.js async defer type=text/javascript></script></body></html>
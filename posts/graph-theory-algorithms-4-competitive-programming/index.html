<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><script>(function(){const e=localStorage.getItem("theme"),t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches;e==="dark"||!e&&t?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark"),window.setTheme=function(e){localStorage.setItem("theme",e),document.documentElement.classList.toggle("dark",e==="dark")}})()</script><title>Graph Theory Algorithms 4 Competitive Programming | norbix.dev
</title><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Graph Theory Algorithms 4 Competitive Programming | norbix.dev - The log of my journey through code & software systems architecture</title>
<meta name=keywords content="go,golang,algorithms,graph-theory"><meta name=description content="A comprehensive guide to graph theory algorithms in Go, covering essential concepts, implementations, and best practices for competitive programming."><meta name=author content><link rel=canonical href=https://norbix.dev/posts/graph-theory-algorithms-4-competitive-programming/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://norbix.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://norbix.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://norbix.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://norbix.dev/apple-touch-icon.png><link rel=mask-icon href=https://norbix.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://norbix.dev/posts/graph-theory-algorithms-4-competitive-programming/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=canonical href=https://norbix.dev/posts/graph-theory-algorithms-4-competitive-programming/><meta property="og:title" content="Graph Theory Algorithms 4 Competitive Programming"><meta property="og:url" content="https://norbix.dev/posts/graph-theory-algorithms-4-competitive-programming/"><meta property="og:image" content="https://norbix.dev/banner.jpg"><meta property="og:type" content="article"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Graph Theory Algorithms 4 Competitive Programming"><meta name=twitter:image content="https://norbix.dev/banner.jpg"><script data-goatcounter=https://norbix.goatcounter.com/count async src=//gc.zgo.at/count.js></script><link rel=alternate type=application/rss+xml title="RSS Feed for norbix.dev" href=/index.xml><script src=https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js defer></script><script>document.addEventListener("DOMContentLoaded",function(){window.mermaid&&(document.querySelectorAll("code.language-mermaid").forEach(function(e){var n=e.parentElement,t=document.createElement("div");t.className="mermaid",t.textContent=e.textContent,n.replaceWith(t)}),mermaid.initialize({startOnLoad:!0}))})</script><link href=https://cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.3/css/lightbox.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.3/js/lightbox.min.js defer></script><meta property="og:title" content="Graph Theory Algorithms 4 Competitive Programming"><meta property="og:description" content="A comprehensive guide to graph theory algorithms in Go, covering essential concepts, implementations, and best practices for competitive programming."><meta property="og:type" content="article"><meta property="og:url" content="https://norbix.dev/posts/graph-theory-algorithms-4-competitive-programming/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-19T15:34:33+02:00"><meta property="article:modified_time" content="2025-04-19T15:34:33+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Graph Theory Algorithms 4 Competitive Programming"><meta name=twitter:description content="A comprehensive guide to graph theory algorithms in Go, covering essential concepts, implementations, and best practices for competitive programming."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://norbix.dev/posts/"},{"@type":"ListItem","position":2,"name":"Graph Theory Algorithms 4 Competitive Programming","item":"https://norbix.dev/posts/graph-theory-algorithms-4-competitive-programming/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Graph Theory Algorithms 4 Competitive Programming","name":"Graph Theory Algorithms 4 Competitive Programming","description":"A comprehensive guide to graph theory algorithms in Go, covering essential concepts, implementations, and best practices for competitive programming.","keywords":["go","golang","algorithms","graph-theory"],"articleBody":" üß† Graph Theory for Competitive Programming In competitive programming, few topics are as powerful‚Äîand sometimes intimidating‚Äîas graph theory. Whether it‚Äôs shortest paths, connected components, or cycles, graphs appear everywhere from Google Maps to dependency resolution.\nIn this article, we‚Äôll explore the essential graph concepts, common problems, and Go (Golang) code snippets to help you handle any graph-based challenge on coding platforms like Codeforces, LeetCode, or AtCoder.\nüï∏Ô∏è What Is a Graph? A graph is a collection of nodes (vertices) and edges (connections between nodes). It can be:\nDirected or Undirected Weighted or Unweighted Connected or Disconnected Cyclic or Acyclic A simple undirected graph looks like:\ngraph TD A(1) -- 2 ‚Üî 1 --\u003e B(2) B -- 3 ‚Üî 2 --\u003e C(3) C -- 4 ‚Üî 3 --\u003e D(4) D -- 1 ‚Üî 4 --\u003e A In Go, we typically represent graphs using an adjacency list.\n1 2 3 4 5 6 graph := map[int][]int{ 1: {2, 4}, 2: {1, 3}, 3: {2, 4}, 4: {1, 3}, } üîç DFS and BFS ‚Äì Graph Traversal Use DFS for problems involving backtracking, connected components, and cycle detection.\nUse BFS for shortest paths in unweighted graphs or level-order traversal\nDepth-First Search (DFS)\n1 2 3 4 5 6 7 8 9 10 11 func dfs(node int, visited map[int]bool, graph map[int][]int) { if visited[node] { return } visited[node] = true fmt.Println(node) for _, neighbor := range graph[node] { dfs(neighbor, visited, graph) } } Breadth-First Search (BFS)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func bfs(start int, graph map[int][]int) { visited := map[int]bool{} queue := []int{start} for len(queue) \u003e 0 { node := queue[0] queue = queue[1:] if visited[node] { continue } visited[node] = true fmt.Println(node) for _, neighbor := range graph[node] { if !visited[neighbor] { queue = append(queue, neighbor) } } } } üîó Connected Components In an undirected graph, you can find connected components by running DFS from each unvisited node.\n1 2 3 4 5 6 7 8 9 10 11 12 func countComponents(graph map[int][]int, n int) int { visited := make(map[int]bool) count := 0 for i := 1; i \u003c= n; i++ { if !visited[i] { dfs(i, visited, graph) count++ } } return count } ‚õìÔ∏è Cycle Detection (Undirected Graph) DFS with parent tracking:\n1 2 3 4 5 6 7 8 9 10 11 12 13 func hasCycle(node, parent int, visited map[int]bool, graph map[int][]int) bool { visited[node] = true for _, neighbor := range graph[node] { if !visited[neighbor] { if hasCycle(neighbor, node, visited, graph) { return true } } else if neighbor != parent { return true } } return false } üìê Topological Sort (Directed Acyclic Graph) Used in task scheduling or course dependency problems.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func topologicalSort(graph map[int][]int, n int) []int { visited := make(map[int]bool) stack := []int{} var dfs func(int) dfs = func(node int) { visited[node] = true for _, neighbor := range graph[node] { if !visited[neighbor] { dfs(neighbor) } } stack = append(stack, node) } for i := 1; i \u003c= n; i++ { if !visited[i] { dfs(i) } } // Reverse the stack for i, j := 0, len(stack)-1; i \u003c j; i, j = i+1, j-1 { stack[i], stack[j] = stack[j], stack[i] } return stack } üõ£Ô∏è Dijkstra‚Äôs Algorithm (Shortest Path) Used in weighted graphs with non-negative edges.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 type Item struct { node, dist int } func dijkstra(graph map[int][]Item, start int, n int) []int { const INF = int(1e9) dist := make([]int, n+1) for i := range dist { dist[i] = INF } dist[start] = 0 pq := \u0026MinHeap{} heap.Init(pq) heap.Push(pq, Item{start, 0}) for pq.Len() \u003e 0 { curr := heap.Pop(pq).(Item) if curr.dist \u003e dist[curr.node] { continue } for _, neighbor := range graph[curr.node] { newDist := dist[curr.node] + neighbor.dist if newDist \u003c dist[neighbor.node] { dist[neighbor.node] = newDist heap.Push(pq, Item{neighbor.node, newDist}) } } } return dist } Hint\nYou‚Äôll need a priority queue with container/heap.\nüéØ Key Problem Patterns Problem Technique Find if a graph is connected DFS / BFS Shortest path (unweighted graph) BFS Shortest path (weighted graph) Dijkstra‚Äôs All-pairs shortest paths Floyd-Warshall Topological sort DFS / Kahn‚Äôs Algo Cycle detection (undirected graph) DFS + parent Bipartite graph check BFS + coloring üß† Final Thoughts Graph problems may seem tough at first, but they become second nature with practice. Whether it‚Äôs mapping networks, detecting cycles, or optimizing routes, graph theory is a core skill that unlocks deep algorithmic power.\n‚úçÔ∏è Practice Tip: Solve 10‚Äì15 problems covering DFS, BFS, topological sort, and shortest path. Then go deeper into Union-Find, Bridges, and Articulation Points.\nüöÄ Follow me on norbix.dev for more insights on Go, Python, AI, system design, and engineering wisdom.\n","wordCount":"837","inLanguage":"en","datePublished":"2025-04-19T15:34:33+02:00","dateModified":"2025-04-19T15:34:33+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://norbix.dev/posts/graph-theory-algorithms-4-competitive-programming/"},"publisher":{"@type":"Organization","name":"norbix.dev - The log of my journey through code \u0026 software systems architecture","logo":{"@type":"ImageObject","url":"https://norbix.dev/favicon.ico"}}}</script></head><body><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://norbix.dev/ accesskey=h title="norbix.dev - The log of my journey through code & software systems architecture (Alt + H)">norbix.dev - The log of my journey through code & software systems architecture</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://norbix.dev/ title=Home><span>Home</span></a></li><li><a href=https://norbix.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://norbix.dev/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://norbix.dev/about/ title=About><span>About</span></a></li><li><a href=https://norbix.dev/index.xml title="üì° RSS"><span>üì° RSS</span></a></li></ul></nav></header><main><main id=main><article class=post-single><header class=post-header><h1 class=post-title>Graph Theory Algorithms 4 Competitive Programming</h1><span title='2025-04-19 15:34:33 +0200 +0200'>April 19, 2025</span></header><div class=post-content><nav class=table-of-contents><nav id=TableOfContents><ul><li><a href=#-graph-theory-for-competitive-programming>üß† Graph Theory for Competitive Programming</a></li><li><a href=#-what-is-a-graph>üï∏Ô∏è What Is a Graph?</a></li><li><a href=#-dfs-and-bfs--graph-traversal>üîç DFS and BFS ‚Äì Graph Traversal</a></li><li><a href=#-connected-components>üîó Connected Components</a></li><li><a href=#-cycle-detection-undirected-graph>‚õìÔ∏è Cycle Detection (Undirected Graph)</a></li><li><a href=#-topological-sort-directed-acyclic-graph>üìê Topological Sort (Directed Acyclic Graph)</a></li><li><a href=#-dijkstras-algorithm-shortest-path>üõ£Ô∏è Dijkstra‚Äôs Algorithm (Shortest Path)</a></li><li><a href=#-key-problem-patterns>üéØ Key Problem Patterns</a></li><li><a href=#-final-thoughts>üß† Final Thoughts</a></li><li><a href=#-practice-tip>‚úçÔ∏è Practice Tip:</a></li></ul></nav></nav><p><img loading=lazy src=banner.jpg alt=banner></p><hr><h2 id=-graph-theory-for-competitive-programming>üß† Graph Theory for Competitive Programming</h2><p>In competitive programming, few topics are as powerful‚Äîand sometimes intimidating‚Äîas graph theory. Whether it‚Äôs shortest paths, connected components, or cycles, graphs appear everywhere from Google Maps to dependency resolution.</p><p>In this article, we‚Äôll explore the essential graph concepts, common problems, and Go (Golang) code snippets to help you handle any graph-based challenge on coding platforms like Codeforces, LeetCode, or AtCoder.</p><hr><h2 id=-what-is-a-graph>üï∏Ô∏è What Is a Graph?</h2><p>A graph is a collection of nodes (vertices) and edges (connections between nodes). It can be:</p><ul><li>Directed or Undirected</li><li>Weighted or Unweighted</li><li>Connected or Disconnected</li><li>Cyclic or Acyclic</li></ul><p>A simple undirected graph looks like:</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>
graph TD
A(1) -- 2 ‚Üî 1 --&gt; B(2)
B -- 3 ‚Üî 2 --&gt; C(3)
C -- 4 ‚Üî 3 --&gt; D(4)
D -- 1 ‚Üî 4 --&gt; A
</code></pre><p>In Go, we typically represent graphs using an adjacency list.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>graph</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>][]</span><span class=kt>int</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=mi>1</span><span class=p>:</span> <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>},</span>
</span></span><span class=line><span class=cl>	<span class=mi>2</span><span class=p>:</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>},</span>
</span></span><span class=line><span class=cl>	<span class=mi>3</span><span class=p>:</span> <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>},</span>
</span></span><span class=line><span class=cl>	<span class=mi>4</span><span class=p>:</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=-dfs-and-bfs--graph-traversal>üîç DFS and BFS ‚Äì Graph Traversal</h2><p>Use <code>DFS</code> for problems involving backtracking, connected components, and cycle detection.</p><p>Use <code>BFS</code> for shortest paths in unweighted graphs or level-order traversal</p><p><strong>Depth-First Search (DFS)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>dfs</span><span class=p>(</span><span class=nx>node</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>visited</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>bool</span><span class=p>,</span> <span class=nx>graph</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>][]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>visited</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>visited</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>neighbor</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>graph</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>dfs</span><span class=p>(</span><span class=nx>neighbor</span><span class=p>,</span> <span class=nx>visited</span><span class=p>,</span> <span class=nx>graph</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>Breadth-First Search (BFS)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>bfs</span><span class=p>(</span><span class=nx>start</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>graph</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>][]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>visited</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>bool</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>queue</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=nx>start</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>queue</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>node</span> <span class=o>:=</span> <span class=nx>queue</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=nx>queue</span> <span class=p>=</span> <span class=nx>queue</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>visited</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>visited</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>neighbor</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>graph</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>!</span><span class=nx>visited</span><span class=p>[</span><span class=nx>neighbor</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>queue</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>queue</span><span class=p>,</span> <span class=nx>neighbor</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=-connected-components>üîó Connected Components</h2><p>In an undirected graph, you can find connected components by running DFS from each unvisited node.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>countComponents</span><span class=p>(</span><span class=nx>graph</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>][]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>visited</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>count</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>!</span><span class=nx>visited</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>dfs</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>visited</span><span class=p>,</span> <span class=nx>graph</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>count</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>count</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=-cycle-detection-undirected-graph>‚õìÔ∏è Cycle Detection (Undirected Graph)</h2><p>DFS with parent tracking:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>hasCycle</span><span class=p>(</span><span class=nx>node</span><span class=p>,</span> <span class=nx>parent</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>visited</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>bool</span><span class=p>,</span> <span class=nx>graph</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>][]</span><span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>visited</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>neighbor</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>graph</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>!</span><span class=nx>visited</span><span class=p>[</span><span class=nx>neighbor</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nf>hasCycle</span><span class=p>(</span><span class=nx>neighbor</span><span class=p>,</span> <span class=nx>node</span><span class=p>,</span> <span class=nx>visited</span><span class=p>,</span> <span class=nx>graph</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>neighbor</span> <span class=o>!=</span> <span class=nx>parent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=-topological-sort-directed-acyclic-graph>üìê Topological Sort (Directed Acyclic Graph)</h2><p>Used in task scheduling or course dependency problems.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>topologicalSort</span><span class=p>(</span><span class=nx>graph</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>][]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>visited</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>stack</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>dfs</span> <span class=kd>func</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>dfs</span> <span class=p>=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>node</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>visited</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>neighbor</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>graph</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>!</span><span class=nx>visited</span><span class=p>[</span><span class=nx>neighbor</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nf>dfs</span><span class=p>(</span><span class=nx>neighbor</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>stack</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stack</span><span class=p>,</span> <span class=nx>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>!</span><span class=nx>visited</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>dfs</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Reverse the stack</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>j</span><span class=p>;</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=p>=</span> <span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>j</span><span class=o>-</span><span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>stack</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>stack</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=nx>stack</span><span class=p>[</span><span class=nx>j</span><span class=p>],</span> <span class=nx>stack</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>stack</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=-dijkstras-algorithm-shortest-path>üõ£Ô∏è Dijkstra‚Äôs Algorithm (Shortest Path)</h2><p>Used in weighted graphs with non-negative edges.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Item</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>node</span><span class=p>,</span> <span class=nx>dist</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>dijkstra</span><span class=p>(</span><span class=nx>graph</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>][]</span><span class=nx>Item</span><span class=p>,</span> <span class=nx>start</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>const</span> <span class=nx>INF</span> <span class=p>=</span> <span class=nb>int</span><span class=p>(</span><span class=mf>1e9</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>dist</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>dist</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>dist</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>INF</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>dist</span><span class=p>[</span><span class=nx>start</span><span class=p>]</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>pq</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>MinHeap</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>heap</span><span class=p>.</span><span class=nf>Init</span><span class=p>(</span><span class=nx>pq</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>heap</span><span class=p>.</span><span class=nf>Push</span><span class=p>(</span><span class=nx>pq</span><span class=p>,</span> <span class=nx>Item</span><span class=p>{</span><span class=nx>start</span><span class=p>,</span> <span class=mi>0</span><span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>pq</span><span class=p>.</span><span class=nf>Len</span><span class=p>()</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>curr</span> <span class=o>:=</span> <span class=nx>heap</span><span class=p>.</span><span class=nf>Pop</span><span class=p>(</span><span class=nx>pq</span><span class=p>).(</span><span class=nx>Item</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>curr</span><span class=p>.</span><span class=nx>dist</span> <span class=p>&gt;</span> <span class=nx>dist</span><span class=p>[</span><span class=nx>curr</span><span class=p>.</span><span class=nx>node</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>neighbor</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>graph</span><span class=p>[</span><span class=nx>curr</span><span class=p>.</span><span class=nx>node</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>newDist</span> <span class=o>:=</span> <span class=nx>dist</span><span class=p>[</span><span class=nx>curr</span><span class=p>.</span><span class=nx>node</span><span class=p>]</span> <span class=o>+</span> <span class=nx>neighbor</span><span class=p>.</span><span class=nx>dist</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>newDist</span> <span class=p>&lt;</span> <span class=nx>dist</span><span class=p>[</span><span class=nx>neighbor</span><span class=p>.</span><span class=nx>node</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>dist</span><span class=p>[</span><span class=nx>neighbor</span><span class=p>.</span><span class=nx>node</span><span class=p>]</span> <span class=p>=</span> <span class=nx>newDist</span>
</span></span><span class=line><span class=cl>				<span class=nx>heap</span><span class=p>.</span><span class=nf>Push</span><span class=p>(</span><span class=nx>pq</span><span class=p>,</span> <span class=nx>Item</span><span class=p>{</span><span class=nx>neighbor</span><span class=p>.</span><span class=nx>node</span><span class=p>,</span> <span class=nx>newDist</span><span class=p>})</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>dist</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>Hint</strong></p><p>You‚Äôll need a priority queue with container/heap.</p><hr><h2 id=-key-problem-patterns>üéØ Key Problem Patterns</h2><table><thead><tr><th>Problem</th><th>Technique</th></tr></thead><tbody><tr><td>Find if a graph is connected</td><td>DFS / BFS</td></tr><tr><td>Shortest path (unweighted graph)</td><td>BFS</td></tr><tr><td>Shortest path (weighted graph)</td><td>Dijkstra‚Äôs</td></tr><tr><td>All-pairs shortest paths</td><td>Floyd-Warshall</td></tr><tr><td>Topological sort</td><td>DFS / Kahn&rsquo;s Algo</td></tr><tr><td>Cycle detection (undirected graph)</td><td>DFS + parent</td></tr><tr><td>Bipartite graph check</td><td>BFS + coloring</td></tr></tbody></table><hr><h2 id=-final-thoughts>üß† Final Thoughts</h2><p>Graph problems may seem tough at first, but they become second nature with practice.
Whether it‚Äôs mapping networks, detecting cycles, or optimizing routes, graph theory is a core skill that unlocks deep algorithmic power.</p><hr><h2 id=-practice-tip>‚úçÔ∏è Practice Tip:</h2><p>Solve 10‚Äì15 problems covering <code>DFS</code>, <code>BFS</code>, <code>topological sort</code>, and <code>shortest path</code>. Then go deeper into <code>Union-Find</code>, <code>Bridges</code>, and <code>Articulation Points</code>.</p><hr><p>üöÄ Follow me on <a href=https://norbix.dev>norbix.dev</a> for more insights on Go, Python, AI, system design, and engineering wisdom.</p></div><div class=post-subscribe><style>.subscribe-form{display:flex;gap:.5rem;margin-top:1rem;align-items:center}.subscribe-form input[type=email]{padding:.5rem;border-radius:6px;border:1px solid #ccc;background-color:#1f1f1f;color:#fff}.subscribe-form input[type=submit],.subscribe-form button{padding:.5rem 1rem;border-radius:6px;background-color:#facc15;color:#000;border:none;cursor:pointer;font-weight:700}.subscribe-form input[type=submit]:hover{background-color:#fcd34d}</style><form action=https://buttondown.email/api/emails/embed-subscribe/norbix method=post target=popupwindow onsubmit='window.open("https://buttondown.email/norbix","popupwindow")' class=subscribe-form><input type=email name=email placeholder="Enter your email" required>
<input type=submit value=Subscribe></form><p style=font-size:.875rem;opacity:.6>Powered by Buttondown.</p></div><div class=post-comments><script src=https://giscus.app/client.js data-repo=norbix/norbix.dev data-repo-id=R_kgDOOV_xMQ data-category=Announcements data-category-id=DIC_kwDOOV_xMc4CpF5M data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=dark data-lang=en crossorigin=anonymous async></script></div><nav class=paginav><a class=prev href=https://norbix.dev/posts/algorithms-and-data-structures/><span class=title>¬´ Prev</span><br><span>DSA - Data Structures and Algorithms</span>
</a><a class=next href=https://norbix.dev/posts/concurrency-in-go/><span class=title>Next ¬ª</span><br><span>Concurrency in Go</span></a></nav></article></main></main><footer class=footer><span>&copy; 2025 <a href=https://norbix.dev/>norbix.dev - The log of my journey through code & software systems architecture</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script src=https://platform.linkedin.com/badges/js/profile.js async defer type=text/javascript></script></body></html>
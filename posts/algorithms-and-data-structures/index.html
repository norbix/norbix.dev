<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><script>(function(){const e=localStorage.getItem("theme"),t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches;e==="dark"||!e&&t?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark"),window.setTheme=function(e){localStorage.setItem("theme",e),document.documentElement.classList.toggle("dark",e==="dark")}})()</script><title>DSA - Data Structures and Algorithms | norbix.dev
</title><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DSA - Data Structures and Algorithms | norbix.dev - The log of my journey through code & software systems architecture</title>
<meta name=keywords content="go,golang,python,algorithms,data-structures"><meta name=description content="A deep dive into Data Structures and Algorithms (DSA) using Go and its Python counterpart, covering essential concepts, implementations, and best practices."><meta name=author content><link rel=canonical href=https://norbix.dev/posts/algorithms-and-data-structures/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://norbix.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://norbix.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://norbix.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://norbix.dev/apple-touch-icon.png><link rel=mask-icon href=https://norbix.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://norbix.dev/posts/algorithms-and-data-structures/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=canonical href=https://norbix.dev/posts/algorithms-and-data-structures/><meta property="og:title" content="DSA - Data Structures and Algorithms"><meta property="og:url" content="https://norbix.dev/posts/algorithms-and-data-structures/"><meta property="og:image" content="https://norbix.dev/banner.jpg"><meta property="og:type" content="article"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="DSA - Data Structures and Algorithms"><meta name=twitter:image content="https://norbix.dev/banner.jpg"><script data-goatcounter=https://norbix.goatcounter.com/count async src=//gc.zgo.at/count.js></script><link rel=alternate type=application/rss+xml title="RSS Feed for norbix.dev" href=/index.xml><script src=https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js defer></script><script>document.addEventListener("DOMContentLoaded",function(){window.mermaid&&(document.querySelectorAll("code.language-mermaid").forEach(function(e){var n=e.parentElement,t=document.createElement("div");t.className="mermaid",t.textContent=e.textContent,n.replaceWith(t)}),mermaid.initialize({startOnLoad:!0}))})</script><link href=https://cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.3/css/lightbox.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.3/js/lightbox.min.js defer></script><meta property="og:title" content="DSA - Data Structures and Algorithms"><meta property="og:description" content="A deep dive into Data Structures and Algorithms (DSA) using Go and its Python counterpart, covering essential concepts, implementations, and best practices."><meta property="og:type" content="article"><meta property="og:url" content="https://norbix.dev/posts/algorithms-and-data-structures/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-24T18:10:25+02:00"><meta property="article:modified_time" content="2025-07-24T18:10:25+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="DSA - Data Structures and Algorithms"><meta name=twitter:description content="A deep dive into Data Structures and Algorithms (DSA) using Go and its Python counterpart, covering essential concepts, implementations, and best practices."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://norbix.dev/posts/"},{"@type":"ListItem","position":2,"name":"DSA - Data Structures and Algorithms","item":"https://norbix.dev/posts/algorithms-and-data-structures/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"DSA - Data Structures and Algorithms","name":"DSA - Data Structures and Algorithms","description":"A deep dive into Data Structures and Algorithms (DSA) using Go and its Python counterpart, covering essential concepts, implementations, and best practices.","keywords":["go","golang","python","algorithms","data-structures"],"articleBody":" ğŸ§  Mastering Data Structures and Algorithms (DSA) with Go and its Python Counterpart Whether youâ€™re preparing for technical interviews, optimizing backend systems, or simply sharpening your problem-solving chops, Data Structures and Algorithms (DSA) are foundational to your success as a developer.\nIn this article, Iâ€™ll walk you through core DSA concepts using Golang and Python, a language praised for its simplicity, performance, and concurrency model. Youâ€™ll see how Go makes understanding DSA both intuitive and powerful.\nğŸš€ What is DSA? Data Structures organize and store data efficiently, while Algorithms define step-by-step instructions to solve problems or manipulate data.\nTogether, DSA provides the backbone for high-performance applications.\nğŸ“¦ Essential Data Structures in Go and its Python Counterpart Arrays \u0026 Slices\nGo implementation:\n1 2 3 4 5 arr := [5]int{1, 2, 3, 4, 5} // Fixed-size array slice := []int{1, 2, 3} // Dynamic size slice = append(slice, 4) fmt.Println(slice) // [1 2 3 4] Python implementation:\n1 2 3 arr = [1, 2, 3, 4, 5] # Dynamic array (list in Python) arr.append(6) print(arr) # [1, 2, 3, 4, 5, 6] Slices are the idiomatic way to work with collections in Go. They offer flexibility while leveraging arrays under the hood.\nLinked List\nGo doesnâ€™t have a built-in linked list, but the container/list package provides one.\nGo implementation:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \"container/list\" \"fmt\" ) func main() { l := list.New() l.PushBack(\"Go\") l.PushBack(\"DSA\") for e := l.Front(); e != nil; e = e.Next() { fmt.Println(e.Value) } } Python implementation:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def append(self, data): new_node = Node(data) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def print_list(self): current = self.head while current: print(current.data) current = current.next ll = LinkedList() ll.append(\"Python\") ll.append(\"DSA\") ll.print_list() Stack (LIFO)\nA stack can be easily implemented using slices.\nGo implementation:\n1 2 3 4 5 6 7 8 9 10 11 12 type Stack []int func (s *Stack) Push(v int) { *s = append(*s, v) } func (s *Stack) Pop() int { n := len(*s) val := (*s)[n-1] *s = (*s)[:n-1] return val } Python implementation:\n1 2 3 4 5 6 7 8 9 10 11 class Stack: def __init__(self): self.stack = [] def push(self, item): self.stack.append(item) # append to the end (like Go's append) def pop(self): if not self.stack: raise IndexError(\"pop from empty stack\") return self.stack.pop() # pop from the end (like Go's slice) Queue (FIFO)\nQueues can also be implemented using slices.\nGo implementation:\n1 2 3 4 5 6 7 8 9 10 11 type Queue []int func (q *Queue) Enqueue(v int) { *q = append(*q, v) } func (q *Queue) Dequeue() int { val := (*q)[0] *q = (*q)[1:] return val } Python implementation:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Queue: def __init__(self): self.queue = [] def enqueue(self, item): # append to the end (like Go's append) self.queue.append(item) def dequeue(self): if not self.queue: raise IndexError(\"dequeue from empty queue\") # take from the front (like q[0] in Go) val = self.queue[0] self.queue = self.queue[1:] # shrink list (like Go slice) return val Hash Map (Go's map)\nGo implementation:\n1 2 3 4 5 m := map[string]int{ \"apple\": 5, \"banana\": 3, } fmt.Println(m[\"apple\"]) // 5 Hint: Goâ€™s built-in map is a powerful hash table implementation for key-value pairs.\nğŸ”‘ What types can be keys in a Go map?\nA map key must be comparable (Go requires == and != operators to be defined).\nâœ… Allowed key types:\nBooleans (bool)\nNumbers (int, float64, etc.)\nStrings\nPointers\nChannels\nInterfaces (if the underlying type is comparable)\nStructs (if all their fields are comparable)\nArrays (fixed-size, if elements are comparable)\nâŒ Not allowed as keys:\nSlices\nMaps\nFunctions\nThese types are not comparable in Go, so they cannot be used as map keys.\nExample:\n1 2 3 4 5 6 7 8 9 // Valid keys m1 := map[int]string{1: \"one\", 2: \"two\"} m2 := map[bool]string{true: \"yes\", false: \"no\"} m3 := map[[2]int]string{{1, 2}: \"coords\"} // array key m4 := map[struct{ID int}]string{{ID: 1}: \"first\"} // struct key fmt.Println(m1[1]) // \"one\" fmt.Println(m2[false]) // \"no\" fmt.Println(m3[[2]int{1, 2}]) // \"coords\" If you try with a slice:\n1 m := map[[]int]string{} ğŸ‘‰ Youâ€™ll get a compile-time error:\n1 invalid map key type []int âœ… Summary:\nGo maps work with keys of any type that is comparable.\nCommonly: string, int, bool, structs, and arrays.\nNot allowed: slices, maps, functions.\nPython implementation:\n1 2 3 4 5 m = { \"apple\": 5, \"banana\": 3, } print(m[\"apple\"]) # 5 ğŸ”‘ What types can be keys in a Python dict?\nA key must be hashable â†’ meaning it has a valid hash() and does not change during its lifetime.\nâœ… Allowed key types:\nImmutable built-ins: str, int, float, bool, bytes\nTuples (if all elements are hashable)\nfrozenset (immutable version of set`)\nUser-defined classes (if they implement hash and eq)\nâŒ Not allowed as keys:\nMutable types like list, dict, and set\nThese can change after being used as a key, which would break hash table invariants.\nExample:\n1 2 3 4 5 6 7 8 9 # Valid keys m1 = {1: \"one\", 2: \"two\"} # int keys m2 = {True: \"yes\", False: \"no\"} # bool keys m3 = {(1, 2): \"coords\"} # tuple key m4 = {frozenset([1, 2]): \"frozen set\"} # frozenset key print(m1[1]) # \"one\" print(m2[False]) # \"no\" print(m3[(1, 2)]) # \"coords\" If you try with a list:\n1 m = { [1, 2]: \"coords\" } ğŸ‘‰ Youâ€™ll get a runtime error:\n1 TypeError: unhashable type: 'list' âœ… Summary:\nPython dicts require keys to be hashable.\nCommonly: strings, numbers, booleans, tuples of immutables, frozensets.\nNot allowed: lists, dicts, sets (mutable types).\nğŸ§© Must-Know Algorithms in Go Binary Search\nEfficient O(log n) search on sorted arrays.\nGo implementation:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func binarySearch(arr []int, target int) int { low, high := 0, len(arr)-1 for low \u003c= high { mid := (low + high) / 2 if arr[mid] == target { return mid } else if arr[mid] \u003c target { low = mid + 1 } else { high = mid - 1 } } return -1 } Python implementation:\n1 2 3 4 5 6 7 8 9 10 11 def binary_search(arr, target): low, high = 0, len(arr) - 1 while low \u003c= high: mid = (low + high) // 2 if arr[mid] == target: return mid elif arr[mid] \u003c target: low = mid + 1 else: high = mid - 1 return -1 Sorting (Bubble Sort Example)\nVideo explanation: Bubble Sort Algorithm\nGo implementation:\n1 2 3 4 5 6 7 8 9 10 func bubbleSort(arr []int) { n := len(arr) for i := 0; i \u003c n-1; i++ { for j := 0; j \u003c n-i-1; j++ { if arr[j] \u003e arr[j+1] { arr[j], arr[j+1] = arr[j+1], arr[j] } } } } Python implementation:\n1 2 3 4 5 6 def bubble_sort(arr): n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] \u003e arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] For real projects, use Goâ€™s built-in sorting:\n1 sort.Ints(arr) Recursion: Factorial\nFactorial of n (n!) is the product of all positive integers up to n.\nGo implementation:\n1 2 3 4 5 6 7 func factorial(n int) int { if n == 0 { return 1 } return n * factorial(n-1) } Python implementation:\n1 2 3 4 def factorial(n): if n == 0: return 1 return n * factorial(n-1) Example: The factorial of 4 is 4 * 3 * 2 * 1 = 24.\n1 2 3 4 5 6 7 factorial(4) = 4 * factorial(3) = 4 * (3 * factorial(2)) = 4 * (3 * (2 * factorial(1))) = 4 * (3 * (2 * (1 * factorial(0)))) = 4 * (3 * (2 * (1 * 1))) = 24 Fibonacci Sequence\nFibonacci numbers are the sum of the two preceding ones, starting from 0 and 1.\nGo implementation:\n1 2 3 4 5 6 func fibonacci(n int) int { if n \u003c= 1 { return n } return fibonacci(n-1) + fibonacci(n-2) } Python implementation:\n1 2 3 4 def fibonacci(n): if n \u003c= 1: return n return fibonacci(n-1) + fibonacci(n-2) Example: The sequence starts as: 0, 1, 1, 2, 3, 5, 8, 13, â€¦\n1 2 3 4 5 6 7 fibonacci(5) = fibonacci(4) + fibonacci(3) = (fibonacci(3) + fibonacci(2)) + (fibonacci(2) + fibonacci(1)) = ((fibonacci(2) + fibonacci(1)) + (fibonacci(1) + fibonacci(0))) + (fibonacci(1) + 1) = (((fibonacci(1) + fibonacci(0)) + 1) + (1 + 0)) + (1 + 1) = (((1 + 0) + 1) + 1) + 2 = 5 Prime Check\nPrime numbers are greater than 1 and only divisible by 1 and themselves.\nGo implementation:\n1 2 3 4 5 6 7 8 9 10 11 func isPrime(n int) bool { if n \u003c= 1 { return false } for i := 2; i*i \u003c= n; i++ { if n%i == 0 { return false } } return true } Python implementation:\n1 2 3 4 5 6 7 8 9 from math import sqrt def is_prime(n): if n \u003c= 1: return False for i in range(2, int(sqrt(n)) + 1): if n % i == 0: return False return True Example: The number 11 is prime, while 12 is not.\n1 2 3 4 5 isPrime(11) = true (11 is only divisible by 1 and 11) isPrime(12) = false (12 is divisible by 1, 2, 3, 4, 6, and 12) FizzBuzz :)\nA classic programming challenge.\nGo implementation:\n1 2 3 4 5 6 7 8 9 10 11 12 13 func fizzBuzz(n int) { for i := 1; i \u003c= n; i++ { if i%3 == 0 \u0026\u0026 i%5 == 0 { fmt.Println(\"FizzBuzz\") } else if i%3 == 0 { fmt.Println(\"Fizz\") } else if i%5 == 0 { fmt.Println(\"Buzz\") } else { fmt.Println(i) } } } Python implementation:\n1 2 3 4 5 6 7 8 9 10 def fizz_buzz(n): for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: print(\"FizzBuzz\") elif i % 3 == 0: print(\"Fizz\") elif i % 5 == 0: print(\"Buzz\") else: print(i) Example: For n = 15 print the numbers from 1 to 15. For multiples of 3, print â€œFizzâ€ instead of the number. For multiples of 5, print â€œBuzzâ€. For numbers which are multiples of both 3 and 5, print â€œFizzBuzzâ€.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz Graph and Trees\nFor binary trees, you define custom structures.\nGo implementation:\n1 2 3 4 5 type Node struct { Value int Left *Node Right *Node } Python implementation:\n1 2 3 4 5 class Node: def __init__(self, value): self.value = value self.left = None self.right = None Depth-first traversal:\nGo implementation:\n1 2 3 4 5 6 7 8 9 func dfs(n *Node) { if n == nil { return } fmt.Println(n.Value) dfs(n.Left) dfs(n.Right) } Python implementation:\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Node: def __init__(self, value): self.value = value self.left = None self.right = None def dfs(node): if node is None: return print(node.value) # Preorder: visit root dfs(node.left) # Traverse left subtree dfs(node.right) # Traverse right subtree ğŸ”ƒ Sort Algorithms Sorting is a fundamental concept in computer science used in everything from searching to data normalization and ranking systems. Below are essential sorting algorithms every developer should know, implemented in Go.\nMerge Sort (ğŸ§¬ Divide and Conquer â€“ O(n log n))\nMerge Sort recursively splits arrays into halves and merges them in a sorted manner.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func mergeSort(arr []int) []int { if len(arr) \u003c= 1 { return arr } mid := len(arr) / 2 left := mergeSort(arr[:mid]) right := mergeSort(arr[mid:]) return merge(left, right) } func merge(left, right []int) []int { result := []int{} i, j := 0, 0 for i \u003c len(left) \u0026\u0026 j \u003c len(right) { if left[i] \u003c right[j] { result = append(result, left[i]) i++ } else { result = append(result, right[j]) j++ } } return append(result, append(left[i:], right[j:]...)...) } Quick Sort (âš¡ Partition-based â€“ Average: O(n log n), Worst: O(nÂ²))\nQuick Sort selects a pivot and partitions the array into smaller and larger elements.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func quickSort(arr []int) { if len(arr) \u003c 2 { return } left, right := 0, len(arr)-1 pivot := rand.Int() % len(arr) arr[pivot], arr[right] = arr[right], arr[pivot] for i := range arr { if arr[i] \u003c arr[right] { arr[i], arr[left] = arr[left], arr[i] left++ } } arr[left], arr[right] = arr[right], arr[left] quickSort(arr[:left]) quickSort(arr[left+1:]) } Bubble Sort (ğŸ«§ Simple but Inefficient â€“ O(nÂ²))\nRepeatedly swaps adjacent elements if they are in the wrong order.\n1 2 3 4 5 6 7 8 9 10 func bubbleSort(arr []int) { n := len(arr) for i := 0; i \u003c n-1; i++ { for j := 0; j \u003c n-i-1; j++ { if arr[j] \u003e arr[j+1] { arr[j], arr[j+1] = arr[j+1], arr[j] } } } } Insertion Sort (ğŸ§© Efficient for Small Datasets â€“ O(nÂ²))\nBuilds the sorted array one item at a time.\n1 2 3 4 5 6 7 8 9 10 11 func insertionSort(arr []int) { for i := 1; i \u003c len(arr); i++ { key := arr[i] j := i - 1 for j \u003e= 0 \u0026\u0026 arr[j] \u003e key { arr[j+1] = arr[j] j-- } arr[j+1] = key } } Selection Sort (ğŸ“Œ Selects Minimum â€“ O(nÂ²))\nRepeatedly finds the minimum element and places it at the beginning.\n1 2 3 4 5 6 7 8 9 10 11 12 func selectionSort(arr []int) { n := len(arr) for i := 0; i \u003c n-1; i++ { minIdx := i for j := i + 1; j \u003c n; j++ { if arr[j] \u003c arr[minIdx] { minIdx = j } } arr[i], arr[minIdx] = arr[minIdx], arr[i] } } Heap Sort (ğŸ—ï¸ Priority Queue-based â€“ O(n log n))\nUses a binary heap structure to repeatedly extract the max element.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func heapSort(arr []int) { n := len(arr) // Build max heap for i := n/2 - 1; i \u003e= 0; i-- { heapify(arr, n, i) } for i := n - 1; i \u003e 0; i-- { arr[0], arr[i] = arr[i], arr[0] heapify(arr, i, 0) } } func heapify(arr []int, n, i int) { largest := i left := 2*i + 1 right := 2*i + 2 if left \u003c n \u0026\u0026 arr[left] \u003e arr[largest] { largest = left } if right \u003c n \u0026\u0026 arr[right] \u003e arr[largest] { largest = right } if largest != i { arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest) } } Each of these sorting algorithms serves different use cases. While Goâ€™s sort package provides optimized versions, understanding how these work internally is critical for building performance-conscious software.\nğŸ“‘ Sorting Algorithms - Cheat Sheet Algorithm Best Time Avg Time Worst Time Space Stable In-Place Notes Merge Sort O(n log n) O(n log n) O(n log n) O(n) âœ… Yes âŒ No Divide and conquer, great for linked lists Quick Sort O(n log n) O(n log n) O(nÂ²) O(log n) âŒ No âœ… Yes Very fast in practice, not stable Bubble Sort O(n) O(nÂ²) O(nÂ²) O(1) âœ… Yes âœ… Yes Educational use only, very slow Insertion Sort O(n) O(nÂ²) O(nÂ²) O(1) âœ… Yes âœ… Yes Efficient for small or nearly sorted data Selection Sort O(nÂ²) O(nÂ²) O(nÂ²) O(1) âŒ No âœ… Yes Always O(nÂ²), rarely used Heap Sort O(n log n) O(n log n) O(n log n) O(1) âŒ No âœ… Yes Good for priority queues âœ… Stable: Maintains the relative order of equal elements\nâœ… In-Place: Uses constant extra space (excluding recursion stack)\nğŸ” Search Algorithms Search algorithms are foundational tools in computer science used to retrieve information stored in data structures like arrays, trees, or graphs. Whether youâ€™re working with sorted arrays, exploring hierarchical structures, or traversing complex graphs, the right search algorithm can dramatically improve efficiency and performance.\nLetâ€™s dive into three essential search algorithms and their Go implementations:\nğŸ§­ Binary Search\nUse Case: Efficiently search for a value in a sorted array. Time Complexity: O(log n) Space Complexity: O(1) (iterative), O(log n) (recursive)\nConcept: Binary Search divides the array into halves, eliminating one half at each step, depending on whether the target is greater or smaller than the midpoint.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func BinarySearch(arr []int, target int) int { left, right := 0, len(arr)-1 for left \u003c= right { mid := left + (right-left)/2 if arr[mid] == target { return mid } else if arr[mid] \u003c target { left = mid + 1 } else { right = mid - 1 } } return -1 // not found } ğŸŒ Breadth-First Search (BFS)\nUse Case: Traverse or search tree/graph level by level. Ideal for finding the shortest path in unweighted graphs. Time Complexity: O(V + E) (vertices + edges) Space Complexity: O(V)\nConcept: BFS uses a queue to explore all neighboring nodes before going deeper. Itâ€™s a level-order traversal for trees or graphs.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func BFS(graph map[int][]int, start int) []int { visited := make(map[int]bool) queue := []int{start} result := []int{} for len(queue) \u003e 0 { node := queue[0] queue = queue[1:] if visited[node] { continue } visited[node] = true result = append(result, node) for _, neighbor := range graph[node] { if !visited[neighbor] { queue = append(queue, neighbor) } } } return result } ğŸ§± Depth-First Search (DFS)\nUse Case: Explore all paths or check for connectivity in graphs/trees. Great for scenarios like maze-solving, backtracking, and topological sorting. Time Complexity: O(V + E) Space Complexity: O(V) (recursive stack or visited map)\nConcept: DFS explores as far as possible along each branch before backtracking. Implemented with recursion or a stack.\n1 2 3 4 5 6 7 8 9 10 11 12 13 func DFS(graph map[int][]int, start int, visited map[int]bool, result *[]int) { if visited[start] { return } visited[start] = true *result = append(*result, start) for _, neighbor := range graph[start] { if !visited[neighbor] { DFS(graph, neighbor, visited, result) } } } To initiate DFS:\n1 2 3 4 5 6 7 8 9 10 graph := map[int][]int{ 1: {2, 3}, 2: {4}, 3: {}, 4: {}, } visited := make(map[int]bool) result := []int{} DFS(graph, 1, visited, \u0026result) fmt.Println(result) // Output: [1 2 4 3] (DFS order may vary) ğŸ” Search Algorithms â€“ Cheat Sheet Algorithm Use Case Time Complexity Space Complexity Notes Binary Search Search in sorted arrays O(log n) O(1) (iterative)\nO(log n) (recursive) Requires sorted input Breadth-First Search (BFS) Shortest path in unweighted graphs O(V + E) O(V) Level-order traversal, uses a queue Depth-First Search (DFS) Exploring all paths, topological sort, cycle detection O(V + E) O(V) Preorder traversal, uses recursion or stack ğŸŒ³ Tree Traversal Algorithms Traversing a tree means visiting every node in a specific order. Whether youâ€™re parsing expressions, printing a binary tree, or converting structures, understanding traversal strategies is fundamental in computer science.\nThis guide covers the four most common tree traversal algorithms:\nPre-Order Traversal\nIn-Order Traversal\nPost-Order Traversal\nLevel-Order Traversal\nğŸ“ Tree Node Definition in Go\nBefore diving into each traversal, hereâ€™s the standard binary tree structure weâ€™ll use:\n1 2 3 4 5 type TreeNode struct { Val int Left *TreeNode Right *TreeNode } ğŸ” Pre-Order Traversal (Root â†’ Left â†’ Right)\nUse Case: Useful for copying a tree or prefix expression evaluation.\nSteps:\nVisit root\nTraverse left subtree\nTraverse right subtree\n1 2 3 4 5 6 7 8 func PreOrder(node *TreeNode, result *[]int) { if node == nil { return } *result = append(*result, node.Val) PreOrder(node.Left, result) PreOrder(node.Right, result) } ğŸ“ In-Order Traversal (Left â†’ Root â†’ Right)\nUse Case: Yields nodes in ascending order for Binary Search Trees (BST).\nSteps:\nTraverse left subtree\nVisit root\nTraverse right subtree\n1 2 3 4 5 6 7 8 func InOrder(node *TreeNode, result *[]int) { if node == nil { return } InOrder(node.Left, result) *result = append(*result, node.Val) InOrder(node.Right, result) } ğŸ§® Post-Order Traversal (Left â†’ Right â†’ Root)\nUse Case: Ideal for deleting or freeing nodes, postfix expression evaluation.\nSteps:\nTraverse left subtree\nTraverse right subtree\nVisit root\n1 2 3 4 5 6 7 8 func PostOrder(node *TreeNode, result *[]int) { if node == nil { return } PostOrder(node.Left, result) PostOrder(node.Right, result) *result = append(*result, node.Val) } ğŸ›ï¸ Level-Order Traversal (Breadth-First)\nUse Case: Used for printing trees by level or finding the shortest path in a tree.\nSteps:\nTraverse nodes level by level (left to right) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func LevelOrder(root *TreeNode) []int { if root == nil { return nil } queue := []*TreeNode{root} var result []int for len(queue) \u003e 0 { node := queue[0] queue = queue[1:] result = append(result, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } return result } ğŸ”§ Test Tree Example\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Construct the following tree: // 1 // / \\ // 2 3 // / \\ \\ // 4 5 6 root := \u0026TreeNode{Val: 1} root.Left = \u0026TreeNode{Val: 2} root.Right = \u0026TreeNode{Val: 3} root.Left.Left = \u0026TreeNode{Val: 4} root.Left.Right = \u0026TreeNode{Val: 5} root.Right.Right = \u0026TreeNode{Val: 6} var pre, in, post []int PreOrder(root, \u0026pre) InOrder(root, \u0026in) PostOrder(root, \u0026post) level := LevelOrder(root) fmt.Println(\"Pre-Order:\", pre) // [1 2 4 5 3 6] fmt.Println(\"In-Order:\", in) // [4 2 5 1 3 6] fmt.Println(\"Post-Order:\", post) // [4 5 2 6 3 1] fmt.Println(\"Level-Order:\", level)// [1 2 3 4 5 6] âš™ï¸ Quick Go Snippets\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // Pre-Order Traversal func PreOrder(node *TreeNode, result *[]int) { if node == nil { return } *result = append(*result, node.Val) PreOrder(node.Left, result) PreOrder(node.Right, result) } // In-Order Traversal func InOrder(node *TreeNode, result *[]int) { if node == nil { return } InOrder(node.Left, result) *result = append(*result, node.Val) InOrder(node.Right, result) } // Post-Order Traversal func PostOrder(node *TreeNode, result *[]int) { if node == nil { return } PostOrder(node.Left, result) PostOrder(node.Right, result) *result = append(*result, node.Val) } // Level-Order Traversal (BFS) func LevelOrder(root *TreeNode) []int { if root == nil { return nil } queue := []*TreeNode{root} var result []int for len(queue) \u003e 0 { node := queue[0] queue = queue[1:] result = append(result, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } return result } ğŸŒ³ Tree Traversal Algorithms â€“ Cheat Sheet Traversal Type Visit Order Use Case Time Complexity Space Complexity Pre-Order Root â†’ Left â†’ Right Copy tree, prefix expressions O(n) O(h) In-Order Left â†’ Root â†’ Right Sorted output in BSTs O(n) O(h) Post-Order Left â†’ Right â†’ Root Delete tree, postfix expressions O(n) O(h) Level-Order Level by level (BFS) Print by level, shortest path O(n) O(w) Legend:\nn: number of nodes h: tree height (log n for balanced, n for skewed) w: max width of the tree (can be up to n/2 in balanced trees) â— The Modulo Operator (%) The modulo operator is often underestimated, but itâ€™s a fundamental tool in both algorithm design and real-world programming.\nWhat Is Modulo? a % b returns the remainder after dividing a by b.\n1 a = b Ã— q + r where 0 â‰¤ r \u003c b Example: 5 % 2 = 1\nExample: 12 % 5 = 2\nExample: 20 % 5 = 0\nğŸ‘‰ If a \u003c b, then a % b = a.\nWhen Do We Use Modulo? Checking Divisibility\nIt is used to check if a number is even or odd.\nGo implementation:\n1 2 3 4 5 if n%2 == 0 { fmt.Println(\"Even\") } else { fmt.Println(\"Odd\") } Python implementation:\n1 2 3 4 if n % 2 == 0: print(\"Even\") else: print(\"Odd\") Cyclic Patterns (wrap-around\nGo implementation:\n1 2 3 days := []string{\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"} dayIndex := (currentDay + offset) % 7 fmt.Println(days[dayIndex]) Python implementation:\n1 2 3 days = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"] day_index = (current_day + offset) % 7 print(days[day_index]) ğŸ”„ Example Walkthrough\nLetâ€™s say today is Friday (currentDay = 5).\nOffset = 2 (2 days later):\n1 2 (5 + 2) % 7 = 7 % 7 = 0 days[0] = \"Sun\" âœ… Two days after Friday is Sunday.\nOffset = 10 (10 days later):\n1 2 (5 + 10) % 7 = 15 % 7 = 1 days[1] = \"Mon\" âœ… Ten days after Friday is Monday.\nOffset = -3 (3 days earlier):\n1 2 (5 - 3) % 7 = 2 % 7 = 2 days[2] = \"Tue\" âœ… Three days before Friday is Tuesday.\nRotating Arrays\nArray rotation is the process of shifting elements circularly â€” so elements that â€œfall offâ€ one end reappear on the other end.\nThis is common in:\nCoding interview problems (LeetCode, HackerRank).\nScheduling (round-robin tasks).\nGames \u0026 simulations (rotating positions, cyclic states).\nData processing (moving averages, cyclic windows).\nGo implementation:\n1 2 3 4 5 func rotate(arr []int, k int) []int { n := len(arr) k = k % n // handle k \u003e n return append(arr[n-k:], arr[:n-k]...) } Python implementation:\n1 2 3 4 def rotate(arr, k): n = len(arr) k = k % n # handle k \u003e n return arr[-k:] + arr[:-k] n := len(arr) â†’ length of the array.\nk = k % n â†’ ensures we donâ€™t rotate more than necessary (e.g., rotating 12 times on length 5 = same as rotating 2 times).\narr[n-k:] â†’ last k elements (to move to front).\narr[:n-k] â†’ first n-k elements (move after).\n`appen â†’ combines into rotated array.\nğŸ”„ Example Walkthrough\n1 2 3 4 arr := []int{1, 2, 3, 4, 5} k := 2 res := rotate(arr, k) fmt.Println(res) Steps:\nOriginal: [1 2 3 4 5]\nSplit: last 2 elements â†’ [4 5], first 3 elements â†’ [1 2 3]\nAppend: [4 5 1 2 3]\nâœ… Result: [4 5 1 2 3]\nğŸ”„ Another Example (k \u003e n)\n1 2 3 4 arr := []int{10, 20, 30, 40, 50} k := 7 res := rotate(arr, k) fmt.Println(res) n = 5\nk = 7 % 5 = 2\nSplit: last 2 â†’ [40 50], first 3 â†’ [10 20 30]\nResult: [40 50 10 20 30]\nğŸ§­ Left vs Right Rotations\nAbove code rotates to the right (end â†’ front).\nTo rotate left, just swap the slices:\n1 2 3 4 5 func rotateLeft(arr []int, k int) []int { n := len(arr) k = k % n return append(arr[k:], arr[:k]...) } âœ… Key Takeaway: Array rotation is a simple but powerful trick for cyclic problems. In Go, slicing + append makes it elegant and efficient.\nğŸ“Œ Use Cases\nRound-Robin Scheduling â†’ rotate task queue.\nCipher Algorithms â†’ shift characters cyclically.\nSliding Window Problems â†’ rotate buffers instead of reallocating.\nGaming â†’ rotate playersâ€™ turns.\nHashing\nHashing is the process of taking a large (potentially infinite) set of input keys and mapping them into a fixed range of slots. This is crucial for data structures like hash tables, maps, and sets, where we want fast lookup, insert, and delete operations.\nThe main idea:\nWe have more possible keys than storage slots.\nWe apply a hash function that always outputs a value within [0 â€¦ tableSize-1].\nThis allows us to place data into a fixed-size array and still find it later in constant time.\nGo implementation:\n1 hash := (key % tableSize + tableSize) % tableSize // handle negative keys Output:\n1 2 3 4 Key 12 â†’ Slot 2 Key 99 â†’ Slot 4 Key -7 â†’ Slot 3 Key 123456 â†’ Slot 1 Python implementation:\n1 hash = (key % table_size + table_size) % table_size # handle negative keys 1.1 ğŸ› ï¸ Why Hashing Matters\nEfficiency: Lookup/insert/delete in O(1) on average.\nFixed memory: No need for huge arrays, even if keys are massive.\nDeterminism: Same key â†’ always the same slot.\nğŸ‘‰ No matter how large or negative the key is, the result always lands in [0,4] because the table size is 5.\n1.2 âš ï¸ The Collision Problem\nSince the number of possible keys is much larger than the number of slots, different keys may map to the same slot. Example:\n- 12 % 5 = 2 - 22 % 5 = 2 Both keys â†’ slot 2.\nCommon strategies to handle this:\nChaining â€“ each slot stores a linked list or slice of elements.\nOpen Addressing â€“ if a slot is taken, probe for the next free one (linear probing, quadratic probing, double hashing).\nExample:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \"fmt\" func main() { tableSize := 5 table := make([][]int, tableSize) // slice of buckets (chaining) keys := []int{12, 22, 99, -7} for _, key := range keys { idx := (key % tableSize + tableSize) % tableSize table[idx] = append(table[idx], key) // put key into bucket } // ğŸ” Lookup keyToFind := 22 idx := (keyToFind % tableSize + tableSize) % tableSize fmt.Println(\"Looking for key:\", keyToFind, \"in bucket:\", idx) fmt.Println(\"Bucket contents:\", table[idx]) } Output:\n1 2 Looking for key: 22 in bucket: 2 Bucket contents: [12 22] 1.3 âœ… Key Takeaway\nHashing ensures that any key, no matter how large or small, is mapped into a fixed range of slots. This is what makes hash maps and sets in Go (and other languages) efficient and practical.\n1.4 ğŸš€ Hashing in Real Go Code (map)\nIn real-world Go code, you donâ€™t usually implement hashing yourself â€” you just use the built-in map.\n1 2 3 4 5 6 users := map[int]string{ 123: \"Alice\", 456: \"Bob\", } fmt.Println(users[123]) // \"Alice\" Goâ€™s map already:\n- Computes the hash of your keys. - Decides which bucket to put them in. - Handles collisions internally (buckets + open addressing). - Resizes automatically when needed. ğŸ‘‰ Writing your own hash function is great for learning DSA, but in production Go code you almost always use map.\nCircular Buffers\nIt is used to wrap indices around when they exceed the buffer size.\nGo implementation:\n1 nextIndex := (currentIndex + 1) % bufferSize currentIndex â†’ where you are now.\n+1 â†’ move forward.\n% bufferSize â†’ wraps back to 0 when you reach the end.\nA circular buffer (or ring buffer) is a fixed-size data structure that treats memory as if it were connected end-to-end in a circle. When the index reaches the end of the buffer, it wraps back to the beginning.\nThis makes it very useful for:\nStreaming data (audio, video, logs).\nQueues with fixed memory (no growing slices).\nProducerâ€“consumer problems (bounded buffer).\nğŸ”„ Example Walkthrough\nSay bufferSize = 5, indices = 0â€“4.\nIf currentIndex = 3:\n1 nextIndex = (3 + 1) % 5 = 4 â†’ move to index 4.\nIf currentIndex = 4:\n1 nextIndex = (4 + 1) % 5 = 0 â†’ wrap around to index 0.\nâœ… The % operator ensures the index always stays inside [0 â€¦ bufferSize-1].\nğŸ› ï¸ Simple Go Example\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \"fmt\" func main() { bufferSize := 5 buffer := make([]int, bufferSize) for i := 0; i \u003c 12; i++ { idx := i % bufferSize buffer[idx] = i fmt.Printf(\"Write %2d â†’ slot %d | buffer: %v\\n\", i, idx, buffer) } } Output:\n1 2 3 4 5 6 7 8 Write 0 â†’ slot 0 | buffer: [0 0 0 0 0] Write 1 â†’ slot 1 | buffer: [0 1 0 0 0] Write 2 â†’ slot 2 | buffer: [0 1 2 0 0] Write 3 â†’ slot 3 | buffer: [0 1 2 3 0] Write 4 â†’ slot 4 | buffer: [0 1 2 3 4] Write 5 â†’ slot 0 | buffer: [5 1 2 3 4] Write 6 â†’ slot 1 | buffer: [5 6 2 3 4] ... ğŸ‘‰ Notice how after filling slots 0â€“4, writing continues at slot 0 again, overwriting old data.\nPython implementation:\n1 next_index = (current_index + 1) % buffer_size ğŸ“Œ Use Cases\nLog buffers â†’ keep last N entries.\nNetwork packets â†’ stream without resizing memory.\nReal-time systems â†’ bounded memory, no GC spikes.\nâœ… Key Takeaway: Circular buffers use modulus arithmetic to â€œwrap aroundâ€ indices. Theyâ€™re memory-efficient and perfect for streaming and queue-like scenarios where overwriting old data is acceptable.\nKey Insights Modulo is the perfect operator when dealing with:\nRepetition (time, days, rotations)\nBounded ranges (array indices, hash maps)\nDivisibility checks\nThink of % as the wrap-around operator â€” it keeps numbers within limits.\nğŸ§  Tips for Learning DSA with Go Practice problems: Use platforms like LeetCode, HackerRank, or Exercism. Understand time complexity: Know Big-O analysis for every structure and algorithm. Build mini-projects: Implement your own LRU Cache, Trie, or Priority Queue. ğŸ¯ Final Thoughts Mastering DSA not only sharpens your coding skills but also prepares you for systems design, performance optimization, and real-world problem-solving.\nWith Goâ€™s clean syntax and powerful standard library, youâ€™re equipped to tackle DSA challenges efficiently and idiomatically.\nğŸš€ Follow me on norbix.dev for more insights on Go, Python, AI, system design, and engineering wisdom.\n","wordCount":"5789","inLanguage":"en","datePublished":"2025-07-24T18:10:25+02:00","dateModified":"2025-07-24T18:10:25+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://norbix.dev/posts/algorithms-and-data-structures/"},"publisher":{"@type":"Organization","name":"norbix.dev - The log of my journey through code \u0026 software systems architecture","logo":{"@type":"ImageObject","url":"https://norbix.dev/favicon.ico"}}}</script></head><body><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://norbix.dev/ accesskey=h title="norbix.dev - The log of my journey through code & software systems architecture (Alt + H)">norbix.dev - The log of my journey through code & software systems architecture</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://norbix.dev/ title=Home><span>Home</span></a></li><li><a href=https://norbix.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://norbix.dev/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://norbix.dev/about/ title=About><span>About</span></a></li><li><a href=https://norbix.dev/index.xml title="ğŸ“¡ RSS"><span>ğŸ“¡ RSS</span></a></li></ul></nav></header><main><main id=main><article class=post-single><header class=post-header><h1 class=post-title>DSA - Data Structures and Algorithms</h1><span title='2025-07-24 18:10:25 +0200 +0200'>July 24, 2025</span></header><div class=post-content><nav class=table-of-contents><nav id=TableOfContents><ul><li><a href=#-mastering-data-structures-and-algorithms-dsa-with-go-and--its-python-counterpart>ğŸ§  Mastering Data Structures and Algorithms (DSA) with <code>Go</code> and its <code>Python</code> Counterpart</a></li><li><a href=#-what-is-dsa>ğŸš€ What is DSA?</a></li><li><a href=#-essential-data-structures-in-go-and-its-python-counterpart>ğŸ“¦ Essential Data Structures in <code>Go</code> and its <code>Python</code> Counterpart</a></li><li><a href=#-must-know-algorithms-in-go>ğŸ§© Must-Know Algorithms in <code>Go</code></a></li><li><a href=#-sort-algorithms>ğŸ”ƒ Sort Algorithms</a></li><li><a href=#-sorting-algorithms---cheat-sheet>ğŸ“‘ Sorting Algorithms - Cheat Sheet</a></li><li><a href=#-search-algorithms>ğŸ” Search Algorithms</a></li><li><a href=#-search-algorithms--cheat-sheet>ğŸ” Search Algorithms â€“ Cheat Sheet</a></li><li><a href=#-tree-traversal-algorithms>ğŸŒ³ Tree Traversal Algorithms</a></li><li><a href=#-tree-traversal-algorithms--cheat-sheet>ğŸŒ³ Tree Traversal Algorithms â€“ Cheat Sheet</a></li><li><a href=#-the-modulo-operator->â— The Modulo Operator (%)</a><ul><li><a href=#what-is-modulo>What Is Modulo?</a></li><li><a href=#when-do-we-use-modulo>When Do We Use Modulo?</a></li><li><a href=#key-insights>Key Insights</a></li></ul></li><li><a href=#-tips-for-learning-dsa-with-go>ğŸ§  Tips for Learning DSA with Go</a></li><li><a href=#-final-thoughts>ğŸ¯ Final Thoughts</a></li></ul></nav></nav><p><img loading=lazy src=banner.jpg alt=banner></p><hr><h2 id=-mastering-data-structures-and-algorithms-dsa-with-go-and--its-python-counterpart>ğŸ§  Mastering Data Structures and Algorithms (DSA) with <code>Go</code> and its <code>Python</code> Counterpart</h2><p>Whether you&rsquo;re preparing for technical interviews, optimizing backend systems, or simply sharpening your problem-solving chops, Data Structures and Algorithms (<code>DSA</code>) are foundational to your success as a developer.</p><p>In this article, Iâ€™ll walk you through core DSA concepts using <code>Golang</code> and <code>Python</code>, a language praised for its simplicity, performance, and concurrency model. You&rsquo;ll see how Go makes understanding DSA both intuitive and powerful.</p><hr><h2 id=-what-is-dsa>ğŸš€ What is DSA?</h2><p>Data Structures organize and store data efficiently, while Algorithms define step-by-step instructions to solve problems or manipulate data.</p><p>Together, DSA provides the backbone for high-performance applications.</p><hr><h2 id=-essential-data-structures-in-go-and-its-python-counterpart>ğŸ“¦ Essential Data Structures in <code>Go</code> and its <code>Python</code> Counterpart</h2><ol><li><p>Arrays & Slices</p><p>Go implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>arr</span> <span class=o>:=</span> <span class=p>[</span><span class=mi>5</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>}</span> <span class=c1>// Fixed-size array</span>
</span></span><span class=line><span class=cl><span class=nx>slice</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>      <span class=c1>// Dynamic size</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>slice</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>slice</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>slice</span><span class=p>)</span> <span class=c1>// [1 2 3 4]</span>
</span></span></code></pre></td></tr></table></div></div><p>Python implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl> <span class=n>arr</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>]</span>  <span class=c1># Dynamic array (list in Python)</span>
</span></span><span class=line><span class=cl> <span class=n>arr</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=mi>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nb>print</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>  <span class=c1># [1, 2, 3, 4, 5, 6]</span>
</span></span></code></pre></td></tr></table></div></div><p>Slices are the idiomatic way to work with collections in Go. They offer flexibility while leveraging arrays under the hood.</p></li><li><p>Linked List</p><p>Go doesnâ€™t have a built-in linked list, but the container/list package provides one.</p><p>Go implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl><span class=s>&#34;container/list&#34;</span>
</span></span><span class=line><span class=cl><span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nx>l</span> <span class=o>:=</span> <span class=nx>list</span><span class=p>.</span><span class=nf>New</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>l</span><span class=p>.</span><span class=nf>PushBack</span><span class=p>(</span><span class=s>&#34;Go&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>l</span><span class=p>.</span><span class=nf>PushBack</span><span class=p>(</span><span class=s>&#34;DSA&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>e</span> <span class=o>:=</span> <span class=nx>l</span><span class=p>.</span><span class=nf>Front</span><span class=p>();</span> <span class=nx>e</span> <span class=o>!=</span> <span class=kc>nil</span><span class=p>;</span> <span class=nx>e</span> <span class=p>=</span> <span class=nx>e</span><span class=p>.</span><span class=nf>Next</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>e</span><span class=p>.</span><span class=nx>Value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Python implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl> <span class=k>class</span> <span class=nc>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>     <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>         <span class=bp>self</span><span class=o>.</span><span class=n>data</span> <span class=o>=</span> <span class=n>data</span>
</span></span><span class=line><span class=cl>         <span class=bp>self</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=k>class</span> <span class=nc>LinkedList</span><span class=p>:</span>
</span></span><span class=line><span class=cl>     <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>         <span class=bp>self</span><span class=o>.</span><span class=n>head</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>     <span class=k>def</span> <span class=nf>append</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>         <span class=n>new_node</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>head</span><span class=p>:</span>
</span></span><span class=line><span class=cl>             <span class=bp>self</span><span class=o>.</span><span class=n>head</span> <span class=o>=</span> <span class=n>new_node</span>
</span></span><span class=line><span class=cl>             <span class=k>return</span>
</span></span><span class=line><span class=cl>         <span class=n>last</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>head</span>
</span></span><span class=line><span class=cl>         <span class=k>while</span> <span class=n>last</span><span class=o>.</span><span class=n>next</span><span class=p>:</span>
</span></span><span class=line><span class=cl>             <span class=n>last</span> <span class=o>=</span> <span class=n>last</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>         <span class=n>last</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>new_node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>     <span class=k>def</span> <span class=nf>print_list</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>         <span class=n>current</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>head</span>
</span></span><span class=line><span class=cl>         <span class=k>while</span> <span class=n>current</span><span class=p>:</span>
</span></span><span class=line><span class=cl>             <span class=nb>print</span><span class=p>(</span><span class=n>current</span><span class=o>.</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>             <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=n>ll</span> <span class=o>=</span> <span class=n>LinkedList</span><span class=p>()</span>
</span></span><span class=line><span class=cl> <span class=n>ll</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s2>&#34;Python&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=n>ll</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s2>&#34;DSA&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=n>ll</span><span class=o>.</span><span class=n>print_list</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Stack (<code>LIFO</code>)</p><p>A stack can be easily implemented using slices.</p><p>Go implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Stack</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>Stack</span><span class=p>)</span> <span class=nf>Push</span><span class=p>(</span><span class=nx>v</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>s</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=o>*</span><span class=nx>s</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>Stack</span><span class=p>)</span> <span class=nf>Pop</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=o>*</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>val</span> <span class=o>:=</span> <span class=p>(</span><span class=o>*</span><span class=nx>s</span><span class=p>)[</span><span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>s</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>s</span><span class=p>)[:</span><span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>val</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Python implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl> <span class=k>class</span> <span class=nc>Stack</span><span class=p>:</span>
</span></span><span class=line><span class=cl>       <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>             <span class=bp>self</span><span class=o>.</span><span class=n>stack</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>       <span class=k>def</span> <span class=nf>push</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>item</span><span class=p>):</span>
</span></span><span class=line><span class=cl>             <span class=bp>self</span><span class=o>.</span><span class=n>stack</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>item</span><span class=p>)</span>  <span class=c1># append to the end (like Go&#39;s append)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>       <span class=k>def</span> <span class=nf>pop</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>             <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>stack</span><span class=p>:</span>
</span></span><span class=line><span class=cl>              <span class=k>raise</span> <span class=ne>IndexError</span><span class=p>(</span><span class=s2>&#34;pop from empty stack&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>             <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>stack</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>  <span class=c1># pop from the end (like Go&#39;s slice)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Queue (<code>FIFO</code>)</p><p>Queues can also be implemented using slices.</p><p>Go implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Queue</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>q</span> <span class=o>*</span><span class=nx>Queue</span><span class=p>)</span> <span class=nf>Enqueue</span><span class=p>(</span><span class=nx>v</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>q</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=o>*</span><span class=nx>q</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>q</span> <span class=o>*</span><span class=nx>Queue</span><span class=p>)</span> <span class=nf>Dequeue</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>val</span> <span class=o>:=</span> <span class=p>(</span><span class=o>*</span><span class=nx>q</span><span class=p>)[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>q</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>q</span><span class=p>)[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>val</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Python implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>     <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>         <span class=bp>self</span><span class=o>.</span><span class=n>queue</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>     <span class=k>def</span> <span class=nf>enqueue</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>item</span><span class=p>):</span>
</span></span><span class=line><span class=cl>         <span class=c1># append to the end (like Go&#39;s append)</span>
</span></span><span class=line><span class=cl>         <span class=bp>self</span><span class=o>.</span><span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>     <span class=k>def</span> <span class=nf>dequeue</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>         <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>             <span class=k>raise</span> <span class=ne>IndexError</span><span class=p>(</span><span class=s2>&#34;dequeue from empty queue&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=c1># take from the front (like q[0] in Go)</span>
</span></span><span class=line><span class=cl>         <span class=n>val</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>queue</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>         <span class=bp>self</span><span class=o>.</span><span class=n>queue</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>queue</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>  <span class=c1># shrink list (like Go slice)</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=n>val</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Hash Map (<code>Go's map</code>)</p><p>Go implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>m</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;apple&#34;</span><span class=p>:</span>  <span class=mi>5</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;banana&#34;</span><span class=p>:</span> <span class=mi>3</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>m</span><span class=p>[</span><span class=s>&#34;apple&#34;</span><span class=p>])</span> <span class=c1>// 5</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>Hint:</strong>
Goâ€™s built-in map is a powerful hash table implementation for key-value pairs.</p><p>ğŸ”‘ What types can be keys in a Go map?</p><ul><li><p>A map key must be comparable (Go requires == and != operators to be defined).</p></li><li><p>âœ… Allowed key types:</p><ul><li><p>Booleans (bool)</p></li><li><p>Numbers (int, float64, etc.)</p></li><li><p>Strings</p></li><li><p>Pointers</p></li><li><p>Channels</p></li><li><p>Interfaces (if the underlying type is comparable)</p></li><li><p>Structs (if all their fields are comparable)</p></li><li><p>Arrays (fixed-size, if elements are comparable)</p></li></ul></li><li><p>âŒ Not allowed as keys:</p><ul><li><p>Slices</p></li><li><p>Maps</p></li><li><p>Functions</p></li></ul></li></ul><p>These types are not comparable in Go, so they cannot be used as map keys.</p><p>Example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Valid keys</span>
</span></span><span class=line><span class=cl><span class=nx>m1</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span><span class=mi>1</span><span class=p>:</span> <span class=s>&#34;one&#34;</span><span class=p>,</span> <span class=mi>2</span><span class=p>:</span> <span class=s>&#34;two&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>m2</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>bool</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span><span class=kc>true</span><span class=p>:</span> <span class=s>&#34;yes&#34;</span><span class=p>,</span> <span class=kc>false</span><span class=p>:</span> <span class=s>&#34;no&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>m3</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[[</span><span class=mi>2</span><span class=p>]</span><span class=kt>int</span><span class=p>]</span><span class=kt>string</span><span class=p>{{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>}:</span> <span class=s>&#34;coords&#34;</span><span class=p>}</span> <span class=c1>// array key</span>
</span></span><span class=line><span class=cl><span class=nx>m4</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kd>struct</span><span class=p>{</span><span class=nx>ID</span> <span class=kt>int</span><span class=p>}]</span><span class=kt>string</span><span class=p>{{</span><span class=nx>ID</span><span class=p>:</span> <span class=mi>1</span><span class=p>}:</span> <span class=s>&#34;first&#34;</span><span class=p>}</span> <span class=c1>// struct key</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>m1</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span> <span class=c1>// &#34;one&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>m2</span><span class=p>[</span><span class=kc>false</span><span class=p>])</span> <span class=c1>// &#34;no&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>m3</span><span class=p>[[</span><span class=mi>2</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>}])</span> <span class=c1>// &#34;coords&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>If you try with a slice:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>m</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[[]</span><span class=kt>int</span><span class=p>]</span><span class=kt>string</span><span class=p>{}</span>
</span></span></code></pre></td></tr></table></div></div><p>ğŸ‘‰ Youâ€™ll get a compile-time error:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>invalid</span> <span class=kd>map</span> <span class=nx>key</span> <span class=kd>type</span> <span class=p>[]</span><span class=kt>int</span>
</span></span></code></pre></td></tr></table></div></div><p>âœ… Summary:</p><ul><li><p>Go maps work with keys of any type that is comparable.</p></li><li><p>Commonly: string, int, bool, structs, and arrays.</p></li><li><p>Not allowed: slices, maps, functions.</p></li></ul><p>Python implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl> <span class=n>m</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=s2>&#34;apple&#34;</span><span class=p>:</span> <span class=mi>5</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=s2>&#34;banana&#34;</span><span class=p>:</span> <span class=mi>3</span><span class=p>,</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=nb>print</span><span class=p>(</span><span class=n>m</span><span class=p>[</span><span class=s2>&#34;apple&#34;</span><span class=p>])</span>  <span class=c1># 5</span>
</span></span></code></pre></td></tr></table></div></div><p>ğŸ”‘ What types can be keys in a Python dict?</p><ul><li><p>A key must be hashable â†’ meaning it has a valid <strong>hash</strong>() and does not change during its lifetime.</p></li><li><p>âœ… Allowed key types:</p><ul><li><p>Immutable built-ins: str, int, float, bool, bytes</p></li><li><p>Tuples (if all elements are hashable)</p></li><li><p><strong>frozenset</strong> (immutable version of set`)</p></li><li><p>User-defined classes (if they implement <strong>hash</strong> and <strong>eq</strong>)</p></li></ul></li><li><p>âŒ Not allowed as keys:</p><ul><li><p>Mutable types like list, dict, and set</p></li><li><p>These can change after being used as a key, which would break hash table invariants.</p></li></ul></li></ul><p>Example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Valid keys</span>
</span></span><span class=line><span class=cl><span class=n>m1</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>:</span> <span class=s2>&#34;one&#34;</span><span class=p>,</span> <span class=mi>2</span><span class=p>:</span> <span class=s2>&#34;two&#34;</span><span class=p>}</span>                 <span class=c1># int keys</span>
</span></span><span class=line><span class=cl><span class=n>m2</span> <span class=o>=</span> <span class=p>{</span><span class=kc>True</span><span class=p>:</span> <span class=s2>&#34;yes&#34;</span><span class=p>,</span> <span class=kc>False</span><span class=p>:</span> <span class=s2>&#34;no&#34;</span><span class=p>}</span>           <span class=c1># bool keys</span>
</span></span><span class=line><span class=cl><span class=n>m3</span> <span class=o>=</span> <span class=p>{(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>):</span> <span class=s2>&#34;coords&#34;</span><span class=p>}</span>                   <span class=c1># tuple key</span>
</span></span><span class=line><span class=cl><span class=n>m4</span> <span class=o>=</span> <span class=p>{</span><span class=nb>frozenset</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>]):</span> <span class=s2>&#34;frozen set&#34;</span><span class=p>}</span>    <span class=c1># frozenset key</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>m1</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>         <span class=c1># &#34;one&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>m2</span><span class=p>[</span><span class=kc>False</span><span class=p>])</span>     <span class=c1># &#34;no&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>m3</span><span class=p>[(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)])</span>    <span class=c1># &#34;coords&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>If you try with a list:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>m</span> <span class=o>=</span> <span class=p>{</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>]:</span> <span class=s2>&#34;coords&#34;</span> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>ğŸ‘‰ Youâ€™ll get a runtime error:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ne>TypeError</span><span class=p>:</span> <span class=n>unhashable</span> <span class=nb>type</span><span class=p>:</span> <span class=s1>&#39;list&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p>âœ… Summary:</p><ul><li><p>Python dicts require keys to be hashable.</p></li><li><p>Commonly: strings, numbers, booleans, tuples of immutables, frozensets.</p></li><li><p>Not allowed: lists, dicts, sets (mutable types).</p></li></ul></li></ol><hr><h2 id=-must-know-algorithms-in-go>ğŸ§© Must-Know Algorithms in <code>Go</code></h2><ol><li><p>Binary Search</p><p>Efficient O(log n) search on sorted arrays.</p><p>Go implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>binarySearch</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>target</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>low</span><span class=p>,</span> <span class=nx>high</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>low</span> <span class=o>&lt;=</span> <span class=nx>high</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>mid</span> <span class=o>:=</span> <span class=p>(</span><span class=nx>low</span> <span class=o>+</span> <span class=nx>high</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>mid</span><span class=p>]</span> <span class=o>==</span> <span class=nx>target</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>mid</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>mid</span><span class=p>]</span> <span class=p>&lt;</span> <span class=nx>target</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>low</span> <span class=p>=</span> <span class=nx>mid</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>high</span> <span class=p>=</span> <span class=nx>mid</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Python implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl> <span class=k>def</span> <span class=nf>binary_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>      <span class=n>low</span><span class=p>,</span> <span class=n>high</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>      <span class=k>while</span> <span class=n>low</span> <span class=o>&lt;=</span> <span class=n>high</span><span class=p>:</span>
</span></span><span class=line><span class=cl>           <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>low</span> <span class=o>+</span> <span class=n>high</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>           <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>mid</span>
</span></span><span class=line><span class=cl>           <span class=k>elif</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>low</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>           <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>high</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Sorting (<code>Bubble Sort</code> Example)</p><p>Video explanation: <a href="https://www.youtube.com/watch?v=yIQuKSwPlro">Bubble Sort Algorithm</a></p><p>Go implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>bubbleSort</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=o>-</span><span class=nx>i</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>&gt;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=o>+</span><span class=mi>1</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Python implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl> <span class=k>def</span> <span class=nf>bubble_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>     <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>         <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>n</span><span class=o>-</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>             <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                 <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>For real projects, use Goâ€™s built-in sorting:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>sort</span><span class=p>.</span><span class=nf>Ints</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Recursion: Factorial</p><p>Factorial of <code>n</code> (n!) is the product of all positive integers up to <code>n</code>.</p><p>Go implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>factorial</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>n</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>n</span> <span class=o>*</span> <span class=nf>factorial</span><span class=p>(</span><span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Python implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl> <span class=k>def</span> <span class=nf>factorial</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>           <span class=k>return</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>n</span> <span class=o>*</span> <span class=n>factorial</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Example: The factorial of 4 is <code>4 * 3 * 2 * 1 = 24</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-matlab data-lang=matlab><span class=line><span class=cl><span class=nb>factorial</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>=</span> <span class=mi>4</span> <span class=o>*</span> <span class=nb>factorial</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>=</span> <span class=mi>4</span> <span class=o>*</span> <span class=p>(</span><span class=mi>3</span> <span class=o>*</span> <span class=nb>factorial</span><span class=p>(</span><span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>=</span> <span class=mi>4</span> <span class=o>*</span> <span class=p>(</span><span class=mi>3</span> <span class=o>*</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nb>factorial</span><span class=p>(</span><span class=mi>1</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=p>=</span> <span class=mi>4</span> <span class=o>*</span> <span class=p>(</span><span class=mi>3</span> <span class=o>*</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=nb>factorial</span><span class=p>(</span><span class=mi>0</span><span class=p>))))</span>
</span></span><span class=line><span class=cl><span class=p>=</span> <span class=mi>4</span> <span class=o>*</span> <span class=p>(</span><span class=mi>3</span> <span class=o>*</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=mi>1</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=p>=</span> <span class=mi>24</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Fibonacci Sequence</p><p>Fibonacci numbers are the sum of the two preceding ones, starting from 0 and 1.</p><p>Go implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>fibonacci</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>n</span> <span class=o>&lt;=</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>fibonacci</span><span class=p>(</span><span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=nf>fibonacci</span><span class=p>(</span><span class=nx>n</span><span class=o>-</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Python implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl> <span class=k>def</span> <span class=nf>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>           <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Example: The sequence starts as: 0, 1, 1, 2, 3, 5, 8, 13, &mldr;</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-matlab data-lang=matlab><span class=line><span class=cl><span class=n>fibonacci</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>=</span> <span class=n>fibonacci</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>=</span> <span class=p>(</span><span class=n>fibonacci</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci</span><span class=p>(</span><span class=mi>2</span><span class=p>))</span> <span class=o>+</span> <span class=p>(</span><span class=n>fibonacci</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci</span><span class=p>(</span><span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>=</span> <span class=p>((</span><span class=n>fibonacci</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci</span><span class=p>(</span><span class=mi>1</span><span class=p>))</span> <span class=o>+</span> <span class=p>(</span><span class=n>fibonacci</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci</span><span class=p>(</span><span class=mi>0</span><span class=p>)))</span> <span class=o>+</span> <span class=p>(</span><span class=n>fibonacci</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>=</span> <span class=p>(((</span><span class=n>fibonacci</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=mi>1</span> <span class=o>+</span> <span class=mi>0</span><span class=p>))</span> <span class=o>+</span> <span class=p>(</span><span class=mi>1</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>=</span> <span class=p>(((</span><span class=mi>1</span> <span class=o>+</span> <span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=p>=</span> <span class=mi>5</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Prime Check</p><p>Prime numbers are greater than 1 and only divisible by 1 and themselves.</p><p><code>Go</code> implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>isPrime</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>n</span> <span class=o>&lt;=</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>2</span><span class=p>;</span> <span class=nx>i</span><span class=o>*</span><span class=nx>i</span> <span class=o>&lt;=</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>n</span><span class=o>%</span><span class=nx>i</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>Python</code> implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl> <span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>sqrt</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=k>def</span> <span class=nf>is_prime</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>           <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=n>sqrt</span><span class=p>(</span><span class=n>n</span><span class=p>))</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>           <span class=k>if</span> <span class=n>n</span> <span class=o>%</span> <span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>             <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>True</span>
</span></span></code></pre></td></tr></table></div></div><p>Example: The number 11 is prime, while 12 is not.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-matlab data-lang=matlab><span class=line><span class=cl><span class=n>isPrime</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>=</span> <span class=n>true</span> <span class=p>(</span><span class=mi>11</span> <span class=n>is</span> <span class=n>only</span> <span class=n>divisible</span> <span class=n>by</span> <span class=mi>1</span> <span class=n>and</span> <span class=mi>11</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>isPrime</span><span class=p>(</span><span class=mi>12</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>=</span> <span class=n>false</span> <span class=p>(</span><span class=mi>12</span> <span class=n>is</span> <span class=n>divisible</span> <span class=n>by</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=n>and</span> <span class=mi>12</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>FizzBuzz :)</p><p>A classic programming challenge.</p><p><code>Go</code> implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>fizzBuzz</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>i</span><span class=o>%</span><span class=mi>3</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>i</span><span class=o>%</span><span class=mi>5</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;FizzBuzz&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>i</span><span class=o>%</span><span class=mi>3</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Fizz&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>i</span><span class=o>%</span><span class=mi>5</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Buzz&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>Python</code> implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fizz_buzz</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>i</span> <span class=o>%</span> <span class=mi>3</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>i</span> <span class=o>%</span> <span class=mi>5</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;FizzBuzz&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>i</span> <span class=o>%</span> <span class=mi>3</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Fizz&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>i</span> <span class=o>%</span> <span class=mi>5</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Buzz&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Example: For <code>n = 15</code> print the numbers from 1 to 15. For multiples of 3, print &ldquo;Fizz&rdquo; instead of the number. For multiples of 5, print &ldquo;Buzz&rdquo;. For numbers which are multiples of both 3 and 5, print &ldquo;FizzBuzz&rdquo;.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-matlab data-lang=matlab><span class=line><span class=cl> <span class=mi>1</span>
</span></span><span class=line><span class=cl> <span class=mi>2</span>
</span></span><span class=line><span class=cl> <span class=n>Fizz</span>
</span></span><span class=line><span class=cl> <span class=mi>4</span>
</span></span><span class=line><span class=cl> <span class=n>Buzz</span>
</span></span><span class=line><span class=cl> <span class=n>Fizz</span>
</span></span><span class=line><span class=cl> <span class=mi>7</span>
</span></span><span class=line><span class=cl> <span class=mi>8</span>
</span></span><span class=line><span class=cl> <span class=n>Fizz</span>
</span></span><span class=line><span class=cl> <span class=n>Buzz</span>
</span></span><span class=line><span class=cl> <span class=mi>11</span>
</span></span><span class=line><span class=cl> <span class=n>Fizz</span>
</span></span><span class=line><span class=cl> <span class=mi>13</span>
</span></span><span class=line><span class=cl> <span class=mi>14</span>
</span></span><span class=line><span class=cl> <span class=n>FizzBuzz</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Graph and Trees</p><p>For binary trees, you define custom structures.</p><p>Go implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Node</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nx>Value</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nx>Left</span>  <span class=o>*</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl><span class=nx>Right</span> <span class=o>*</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Python implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl> <span class=k>class</span> <span class=nc>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>       <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>             <span class=bp>self</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>             <span class=bp>self</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>             <span class=bp>self</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=kc>None</span>
</span></span></code></pre></td></tr></table></div></div><p>Depth-first traversal:</p><p>Go implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>dfs</span><span class=p>(</span><span class=nx>n</span> <span class=o>*</span><span class=nx>Node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>n</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>n</span><span class=p>.</span><span class=nx>Value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>dfs</span><span class=p>(</span><span class=nx>n</span><span class=p>.</span><span class=nx>Left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>dfs</span><span class=p>(</span><span class=nx>n</span><span class=p>.</span><span class=nx>Right</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Python implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl> <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>     <span class=bp>self</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>     <span class=bp>self</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>     <span class=bp>self</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>     <span class=k>if</span> <span class=n>node</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>value</span><span class=p>)</span>      <span class=c1># Preorder: visit root</span>
</span></span><span class=line><span class=cl>    <span class=n>dfs</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>         <span class=c1># Traverse left subtree</span>
</span></span><span class=line><span class=cl>    <span class=n>dfs</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>        <span class=c1># Traverse right subtree</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><hr><h2 id=-sort-algorithms>ğŸ”ƒ Sort Algorithms</h2><p>Sorting is a fundamental concept in computer science used in everything from searching to data normalization and ranking systems. Below are essential sorting algorithms every developer should know, implemented in Go.</p><ol><li><p>Merge Sort (ğŸ§¬ Divide and Conquer â€“ O(n log n))</p><p>Merge Sort recursively splits arrays into halves and merges them in a sorted manner.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>mergeSort</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>arr</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>mid</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=nx>left</span> <span class=o>:=</span> <span class=nf>mergeSort</span><span class=p>(</span><span class=nx>arr</span><span class=p>[:</span><span class=nx>mid</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=nx>right</span> <span class=o>:=</span> <span class=nf>mergeSort</span><span class=p>(</span><span class=nx>arr</span><span class=p>[</span><span class=nx>mid</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>merge</span><span class=p>(</span><span class=nx>left</span><span class=p>,</span> <span class=nx>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>merge</span><span class=p>(</span><span class=nx>left</span><span class=p>,</span> <span class=nx>right</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>result</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>left</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>left</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>&lt;</span> <span class=nx>right</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>left</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=nx>i</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>right</span><span class=p>[</span><span class=nx>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=nx>j</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nb>append</span><span class=p>(</span><span class=nx>left</span><span class=p>[</span><span class=nx>i</span><span class=p>:],</span> <span class=nx>right</span><span class=p>[</span><span class=nx>j</span><span class=p>:]</span><span class=o>...</span><span class=p>)</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Quick Sort (âš¡ Partition-based â€“ Average: O(n log n), Worst: O(nÂ²))</p><p>Quick Sort selects a pivot and partitions the array into smaller and larger elements.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>quickSort</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span> <span class=p>&lt;</span> <span class=mi>2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>left</span><span class=p>,</span> <span class=nx>right</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nx>pivot</span> <span class=o>:=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Int</span><span class=p>()</span> <span class=o>%</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>arr</span><span class=p>[</span><span class=nx>pivot</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>right</span><span class=p>]</span> <span class=p>=</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>right</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>pivot</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>arr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>&lt;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>right</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>left</span><span class=p>]</span> <span class=p>=</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>left</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=nx>left</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>arr</span><span class=p>[</span><span class=nx>left</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>right</span><span class=p>]</span> <span class=p>=</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>right</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>left</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nf>quickSort</span><span class=p>(</span><span class=nx>arr</span><span class=p>[:</span><span class=nx>left</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=nf>quickSort</span><span class=p>(</span><span class=nx>arr</span><span class=p>[</span><span class=nx>left</span><span class=o>+</span><span class=mi>1</span><span class=p>:])</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Bubble Sort (ğŸ«§ Simple but Inefficient â€“ O(nÂ²))</p><p>Repeatedly swaps adjacent elements if they are in the wrong order.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>bubbleSort</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=o>-</span><span class=nx>i</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>&gt;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=o>+</span><span class=mi>1</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Insertion Sort (ğŸ§© Efficient for Small Datasets â€“ O(nÂ²))</p><p>Builds the sorted array one item at a time.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>insertionSort</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>key</span> <span class=o>:=</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nx>j</span> <span class=o>:=</span> <span class=nx>i</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>j</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>&gt;</span> <span class=nx>key</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=nx>j</span><span class=o>--</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=nx>key</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Selection Sort (ğŸ“Œ Selects Minimum â€“ O(nÂ²))</p><p>Repeatedly finds the minimum element and places it at the beginning.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>selectionSort</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>minIdx</span> <span class=o>:=</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>&lt;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>minIdx</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>minIdx</span> <span class=p>=</span> <span class=nx>j</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>minIdx</span><span class=p>]</span> <span class=p>=</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>minIdx</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Heap Sort (ğŸ—ï¸ Priority Queue-based â€“ O(n log n))</p><p>Uses a binary heap structure to repeatedly extract the max element.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>heapSort</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Build max heap</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>n</span><span class=o>/</span><span class=mi>2</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=o>--</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>heapify</span><span class=p>(</span><span class=nx>arr</span><span class=p>,</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&gt;</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=o>--</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nf>heapify</span><span class=p>(</span><span class=nx>arr</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>heapify</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>largest</span> <span class=o>:=</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>    <span class=nx>left</span> <span class=o>:=</span> <span class=mi>2</span><span class=o>*</span><span class=nx>i</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nx>right</span> <span class=o>:=</span> <span class=mi>2</span><span class=o>*</span><span class=nx>i</span> <span class=o>+</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>left</span> <span class=p>&lt;</span> <span class=nx>n</span> <span class=o>&amp;&amp;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>left</span><span class=p>]</span> <span class=p>&gt;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>largest</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>largest</span> <span class=p>=</span> <span class=nx>left</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>right</span> <span class=p>&lt;</span> <span class=nx>n</span> <span class=o>&amp;&amp;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>right</span><span class=p>]</span> <span class=p>&gt;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>largest</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>largest</span> <span class=p>=</span> <span class=nx>right</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>largest</span> <span class=o>!=</span> <span class=nx>i</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>largest</span><span class=p>]</span> <span class=p>=</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>largest</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nf>heapify</span><span class=p>(</span><span class=nx>arr</span><span class=p>,</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>largest</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><p>Each of these sorting algorithms serves different use cases. While Goâ€™s sort package provides optimized versions, understanding how these work internally is critical for building performance-conscious software.</p><hr><h2 id=-sorting-algorithms---cheat-sheet>ğŸ“‘ Sorting Algorithms - Cheat Sheet</h2><table><thead><tr><th>Algorithm</th><th>Best Time</th><th>Avg Time</th><th>Worst Time</th><th>Space</th><th>Stable</th><th>In-Place</th><th>Notes</th></tr></thead><tbody><tr><td><strong>Merge Sort</strong></td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n)</td><td>âœ… Yes</td><td>âŒ No</td><td>Divide and conquer, great for linked lists</td></tr><tr><td><strong>Quick Sort</strong></td><td>O(n log n)</td><td>O(n log n)</td><td>O(nÂ²)</td><td>O(log n)</td><td>âŒ No</td><td>âœ… Yes</td><td>Very fast in practice, not stable</td></tr><tr><td><strong>Bubble Sort</strong></td><td>O(n)</td><td>O(nÂ²)</td><td>O(nÂ²)</td><td>O(1)</td><td>âœ… Yes</td><td>âœ… Yes</td><td>Educational use only, very slow</td></tr><tr><td><strong>Insertion Sort</strong></td><td>O(n)</td><td>O(nÂ²)</td><td>O(nÂ²)</td><td>O(1)</td><td>âœ… Yes</td><td>âœ… Yes</td><td>Efficient for small or nearly sorted data</td></tr><tr><td><strong>Selection Sort</strong></td><td>O(nÂ²)</td><td>O(nÂ²)</td><td>O(nÂ²)</td><td>O(1)</td><td>âŒ No</td><td>âœ… Yes</td><td>Always O(nÂ²), rarely used</td></tr><tr><td><strong>Heap Sort</strong></td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(1)</td><td>âŒ No</td><td>âœ… Yes</td><td>Good for priority queues</td></tr></tbody></table><blockquote><p>âœ… <strong>Stable</strong>: Maintains the relative order of equal elements<br>âœ… <strong>In-Place</strong>: Uses constant extra space (excluding recursion stack)</p></blockquote><hr><h2 id=-search-algorithms>ğŸ” Search Algorithms</h2><p>Search algorithms are foundational tools in computer science used to retrieve information stored in data structures like arrays, trees, or graphs. Whether you&rsquo;re working with sorted arrays, exploring hierarchical structures, or traversing complex graphs, the right search algorithm can dramatically improve efficiency and performance.</p><p>Letâ€™s dive into three essential search algorithms and their Go implementations:</p><ol><li><p>ğŸ§­ Binary Search</p><p>Use Case: Efficiently search for a value in a sorted array.
Time Complexity: O(log n)
Space Complexity: O(1) (iterative), O(log n) (recursive)</p><p>Concept:
Binary Search divides the array into halves, eliminating one half at each step, depending on whether the target is greater or smaller than the midpoint.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BinarySearch</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>target</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>left</span><span class=p>,</span> <span class=nx>right</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>left</span> <span class=o>&lt;=</span> <span class=nx>right</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>mid</span> <span class=o>:=</span> <span class=nx>left</span> <span class=o>+</span> <span class=p>(</span><span class=nx>right</span><span class=o>-</span><span class=nx>left</span><span class=p>)</span><span class=o>/</span><span class=mi>2</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>mid</span><span class=p>]</span> <span class=o>==</span> <span class=nx>target</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>mid</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>mid</span><span class=p>]</span> <span class=p>&lt;</span> <span class=nx>target</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>left</span> <span class=p>=</span> <span class=nx>mid</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>right</span> <span class=p>=</span> <span class=nx>mid</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span> <span class=c1>// not found</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>ğŸŒ Breadth-First Search (BFS)</p></li></ol><p>Use Case: Traverse or search tree/graph level by level. Ideal for finding the shortest path in unweighted graphs.
Time Complexity: O(V + E) (vertices + edges)
Space Complexity: O(V)</p><p>Concept:
BFS uses a queue to explore all neighboring nodes before going deeper. Itâ€™s a level-order traversal for trees or graphs.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BFS</span><span class=p>(</span><span class=nx>graph</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>][]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>start</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>visited</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>queue</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=nx>start</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>result</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>queue</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>node</span> <span class=o>:=</span> <span class=nx>queue</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nx>queue</span> <span class=p>=</span> <span class=nx>queue</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>visited</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>visited</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>        <span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>neighbor</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>graph</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>!</span><span class=nx>visited</span><span class=p>[</span><span class=nx>neighbor</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>queue</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>queue</span><span class=p>,</span> <span class=nx>neighbor</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>result</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ol><li><p>ğŸ§± Depth-First Search (DFS)</p><p>Use Case: Explore all paths or check for connectivity in graphs/trees. Great for scenarios like maze-solving, backtracking, and topological sorting.
Time Complexity: O(V + E)
Space Complexity: O(V) (recursive stack or visited map)</p><p>Concept:
DFS explores as far as possible along each branch before backtracking. Implemented with recursion or a stack.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>DFS</span><span class=p>(</span><span class=nx>graph</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>][]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>start</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>visited</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>bool</span><span class=p>,</span> <span class=nx>result</span> <span class=o>*</span><span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>visited</span><span class=p>[</span><span class=nx>start</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>visited</span><span class=p>[</span><span class=nx>start</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=o>*</span><span class=nx>result</span><span class=p>,</span> <span class=nx>start</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>neighbor</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>graph</span><span class=p>[</span><span class=nx>start</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>!</span><span class=nx>visited</span><span class=p>[</span><span class=nx>neighbor</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>DFS</span><span class=p>(</span><span class=nx>graph</span><span class=p>,</span> <span class=nx>neighbor</span><span class=p>,</span> <span class=nx>visited</span><span class=p>,</span> <span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>To initiate <code>DFS</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>graph</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>][]</span><span class=kt>int</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=mi>1</span><span class=p>:</span> <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=mi>2</span><span class=p>:</span> <span class=p>{</span><span class=mi>4</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=mi>3</span><span class=p>:</span> <span class=p>{},</span>
</span></span><span class=line><span class=cl>    <span class=mi>4</span><span class=p>:</span> <span class=p>{},</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>visited</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>result</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=nf>DFS</span><span class=p>(</span><span class=nx>graph</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>visited</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>result</span><span class=p>)</span> <span class=c1>// Output: [1 2 4 3] (DFS order may vary)</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><hr><h2 id=-search-algorithms--cheat-sheet>ğŸ” Search Algorithms â€“ Cheat Sheet</h2><table><thead><tr><th>Algorithm</th><th>Use Case</th><th>Time Complexity</th><th>Space Complexity</th><th>Notes</th></tr></thead><tbody><tr><td><strong>Binary Search</strong></td><td>Search in sorted arrays</td><td>O(log n)</td><td>O(1) (iterative)<br>O(log n) (recursive)</td><td>Requires sorted input</td></tr><tr><td><strong>Breadth-First Search (BFS)</strong></td><td>Shortest path in unweighted graphs</td><td>O(V + E)</td><td>O(V)</td><td>Level-order traversal, uses a queue</td></tr><tr><td><strong>Depth-First Search (DFS)</strong></td><td>Exploring all paths, topological sort, cycle detection</td><td>O(V + E)</td><td>O(V)</td><td>Preorder traversal, uses recursion or stack</td></tr></tbody></table><hr><h2 id=-tree-traversal-algorithms>ğŸŒ³ Tree Traversal Algorithms</h2><p>Traversing a tree means visiting every node in a specific order. Whether you&rsquo;re parsing expressions, printing a binary tree, or converting structures, understanding traversal strategies is fundamental in computer science.</p><p>This guide covers the four most common tree traversal algorithms:</p><ul><li><p>Pre-Order Traversal</p></li><li><p>In-Order Traversal</p></li><li><p>Post-Order Traversal</p></li><li><p>Level-Order Traversal</p></li></ul><ol><li><p>ğŸ“ Tree Node Definition in Go</p><p>Before diving into each traversal, hereâ€™s the standard binary tree structure we&rsquo;ll use:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>TreeNode</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Val</span>   <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>Left</span>  <span class=o>*</span><span class=nx>TreeNode</span>
</span></span><span class=line><span class=cl>    <span class=nx>Right</span> <span class=o>*</span><span class=nx>TreeNode</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>ğŸ” Pre-Order Traversal (Root â†’ Left â†’ Right)</p><p>Use Case:
Useful for copying a tree or prefix expression evaluation.</p><p>Steps:</p><ol><li><p>Visit root</p></li><li><p>Traverse left subtree</p></li><li><p>Traverse right subtree</p></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>PreOrder</span><span class=p>(</span><span class=nx>node</span> <span class=o>*</span><span class=nx>TreeNode</span><span class=p>,</span> <span class=nx>result</span> <span class=o>*</span><span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>node</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=o>*</span><span class=nx>result</span><span class=p>,</span> <span class=nx>node</span><span class=p>.</span><span class=nx>Val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>PreOrder</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>Left</span><span class=p>,</span> <span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>PreOrder</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>Right</span><span class=p>,</span> <span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>ğŸ“ In-Order Traversal (Left â†’ Root â†’ Right)</p><p>Use Case:
Yields nodes in ascending order for Binary Search Trees (BST).</p><p>Steps:</p><ol><li><p>Traverse left subtree</p></li><li><p>Visit root</p></li><li><p>Traverse right subtree</p></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>InOrder</span><span class=p>(</span><span class=nx>node</span> <span class=o>*</span><span class=nx>TreeNode</span><span class=p>,</span> <span class=nx>result</span> <span class=o>*</span><span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>node</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>InOrder</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>Left</span><span class=p>,</span> <span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=o>*</span><span class=nx>result</span><span class=p>,</span> <span class=nx>node</span><span class=p>.</span><span class=nx>Val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>InOrder</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>Right</span><span class=p>,</span> <span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>ğŸ§® Post-Order Traversal (Left â†’ Right â†’ Root)</p><p>Use Case:
Ideal for deleting or freeing nodes, postfix expression evaluation.</p><p>Steps:</p><ol><li><p>Traverse left subtree</p></li><li><p>Traverse right subtree</p></li><li><p>Visit root</p></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>PostOrder</span><span class=p>(</span><span class=nx>node</span> <span class=o>*</span><span class=nx>TreeNode</span><span class=p>,</span> <span class=nx>result</span> <span class=o>*</span><span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>node</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>PostOrder</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>Left</span><span class=p>,</span> <span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>PostOrder</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>Right</span><span class=p>,</span> <span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=o>*</span><span class=nx>result</span><span class=p>,</span> <span class=nx>node</span><span class=p>.</span><span class=nx>Val</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>ğŸ›ï¸ Level-Order Traversal (Breadth-First)</p><p>Use Case:
Used for printing trees by level or finding the shortest path in a tree.</p><p>Steps:</p><ol><li>Traverse nodes level by level (left to right)</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>LevelOrder</span><span class=p>(</span><span class=nx>root</span> <span class=o>*</span><span class=nx>TreeNode</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>root</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>queue</span> <span class=o>:=</span> <span class=p>[]</span><span class=o>*</span><span class=nx>TreeNode</span><span class=p>{</span><span class=nx>root</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>result</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>queue</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>node</span> <span class=o>:=</span> <span class=nx>queue</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nx>queue</span> <span class=p>=</span> <span class=nx>queue</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>        <span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>node</span><span class=p>.</span><span class=nx>Val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>node</span><span class=p>.</span><span class=nx>Left</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>queue</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>queue</span><span class=p>,</span> <span class=nx>node</span><span class=p>.</span><span class=nx>Left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>node</span><span class=p>.</span><span class=nx>Right</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>queue</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>queue</span><span class=p>,</span> <span class=nx>node</span><span class=p>.</span><span class=nx>Right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>result</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>ğŸ”§ Test Tree Example</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Construct the following tree:</span>
</span></span><span class=line><span class=cl><span class=c1>//      1</span>
</span></span><span class=line><span class=cl><span class=c1>//     / \</span>
</span></span><span class=line><span class=cl><span class=c1>//    2   3</span>
</span></span><span class=line><span class=cl><span class=c1>//   / \   \</span>
</span></span><span class=line><span class=cl><span class=c1>//  4   5   6</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>root</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>TreeNode</span><span class=p>{</span><span class=nx>Val</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>root</span><span class=p>.</span><span class=nx>Left</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>TreeNode</span><span class=p>{</span><span class=nx>Val</span><span class=p>:</span> <span class=mi>2</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>root</span><span class=p>.</span><span class=nx>Right</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>TreeNode</span><span class=p>{</span><span class=nx>Val</span><span class=p>:</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>root</span><span class=p>.</span><span class=nx>Left</span><span class=p>.</span><span class=nx>Left</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>TreeNode</span><span class=p>{</span><span class=nx>Val</span><span class=p>:</span> <span class=mi>4</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>root</span><span class=p>.</span><span class=nx>Left</span><span class=p>.</span><span class=nx>Right</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>TreeNode</span><span class=p>{</span><span class=nx>Val</span><span class=p>:</span> <span class=mi>5</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>root</span><span class=p>.</span><span class=nx>Right</span><span class=p>.</span><span class=nx>Right</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>TreeNode</span><span class=p>{</span><span class=nx>Val</span><span class=p>:</span> <span class=mi>6</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>pre</span><span class=p>,</span> <span class=nx>in</span><span class=p>,</span> <span class=nx>post</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>PreOrder</span><span class=p>(</span><span class=nx>root</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>pre</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>InOrder</span><span class=p>(</span><span class=nx>root</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>in</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>PostOrder</span><span class=p>(</span><span class=nx>root</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>post</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>level</span> <span class=o>:=</span> <span class=nf>LevelOrder</span><span class=p>(</span><span class=nx>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Pre-Order:&#34;</span><span class=p>,</span> <span class=nx>pre</span><span class=p>)</span>    <span class=c1>// [1 2 4 5 3 6]</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;In-Order:&#34;</span><span class=p>,</span> <span class=nx>in</span><span class=p>)</span>      <span class=c1>// [4 2 5 1 3 6]</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Post-Order:&#34;</span><span class=p>,</span> <span class=nx>post</span><span class=p>)</span>  <span class=c1>// [4 5 2 6 3 1]</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Level-Order:&#34;</span><span class=p>,</span> <span class=nx>level</span><span class=p>)</span><span class=c1>// [1 2 3 4 5 6]</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>âš™ï¸ Quick Go Snippets</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Pre-Order Traversal</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>PreOrder</span><span class=p>(</span><span class=nx>node</span> <span class=o>*</span><span class=nx>TreeNode</span><span class=p>,</span> <span class=nx>result</span> <span class=o>*</span><span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>node</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=o>*</span><span class=nx>result</span><span class=p>,</span> <span class=nx>node</span><span class=p>.</span><span class=nx>Val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>PreOrder</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>Left</span><span class=p>,</span> <span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>PreOrder</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>Right</span><span class=p>,</span> <span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// In-Order Traversal</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>InOrder</span><span class=p>(</span><span class=nx>node</span> <span class=o>*</span><span class=nx>TreeNode</span><span class=p>,</span> <span class=nx>result</span> <span class=o>*</span><span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>node</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>InOrder</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>Left</span><span class=p>,</span> <span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=o>*</span><span class=nx>result</span><span class=p>,</span> <span class=nx>node</span><span class=p>.</span><span class=nx>Val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>InOrder</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>Right</span><span class=p>,</span> <span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Post-Order Traversal</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>PostOrder</span><span class=p>(</span><span class=nx>node</span> <span class=o>*</span><span class=nx>TreeNode</span><span class=p>,</span> <span class=nx>result</span> <span class=o>*</span><span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>node</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>PostOrder</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>Left</span><span class=p>,</span> <span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>PostOrder</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>Right</span><span class=p>,</span> <span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=o>*</span><span class=nx>result</span><span class=p>,</span> <span class=nx>node</span><span class=p>.</span><span class=nx>Val</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Level-Order Traversal (BFS)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>LevelOrder</span><span class=p>(</span><span class=nx>root</span> <span class=o>*</span><span class=nx>TreeNode</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>root</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>queue</span> <span class=o>:=</span> <span class=p>[]</span><span class=o>*</span><span class=nx>TreeNode</span><span class=p>{</span><span class=nx>root</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>result</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>queue</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>node</span> <span class=o>:=</span> <span class=nx>queue</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nx>queue</span> <span class=p>=</span> <span class=nx>queue</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>        <span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>node</span><span class=p>.</span><span class=nx>Val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>node</span><span class=p>.</span><span class=nx>Left</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>queue</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>queue</span><span class=p>,</span> <span class=nx>node</span><span class=p>.</span><span class=nx>Left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>node</span><span class=p>.</span><span class=nx>Right</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>queue</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>queue</span><span class=p>,</span> <span class=nx>node</span><span class=p>.</span><span class=nx>Right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>result</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><hr><h2 id=-tree-traversal-algorithms--cheat-sheet>ğŸŒ³ Tree Traversal Algorithms â€“ Cheat Sheet</h2><table><thead><tr><th>Traversal Type</th><th>Visit Order</th><th>Use Case</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody><tr><td><strong>Pre-Order</strong></td><td>Root â†’ Left â†’ Right</td><td>Copy tree, prefix expressions</td><td>O(n)</td><td>O(h)</td></tr><tr><td><strong>In-Order</strong></td><td>Left â†’ Root â†’ Right</td><td>Sorted output in BSTs</td><td>O(n)</td><td>O(h)</td></tr><tr><td><strong>Post-Order</strong></td><td>Left â†’ Right â†’ Root</td><td>Delete tree, postfix expressions</td><td>O(n)</td><td>O(h)</td></tr><tr><td><strong>Level-Order</strong></td><td>Level by level (BFS)</td><td>Print by level, shortest path</td><td>O(n)</td><td>O(w)</td></tr></tbody></table><p><strong>Legend</strong>:</p><ul><li><code>n</code>: number of nodes</li><li><code>h</code>: tree height (log n for balanced, n for skewed)</li><li><code>w</code>: max width of the tree (can be up to n/2 in balanced trees)</li></ul><hr><h2 id=-the-modulo-operator->â— The Modulo Operator (%)</h2><p>The modulo operator is often underestimated, but itâ€™s a fundamental tool in both algorithm design and real-world programming.</p><h3 id=what-is-modulo>What Is Modulo?</h3><p><code>a % b</code> returns the remainder after dividing <code>a</code> by <code>b</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-matlab data-lang=matlab><span class=line><span class=cl><span class=n>a</span> <span class=p>=</span> <span class=n>b</span> Ã— <span class=n>q</span> <span class=o>+</span> <span class=n>r</span> <span class=n>where</span> <span class=mi>0</span> â‰¤ <span class=n>r</span> <span class=o>&lt;</span> <span class=n>b</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>Example: <code>5 % 2 = 1</code></p></li><li><p>Example: <code>12 % 5 = 2</code></p></li><li><p>Example: <code>20 % 5 = 0</code></p></li></ul><p>ğŸ‘‰ If <code>a &lt; b</code>, then <code>a % b = a</code>.</p><h3 id=when-do-we-use-modulo>When Do We Use Modulo?</h3><ol><li><p>Checking Divisibility</p><p>It is used to check if a number is even or odd.</p><p>Go implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>if</span> <span class=nx>n</span><span class=o>%</span><span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Even&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Odd&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Python implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>if</span> <span class=n>n</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Even&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Odd&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Cyclic Patterns (wrap-around</p><p>Go implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>days</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;Sun&#34;</span><span class=p>,</span> <span class=s>&#34;Mon&#34;</span><span class=p>,</span> <span class=s>&#34;Tue&#34;</span><span class=p>,</span> <span class=s>&#34;Wed&#34;</span><span class=p>,</span> <span class=s>&#34;Thu&#34;</span><span class=p>,</span> <span class=s>&#34;Fri&#34;</span><span class=p>,</span> <span class=s>&#34;Sat&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>dayIndex</span> <span class=o>:=</span> <span class=p>(</span><span class=nx>currentDay</span> <span class=o>+</span> <span class=nx>offset</span><span class=p>)</span> <span class=o>%</span> <span class=mi>7</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>days</span><span class=p>[</span><span class=nx>dayIndex</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><p>Python implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>days</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;Sun&#34;</span><span class=p>,</span> <span class=s2>&#34;Mon&#34;</span><span class=p>,</span> <span class=s2>&#34;Tue&#34;</span><span class=p>,</span> <span class=s2>&#34;Wed&#34;</span><span class=p>,</span> <span class=s2>&#34;Thu&#34;</span><span class=p>,</span> <span class=s2>&#34;Fri&#34;</span><span class=p>,</span> <span class=s2>&#34;Sat&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>day_index</span> <span class=o>=</span> <span class=p>(</span><span class=n>current_day</span> <span class=o>+</span> <span class=n>offset</span><span class=p>)</span> <span class=o>%</span> <span class=mi>7</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>days</span><span class=p>[</span><span class=n>day_index</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><p>ğŸ”„ Example Walkthrough</p><p>Letâ€™s say today is Friday (currentDay = 5).</p><ol><li><p>Offset = 2 (2 days later):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-matlab data-lang=matlab><span class=line><span class=cl><span class=p>(</span><span class=mi>5</span> <span class=o>+</span> <span class=mi>2</span><span class=p>)</span> <span class=c>% 7 = 7 % 7 = 0</span>
</span></span><span class=line><span class=cl><span class=n>days</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> &#34;<span class=n>Sun</span>&#34;
</span></span></code></pre></td></tr></table></div></div><p>âœ… Two days after Friday is Sunday.</p></li><li><p>Offset = 10 (10 days later):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-matlab data-lang=matlab><span class=line><span class=cl><span class=p>(</span><span class=mi>5</span> <span class=o>+</span> <span class=mi>10</span><span class=p>)</span> <span class=c>% 7 = 15 % 7 = 1</span>
</span></span><span class=line><span class=cl><span class=n>days</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> &#34;<span class=n>Mon</span>&#34;
</span></span></code></pre></td></tr></table></div></div><p>âœ… Ten days after Friday is Monday.</p></li><li><p>Offset = -3 (3 days earlier):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-matlab data-lang=matlab><span class=line><span class=cl><span class=p>(</span><span class=mi>5</span> <span class=o>-</span> <span class=mi>3</span><span class=p>)</span> <span class=c>% 7 = 2 % 7 = 2</span>
</span></span><span class=line><span class=cl><span class=n>days</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=p>=</span> &#34;<span class=n>Tue</span>&#34;
</span></span></code></pre></td></tr></table></div></div><p>âœ… Three days before Friday is Tuesday.</p></li></ol></li><li><p>Rotating Arrays</p><p>Array rotation is the process of shifting elements circularly â€” so elements that â€œfall offâ€ one end reappear on the other end.</p><p>This is common in:</p><ul><li><p>Coding interview problems (LeetCode, HackerRank).</p></li><li><p>Scheduling (round-robin tasks).</p></li><li><p>Games & simulations (rotating positions, cyclic states).</p></li><li><p>Data processing (moving averages, cyclic windows).</p></li></ul><p>Go implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>rotate</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>k</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=nx>k</span> <span class=p>=</span> <span class=nx>k</span> <span class=o>%</span> <span class=nx>n</span> <span class=c1>// handle k &gt; n</span>
</span></span><span class=line><span class=cl>     <span class=k>return</span> <span class=nb>append</span><span class=p>(</span><span class=nx>arr</span><span class=p>[</span><span class=nx>n</span><span class=o>-</span><span class=nx>k</span><span class=p>:],</span> <span class=nx>arr</span><span class=p>[:</span><span class=nx>n</span><span class=o>-</span><span class=nx>k</span><span class=p>]</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Python implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>rotate</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>      <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>k</span> <span class=o>=</span> <span class=n>k</span> <span class=o>%</span> <span class=n>n</span>  <span class=c1># handle k &gt; n</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>arr</span><span class=p>[</span><span class=o>-</span><span class=n>k</span><span class=p>:]</span> <span class=o>+</span> <span class=n>arr</span><span class=p>[:</span><span class=o>-</span><span class=n>k</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p><code>n := len(arr)</code> â†’ length of the array.</p></li><li><p><code>k = k % n</code> â†’ ensures we donâ€™t rotate more than necessary (e.g., rotating 12 times on length 5 = same as rotating 2 times).</p></li><li><p><code>arr[n-k:]</code> â†’ last k elements (to move to front).</p></li><li><p><code>arr[:n-k]</code> â†’ first n-k elements (move after).</p></li><li><p>`appen â†’ combines into rotated array.</p></li></ul><p>ğŸ”„ Example Walkthrough</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>arr</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>k</span> <span class=o>:=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=nx>res</span> <span class=o>:=</span> <span class=nf>rotate</span><span class=p>(</span><span class=nx>arr</span><span class=p>,</span> <span class=nx>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>res</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Steps:</p><ul><li><p>Original: [1 2 3 4 5]</p></li><li><p>Split: last 2 elements â†’ [4 5], first 3 elements â†’ [1 2 3]</p></li><li><p>Append: [4 5 1 2 3]</p></li></ul><p>âœ… Result: [4 5 1 2 3]</p><p>ğŸ”„ Another Example (k > n)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>arr</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>30</span><span class=p>,</span> <span class=mi>40</span><span class=p>,</span> <span class=mi>50</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>k</span> <span class=o>:=</span> <span class=mi>7</span>
</span></span><span class=line><span class=cl><span class=nx>res</span> <span class=o>:=</span> <span class=nf>rotate</span><span class=p>(</span><span class=nx>arr</span><span class=p>,</span> <span class=nx>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>res</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p><code>n = 5</code></p></li><li><p><code>k = 7 % 5 = 2</code></p></li><li><p>Split: last <code>2</code> â†’ <code>[40 50]</code>, first <code>3</code> â†’ <code>[10 20 30]</code></p></li><li><p>Result: <code>[40 50 10 20 30]</code></p></li></ul><p>ğŸ§­ Left vs Right Rotations</p><ul><li><p>Above code rotates to the right (end â†’ front).</p></li><li><p>To rotate left, just swap the slices:</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>rotateLeft</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>k</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=nx>k</span> <span class=p>=</span> <span class=nx>k</span> <span class=o>%</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=nb>append</span><span class=p>(</span><span class=nx>arr</span><span class=p>[</span><span class=nx>k</span><span class=p>:],</span> <span class=nx>arr</span><span class=p>[:</span><span class=nx>k</span><span class=p>]</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>âœ… Key Takeaway: Array rotation is a simple but powerful trick for cyclic problems. In Go, slicing + append makes it elegant and efficient.</p><p>ğŸ“Œ Use Cases</p><ul><li><p>Round-Robin Scheduling â†’ rotate task queue.</p></li><li><p>Cipher Algorithms â†’ shift characters cyclically.</p></li><li><p>Sliding Window Problems â†’ rotate buffers instead of reallocating.</p></li><li><p>Gaming â†’ rotate playersâ€™ turns.</p></li></ul></li><li><p>Hashing</p><p>Hashing is the process of taking a large (potentially infinite) set of input keys and mapping them into a fixed range of slots. This is crucial for data structures like hash tables, maps, and sets, where we want fast lookup, insert, and delete operations.</p><p>The main idea:</p><ul><li><p>We have more possible keys than storage slots.</p></li><li><p>We apply a hash function that always outputs a value within [0 â€¦ tableSize-1].</p></li><li><p>This allows us to place data into a fixed-size array and still find it later in constant time.</p></li></ul><p>Go implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>hash</span> <span class=o>:=</span> <span class=p>(</span><span class=nx>key</span> <span class=o>%</span> <span class=nx>tableSize</span> <span class=o>+</span> <span class=nx>tableSize</span><span class=p>)</span> <span class=o>%</span> <span class=nx>tableSize</span> <span class=c1>// handle negative keys</span>
</span></span></code></pre></td></tr></table></div></div><p>Output:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-matlab data-lang=matlab><span class=line><span class=cl><span class=n>Key</span> <span class=mi>12</span>     â†’ <span class=n>Slot</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=n>Key</span> <span class=mi>99</span>     â†’ <span class=n>Slot</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl><span class=n>Key</span> <span class=o>-</span><span class=mi>7</span>     â†’ <span class=n>Slot</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=n>Key</span> <span class=mi>123456</span> â†’ <span class=n>Slot</span> <span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div><p>Python implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>hash</span> <span class=o>=</span> <span class=p>(</span><span class=n>key</span> <span class=o>%</span> <span class=n>table_size</span> <span class=o>+</span> <span class=n>table_size</span><span class=p>)</span> <span class=o>%</span> <span class=n>table_size</span>  <span class=c1># handle negative keys</span>
</span></span></code></pre></td></tr></table></div></div><p>1.1 ğŸ› ï¸ Why Hashing Matters</p><ul><li><p>Efficiency: Lookup/insert/delete in O(1) on average.</p></li><li><p>Fixed memory: No need for huge arrays, even if keys are massive.</p></li><li><p>Determinism: Same key â†’ always the same slot.</p></li></ul><p>ğŸ‘‰ No matter how large or negative the key is, the result always lands in [0,4] because the table size is 5.</p><p>1.2 âš ï¸ The Collision Problem</p><p>Since the number of possible keys is much larger than the number of slots, different keys may map to the same slot.
Example:</p><pre><code>- 12 % 5 = 2

- 22 % 5 = 2
</code></pre><p>Both keys â†’ slot 2.</p><p>Common strategies to handle this:</p><ol><li><p>Chaining â€“ each slot stores a linked list or slice of elements.</p></li><li><p>Open Addressing â€“ if a slot is taken, probe for the next free one (linear probing, quadratic probing, double hashing).</p></li></ol><p>Example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nx>tableSize</span> <span class=o>:=</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl><span class=nx>table</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([][]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>tableSize</span><span class=p>)</span> <span class=c1>// slice of buckets (chaining)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>keys</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>12</span><span class=p>,</span> <span class=mi>22</span><span class=p>,</span> <span class=mi>99</span><span class=p>,</span> <span class=o>-</span><span class=mi>7</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>key</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>keys</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>idx</span> <span class=o>:=</span> <span class=p>(</span><span class=nx>key</span> <span class=o>%</span> <span class=nx>tableSize</span> <span class=o>+</span> <span class=nx>tableSize</span><span class=p>)</span> <span class=o>%</span> <span class=nx>tableSize</span>
</span></span><span class=line><span class=cl>        <span class=nx>table</span><span class=p>[</span><span class=nx>idx</span><span class=p>]</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>table</span><span class=p>[</span><span class=nx>idx</span><span class=p>],</span> <span class=nx>key</span><span class=p>)</span> <span class=c1>// put key into bucket</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// ğŸ” Lookup</span>
</span></span><span class=line><span class=cl>    <span class=nx>keyToFind</span> <span class=o>:=</span> <span class=mi>22</span>
</span></span><span class=line><span class=cl>    <span class=nx>idx</span> <span class=o>:=</span> <span class=p>(</span><span class=nx>keyToFind</span> <span class=o>%</span> <span class=nx>tableSize</span> <span class=o>+</span> <span class=nx>tableSize</span><span class=p>)</span> <span class=o>%</span> <span class=nx>tableSize</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Looking for key:&#34;</span><span class=p>,</span> <span class=nx>keyToFind</span><span class=p>,</span> <span class=s>&#34;in bucket:&#34;</span><span class=p>,</span> <span class=nx>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Bucket contents:&#34;</span><span class=p>,</span> <span class=nx>table</span><span class=p>[</span><span class=nx>idx</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Output:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-matlab data-lang=matlab><span class=line><span class=cl><span class=n>Looking</span> <span class=k>for</span> <span class=n>key</span><span class=p>:</span> <span class=mi>22</span> <span class=n>in</span> <span class=n>bucket</span><span class=p>:</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=n>Bucket</span> <span class=n>contents</span><span class=p>:</span> <span class=p>[</span><span class=mi>12</span> <span class=mi>22</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>1.3 âœ… Key Takeaway</p><p>Hashing ensures that any key, no matter how large or small, is mapped into a fixed range of slots. This is what makes hash maps and sets in Go (and other languages) efficient and practical.</p><p>1.4 ğŸš€ Hashing in Real Go Code (map)</p><p>In real-world Go code, you donâ€™t usually implement hashing yourself â€” you just use the built-in map.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>users</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=mi>123</span><span class=p>:</span> <span class=s>&#34;Alice&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl> <span class=mi>456</span><span class=p>:</span> <span class=s>&#34;Bob&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>users</span><span class=p>[</span><span class=mi>123</span><span class=p>])</span> <span class=c1>// &#34;Alice&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>Goâ€™s map already:</p><pre><code>- Computes the hash of your keys.

- Decides which bucket to put them in.

- Handles collisions internally (buckets + open addressing).

- Resizes automatically when needed.
</code></pre><p>ğŸ‘‰ Writing your own hash function is great for learning DSA, but in production Go code you almost always use map.</p></li><li><p>Circular Buffers</p><p>It is used to wrap indices around when they exceed the buffer size.</p><p>Go implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>nextIndex</span> <span class=o>:=</span> <span class=p>(</span><span class=nx>currentIndex</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=nx>bufferSize</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>currentIndex â†’ where you are now.</p></li><li><p>+1 â†’ move forward.</p></li><li><p>% bufferSize â†’ wraps back to 0 when you reach the end.</p></li></ul><p>A circular buffer (or ring buffer) is a fixed-size data structure that treats memory as if it were connected end-to-end in a circle. When the index reaches the end of the buffer, it wraps back to the beginning.</p><p>This makes it very useful for:</p><ul><li><p>Streaming data (audio, video, logs).</p></li><li><p>Queues with fixed memory (no growing slices).</p></li><li><p>Producerâ€“consumer problems (bounded buffer).</p></li></ul><p>ğŸ”„ Example Walkthrough</p><p>Say bufferSize = 5, indices = 0â€“4.</p><p>If currentIndex = 3:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>nextIndex</span> <span class=p>=</span> <span class=p>(</span><span class=mi>3</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=mi>5</span> <span class=p>=</span> <span class=mi>4</span>
</span></span></code></pre></td></tr></table></div></div><p>â†’ move to index 4.</p><p>If currentIndex = 4:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>nextIndex</span> <span class=p>=</span> <span class=p>(</span><span class=mi>4</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=mi>5</span> <span class=p>=</span> <span class=mi>0</span>
</span></span></code></pre></td></tr></table></div></div><p>â†’ wrap around to index 0.</p><p>âœ… The % operator ensures the index always stays inside [0 â€¦ bufferSize-1].</p><p>ğŸ› ï¸ Simple Go Example</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nx>bufferSize</span> <span class=o>:=</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl><span class=nx>buffer</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>bufferSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>12</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>idx</span> <span class=o>:=</span> <span class=nx>i</span> <span class=o>%</span> <span class=nx>bufferSize</span>
</span></span><span class=line><span class=cl>        <span class=nx>buffer</span><span class=p>[</span><span class=nx>idx</span><span class=p>]</span> <span class=p>=</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Write %2d â†’ slot %d | buffer: %v\n&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>idx</span><span class=p>,</span> <span class=nx>buffer</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Output:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-matlab data-lang=matlab><span class=line><span class=cl><span class=n>Write</span>  <span class=mi>0</span> â†’ <span class=n>slot</span> <span class=mi>0</span> <span class=o>|</span> <span class=n>buffer</span><span class=p>:</span> <span class=p>[</span><span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>Write</span>  <span class=mi>1</span> â†’ <span class=n>slot</span> <span class=mi>1</span> <span class=o>|</span> <span class=n>buffer</span><span class=p>:</span> <span class=p>[</span><span class=mi>0</span> <span class=mi>1</span> <span class=mi>0</span> <span class=mi>0</span> <span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>Write</span>  <span class=mi>2</span> â†’ <span class=n>slot</span> <span class=mi>2</span> <span class=o>|</span> <span class=n>buffer</span><span class=p>:</span> <span class=p>[</span><span class=mi>0</span> <span class=mi>1</span> <span class=mi>2</span> <span class=mi>0</span> <span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>Write</span>  <span class=mi>3</span> â†’ <span class=n>slot</span> <span class=mi>3</span> <span class=o>|</span> <span class=n>buffer</span><span class=p>:</span> <span class=p>[</span><span class=mi>0</span> <span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>Write</span>  <span class=mi>4</span> â†’ <span class=n>slot</span> <span class=mi>4</span> <span class=o>|</span> <span class=n>buffer</span><span class=p>:</span> <span class=p>[</span><span class=mi>0</span> <span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>Write</span>  <span class=mi>5</span> â†’ <span class=n>slot</span> <span class=mi>0</span> <span class=o>|</span> <span class=n>buffer</span><span class=p>:</span> <span class=p>[</span><span class=mi>5</span> <span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>Write</span>  <span class=mi>6</span> â†’ <span class=n>slot</span> <span class=mi>1</span> <span class=o>|</span> <span class=n>buffer</span><span class=p>:</span> <span class=p>[</span><span class=mi>5</span> <span class=mi>6</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=c>...</span>
</span></span></code></pre></td></tr></table></div></div><p>ğŸ‘‰ Notice how after filling slots 0â€“4, writing continues at slot 0 again, overwriting old data.</p><p>Python implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>next_index</span> <span class=o>=</span> <span class=p>(</span><span class=n>current_index</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>buffer_size</span>
</span></span></code></pre></td></tr></table></div></div><p>ğŸ“Œ Use Cases</p><ul><li><p>Log buffers â†’ keep last N entries.</p></li><li><p>Network packets â†’ stream without resizing memory.</p></li><li><p>Real-time systems â†’ bounded memory, no GC spikes.</p></li></ul><p>âœ… Key Takeaway: Circular buffers use modulus arithmetic to â€œwrap aroundâ€ indices. Theyâ€™re memory-efficient and perfect for streaming and queue-like scenarios where overwriting old data is acceptable.</p></li></ol><h3 id=key-insights>Key Insights</h3><p>Modulo is the perfect operator when dealing with:</p><ul><li><p>Repetition (time, days, rotations)</p></li><li><p>Bounded ranges (array indices, hash maps)</p></li><li><p>Divisibility checks</p></li></ul><p>Think of % as the wrap-around operator â€” it keeps numbers within limits.</p><hr><h2 id=-tips-for-learning-dsa-with-go>ğŸ§  Tips for Learning DSA with Go</h2><ul><li>Practice problems: Use platforms like <a href=https://leetcode.com/>LeetCode</a>, <a href=https://www.hackerrank.com/>HackerRank</a>, or <a href=https://exercism.org/>Exercism</a>.</li><li>Understand time complexity: Know Big-O analysis for every structure and algorithm.</li><li>Build mini-projects: Implement your own <code>LRU Cache</code>, <code>Trie</code>, or <code>Priority Queue</code>.</li></ul><hr><h2 id=-final-thoughts>ğŸ¯ Final Thoughts</h2><p>Mastering DSA not only sharpens your coding skills but also prepares you for systems design, performance optimization, and real-world problem-solving.</p><p>With Goâ€™s clean syntax and powerful standard library, you&rsquo;re equipped to tackle DSA challenges efficiently and idiomatically.</p><hr><p>ğŸš€ Follow me on <a href=https://norbix.dev>norbix.dev</a> for more insights on Go, Python, AI, system design, and engineering wisdom.</p></div><div class=post-subscribe><style>.subscribe-form{display:flex;gap:.5rem;margin-top:1rem;align-items:center}.subscribe-form input[type=email]{padding:.5rem;border-radius:6px;border:1px solid #ccc;background-color:#1f1f1f;color:#fff}.subscribe-form input[type=submit],.subscribe-form button{padding:.5rem 1rem;border-radius:6px;background-color:#facc15;color:#000;border:none;cursor:pointer;font-weight:700}.subscribe-form input[type=submit]:hover{background-color:#fcd34d}</style><form action=https://buttondown.email/api/emails/embed-subscribe/norbix method=post target=popupwindow onsubmit='window.open("https://buttondown.email/norbix","popupwindow")' class=subscribe-form><input type=email name=email placeholder="Enter your email" required>
<input type=submit value=Subscribe></form><p style=font-size:.875rem;opacity:.6>Powered by Buttondown.</p></div><div class=post-comments><script src=https://giscus.app/client.js data-repo=norbix/norbix.dev data-repo-id=R_kgDOOV_xMQ data-category=Announcements data-category-id=DIC_kwDOOV_xMc4CpF5M data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=dark data-lang=en crossorigin=anonymous async></script></div><nav class=paginav><a class=prev href=https://norbix.dev/posts/design-patterns/><span class=title>Â« Prev</span><br><span>GoF Design Patterns in Go: Practical Examples</span>
</a><a class=next href=https://norbix.dev/posts/graph-theory-algorithms-4-competitive-programming/><span class=title>Next Â»</span><br><span>Graph Theory Algorithms 4 Competitive Programming</span></a></nav></article></main></main><footer class=footer><span>&copy; 2026 <a href=https://norbix.dev/>norbix.dev - The log of my journey through code & software systems architecture</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script src=https://platform.linkedin.com/badges/js/profile.js async defer type=text/javascript></script></body></html>
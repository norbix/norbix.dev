<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><script>(function(){const e=localStorage.getItem("theme"),t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches;e==="dark"||!e&&t?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark"),window.setTheme=function(e){localStorage.setItem("theme",e),document.documentElement.classList.toggle("dark",e==="dark")}})()</script><title>Concurrency in Go | norbix.dev
</title><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Concurrency in Go | norbix.dev - The log of my journey through code & software systems architecture</title>
<meta name=keywords content="go,golang,concurrency,goroutines,channels"><meta name=description content="A deep dive into concurrency in Go, covering goroutines, channels, and real-world patterns."><meta name=author content><link rel=canonical href=https://norbix.dev/posts/concurrency-in-go/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://norbix.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://norbix.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://norbix.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://norbix.dev/apple-touch-icon.png><link rel=mask-icon href=https://norbix.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://norbix.dev/posts/concurrency-in-go/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=canonical href=https://norbix.dev/posts/concurrency-in-go/><meta property="og:title" content="Concurrency in Go"><meta property="og:url" content="https://norbix.dev/posts/concurrency-in-go/"><meta property="og:image" content="https://norbix.dev/banner.jpg"><meta property="og:type" content="article"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Concurrency in Go"><meta name=twitter:image content="https://norbix.dev/banner.jpg"><script data-goatcounter=https://norbix.goatcounter.com/count async src=//gc.zgo.at/count.js></script><link rel=alternate type=application/rss+xml title="RSS Feed for norbix.dev" href=/index.xml><script src=https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js defer></script><script>document.addEventListener("DOMContentLoaded",function(){window.mermaid&&(document.querySelectorAll("code.language-mermaid").forEach(function(e){var n=e.parentElement,t=document.createElement("div");t.className="mermaid",t.textContent=e.textContent,n.replaceWith(t)}),mermaid.initialize({startOnLoad:!0}))})</script><link href=https://cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.3/css/lightbox.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.3/js/lightbox.min.js defer></script><meta property="og:title" content="Concurrency in Go"><meta property="og:description" content="A deep dive into concurrency in Go, covering goroutines, channels, and real-world patterns."><meta property="og:type" content="article"><meta property="og:url" content="https://norbix.dev/posts/concurrency-in-go/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-19T15:52:47+02:00"><meta property="article:modified_time" content="2025-04-19T15:52:47+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Concurrency in Go"><meta name=twitter:description content="A deep dive into concurrency in Go, covering goroutines, channels, and real-world patterns."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://norbix.dev/posts/"},{"@type":"ListItem","position":2,"name":"Concurrency in Go","item":"https://norbix.dev/posts/concurrency-in-go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Concurrency in Go","name":"Concurrency in Go","description":"A deep dive into concurrency in Go, covering goroutines, channels, and real-world patterns.","keywords":["go","golang","concurrency","goroutines","channels"],"articleBody":" üß† Concurrency in Go: Goroutines, Channels, and Patterns Go was designed with concurrency as a first-class citizen. Unlike many other languages that bolt on concurrency, Go‚Äôs model‚Äîcentered around goroutines and channels‚Äîis simple, elegant, and incredibly powerful.\nIn this article, we‚Äôll break down:\nWhat concurrency is in Go How goroutines and channels work Real-world concurrency patterns Code examples you can plug into your own projects üö¶ Concurrency vs. Parallelism Concurrency is about managing multiple tasks at once. Parallelism is about doing multiple tasks simultaneously. Go lets you write concurrent code easily, and if your CPU allows, it can also run in parallel.\nüåÄ Goroutines A goroutine is a lightweight thread managed by the Go runtime.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \"fmt\" \"time\" ) func sayHello() { fmt.Println(\"Hello from goroutine!\") } func main() { go sayHello() // runs concurrently time.Sleep(time.Second) fmt.Println(\"Main finished.\") } go sayHello() starts the function in the background.\n‚ö†Ô∏è Without time.Sleep, the main function may exit before the goroutine finishes.\nüì° Unbuffered Channels Channels allow goroutines to communicate safely.\nUnbuffered channel are blocking, both send and receive are blocking operations.\n1 2 3 4 5 6 7 8 ch := make(chan string) go func() { ch \u003c- \"ping\" // send }() msg := \u003c-ch // receive fmt.Println(msg) // prints: ping chan T is a channel of type T \u003c-ch receives ch \u003c- sends üîÑ Buffered Channels Buffered channels don‚Äôt block until full.\n1 2 3 4 5 6 ch := make(chan int, 2) ch \u003c- 1 ch \u003c- 2 fmt.Println(\u003c-ch) fmt.Println(\u003c-ch) ‚ùå Closing Channels You can close a channel to indicate no more values will be sent.\nThis example does require close(ch) because of how range works with channels. This for range loop keeps receiving values from the channel until it‚Äôs closed.\n1 2 3 4 5 6 7 8 9 10 11 ch := make(chan int) go func() { for i := 0; i \u003c 3; i++ { ch \u003c- i } close(ch) }() for val := range ch { fmt.Println(val) } üß± Select Statement select lets you wait on multiple channel operations.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ch1 := make(chan string) ch2 := make(chan string) go func() { time.Sleep(1 * time.Second) ch1 \u003c- \"one\" }() go func() { time.Sleep(2 * time.Second) ch2 \u003c- \"two\" }() select { case msg1 := \u003c-ch1: fmt.Println(\"Received\", msg1) case msg2 := \u003c-ch2: fmt.Println(\"Received\", msg2) } üõ†Ô∏è Concurrency Patterns Fan-Out / Fan-In\nFan-Out: Multiple goroutines read from the same channel.\nFan-In: Multiple goroutines send into a single channel.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import ( \"fmt\" \"time\" ) func worker(id int, jobs \u003c-chan int, results chan\u003c- int) { for j := range jobs { fmt.Printf(\"Worker %d processing job %d\\n\", id, j) time.Sleep(time.Second) // simulate work fmt.Printf(\"Worker %d finished job %d\\n\", id, j) results \u003c- j * 2 } } func main() { jobs := make(chan int, 5) results := make(chan int, 5) // Creates 3 goroutines, each running worker(...). for w := 1; w \u003c= 3; w++ { go worker(w, jobs, results) } // The main function (itself a goroutine) then sends 5 jobs. for j := 1; j \u003c= 5; j++ { jobs \u003c- j } close(jobs) // Main goroutine waits for results // It receives 5 results ‚Äî one for each job processed by the pool. for a := 1; a \u003c= 5; a++ { fmt.Println(\"Result:\", \u003c-results) } } Example output (order may vary):\n1 2 3 4 5 6 7 8 9 10 Worker 1 processing job 1 Worker 2 processing job 2 Worker 3 processing job 3 Worker 1 processing job 4 Worker 2 processing job 5 Result: 2 Result: 4 Result: 6 Result: 8 Result: 10 Order isn‚Äôt guaranteed ‚Äî it depends on goroutine scheduling\nWorker Pool\nA worker pool is one of the most common and practical concurrency patterns in Go. It helps you:\nControl concurrency ‚Üí avoid spawning too many goroutines.\nReuse workers ‚Üí instead of creating a goroutine per job.\nPrevent resource exhaustion ‚Üí e.g. database connections, network sockets.\nThink of it like a factory line: jobs come in, a fixed number of workers handle them, results are collected.\nBasic Worker Pool Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package main import ( \"fmt\" \"sync\" \"time\" ) func worker(id int, jobs \u003c-chan int, results chan\u003c- int, wg *sync.WaitGroup) { defer wg.Done() for j := range jobs { fmt.Printf(\"Worker %d started job %d\\n\", id, j) time.Sleep(time.Second) // simulate work fmt.Printf(\"Worker %d finished job %d\\n\", id, j) results \u003c- j * 2 } } func main() { jobs := make(chan int, 5) results := make(chan int, 5) var wg sync.WaitGroup // start workers for w := 1; w \u003c= 5; w++ { wg.Add(1) go worker(w, jobs, results, \u0026wg) } // send jobs for j := 1; j \u003c= 5; j++ { jobs \u003c- j } close(jobs) // wait for workers to finish go func() { wg.Wait() close(results) }() // collect results for r := range results { fmt.Println(\"Result:\", r) } } üß† Key Observations numWorkers controls parallelism (not number of jobs).\nJobs are pushed into a channel ‚Üí workers pull them at their own pace.\nsync.WaitGroup ensures all workers finish before closing results.\n‚ö° Variations in Production Dynamic Pools ‚Üí adjust number of workers depending on load. Error Handling ‚Üí use an errChan to collect errors from workers.\nContext-Aware Pools ‚Üí cancel all workers if one fails or timeout occurs.\n1 2 ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() üìä When to Use Worker Pools ‚úÖ Best for:\nCPU-bound tasks (e.g., image processing).\nI/O-bound tasks (e.g., HTTP requests, DB queries).\nBatch jobs and pipelines.\n‚ùå Not needed for:\nSmall scripts.\nLightweight goroutine fan-out without backpressure. üëâ Rule of Thumb:\nStart with goroutines + channels. If you notice too many goroutines or unbounded resource use, switch to a worker pool.\nüîç Key Differences Summary Aspect Without WaitGroup With WaitGroup Knowing how many results to read Must know exact count (for i := 1; i \u003c= N) No need ‚Äî for range until closed Who closes results Nobody (left open) A goroutine after all workers finish When program ends Possibly before all workers finish Guaranteed after all workers finish Synchronization Implicit (via job count) Explicit (via wg.Wait()) Safety in large systems Not safe for unknown job counts Safe and scalable ‚è±Ô∏è Timeout with select In Go, you can use the select statement with time.After to implement timeouts for channel operations.\nThis prevents your goroutine from blocking forever if no data arrives within a given duration.\n1 2 3 4 5 6 7 8 9 10 11 12 13 c := make(chan string) go func() { time.Sleep(2 * time.Second) c \u003c- \"done\" }() select { case res := \u003c-c: fmt.Println(res) case \u003c-time.After(1 * time.Second): fmt.Println(\"timeout\") } ‚öñÔ∏è sync.WaitGroup Use it to wait for all goroutines to finish before continuing execution.\nA WaitGroup provides a simple way to coordinate concurrent tasks and ensure they complete before your program exits.\n1 2 3 4 5 6 7 8 9 10 11 12 var wg sync.WaitGroup for i := 0; i \u003c 3; i++ { wg.Add(1) go func(id int) { defer wg.Done() fmt.Printf(\"Worker %d done\\n\", id) }(i) } wg.Wait() fmt.Println(\"All workers finished.\") üß† Final Thoughts Go makes concurrency not only powerful‚Äîbut approachable. You don‚Äôt need threads or semaphores to build safe, concurrent systems. ‚úÖ Key Takeaways:\nUse goroutines for lightweight concurrency. Use channels for safe communication. Master select, worker pools, and timeouts for production-grade patterns. üöÄ Follow me on norbix.dev for more insights on Go, Python, AI, system design, and engineering wisdom.\n","wordCount":"1352","inLanguage":"en","datePublished":"2025-04-19T15:52:47+02:00","dateModified":"2025-04-19T15:52:47+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://norbix.dev/posts/concurrency-in-go/"},"publisher":{"@type":"Organization","name":"norbix.dev - The log of my journey through code \u0026 software systems architecture","logo":{"@type":"ImageObject","url":"https://norbix.dev/favicon.ico"}}}</script></head><body><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://norbix.dev/ accesskey=h title="norbix.dev - The log of my journey through code & software systems architecture (Alt + H)">norbix.dev - The log of my journey through code & software systems architecture</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://norbix.dev/ title=Home><span>Home</span></a></li><li><a href=https://norbix.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://norbix.dev/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://norbix.dev/about/ title=About><span>About</span></a></li><li><a href=https://norbix.dev/index.xml title="üì° RSS"><span>üì° RSS</span></a></li></ul></nav></header><main><main id=main><article class=post-single><header class=post-header><h1 class=post-title>Concurrency in Go</h1><span title='2025-04-19 15:52:47 +0200 +0200'>April 19, 2025</span></header><div class=post-content><nav class=table-of-contents><nav id=TableOfContents><ul><li><a href=#-concurrency-in-go-goroutines-channels-and-patterns>üß† Concurrency in Go: Goroutines, Channels, and Patterns</a></li><li><a href=#-concurrency-vs-parallelism>üö¶ Concurrency vs. Parallelism</a></li><li><a href=#-goroutines>üåÄ Goroutines</a></li><li><a href=#-unbuffered-channels>üì° Unbuffered Channels</a></li><li><a href=#-buffered-channels>üîÑ Buffered Channels</a></li><li><a href=#-closing-channels>‚ùå Closing Channels</a></li><li><a href=#-select-statement>üß± Select Statement</a></li><li><a href=#-concurrency-patterns>üõ†Ô∏è Concurrency Patterns</a><ul><li><a href=#-key-observations>üß† Key Observations</a></li><li><a href=#-variations-in-production>‚ö° Variations in Production</a></li><li><a href=#-when-to-use-worker-pools>üìä When to Use Worker Pools</a></li><li><a href=#-key-differences-summary>üîç Key Differences Summary</a></li></ul></li><li><a href=#-timeout-with-select>‚è±Ô∏è Timeout with <code>select</code></a></li><li><a href=#-syncwaitgroup>‚öñÔ∏è sync.WaitGroup</a></li><li><a href=#-final-thoughts>üß† Final Thoughts</a></li></ul></nav></nav><p><img loading=lazy src=banner.jpg alt=banner></p><h2 id=-concurrency-in-go-goroutines-channels-and-patterns>üß† Concurrency in Go: Goroutines, Channels, and Patterns</h2><p>Go was designed with concurrency as a first-class citizen. Unlike many other languages that bolt on concurrency, Go&rsquo;s model‚Äîcentered around goroutines and channels‚Äîis simple, elegant, and incredibly powerful.</p><p>In this article, we‚Äôll break down:</p><ul><li>What concurrency is in Go</li><li>How goroutines and channels work</li><li>Real-world concurrency patterns</li><li>Code examples you can plug into your own projects</li></ul><hr><h2 id=-concurrency-vs-parallelism>üö¶ Concurrency vs. Parallelism</h2><ul><li>Concurrency is about managing multiple tasks at once.</li><li>Parallelism is about doing multiple tasks simultaneously.</li></ul><p>Go lets you write concurrent code easily, and if your CPU allows, it can also run in parallel.</p><hr><h2 id=-goroutines>üåÄ Goroutines</h2><p>A goroutine is a lightweight thread managed by the Go runtime.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>sayHello</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Hello from goroutine!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>sayHello</span><span class=p>()</span> <span class=c1>// runs concurrently</span>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Main finished.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>go sayHello() starts the function in the background.</p><p>‚ö†Ô∏è Without time.Sleep, the main function may exit before the goroutine finishes.</p><hr><h2 id=-unbuffered-channels>üì° Unbuffered Channels</h2><p>Channels allow goroutines to communicate safely.</p><p>Unbuffered channel are blocking, both send and receive are blocking operations.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ch</span> <span class=o>&lt;-</span> <span class=s>&#34;ping&#34;</span>    <span class=c1>// send</span>
</span></span><span class=line><span class=cl><span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>msg</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>ch</span>         <span class=c1>// receive</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>msg</span><span class=p>)</span> <span class=c1>// prints: ping</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>chan T</code> is a channel of type T</li><li><code>&lt;-ch</code> receives</li><li><code>ch &lt;-</code> sends</li></ul><hr><h2 id=-buffered-channels>üîÑ Buffered Channels</h2><p>Buffered channels don‚Äôt block until full.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>ch</span> <span class=o>&lt;-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nx>ch</span> <span class=o>&lt;-</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=o>&lt;-</span><span class=nx>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=o>&lt;-</span><span class=nx>ch</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=-closing-channels>‚ùå Closing Channels</h2><p>You can close a channel to indicate no more values will be sent.</p><p>This example does require close(ch) because of how range works with channels. This <code>for range</code> loop keeps receiving values from the channel until it‚Äôs closed.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>ch</span> <span class=o>&lt;-</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nb>close</span><span class=p>(</span><span class=nx>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>val</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>ch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=-select-statement>üß± Select Statement</h2><p><code>select</code> lets you wait on multiple channel operations.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>ch1</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>ch2</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>ch1</span> <span class=o>&lt;-</span> <span class=s>&#34;one&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>ch2</span> <span class=o>&lt;-</span> <span class=s>&#34;two&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=nx>msg1</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>ch1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Received&#34;</span><span class=p>,</span> <span class=nx>msg1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=nx>msg2</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>ch2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Received&#34;</span><span class=p>,</span> <span class=nx>msg2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=-concurrency-patterns>üõ†Ô∏è Concurrency Patterns</h2><ol><li><p>Fan-Out / Fan-In</p><p>Fan-Out: Multiple goroutines read from the same channel.</p><p>Fan-In: Multiple goroutines send into a single channel.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>   
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>worker</span><span class=p>(</span><span class=nx>id</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>jobs</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>results</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>jobs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Worker %d processing job %d\n&#34;</span><span class=p>,</span> <span class=nx>id</span><span class=p>,</span> <span class=nx>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span> <span class=c1>// simulate work</span>
</span></span><span class=line><span class=cl>    	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Worker %d finished job %d\n&#34;</span><span class=p>,</span> <span class=nx>id</span><span class=p>,</span> <span class=nx>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>results</span> <span class=o>&lt;-</span> <span class=nx>j</span> <span class=o>*</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>jobs</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>results</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Creates 3 goroutines, each running worker(...).</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>w</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>w</span> <span class=o>&lt;=</span> <span class=mi>3</span><span class=p>;</span> <span class=nx>w</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=nf>worker</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>jobs</span><span class=p>,</span> <span class=nx>results</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// The main function (itself a goroutine) then sends 5 jobs.</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>j</span> <span class=o>&lt;=</span> <span class=mi>5</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>jobs</span> <span class=o>&lt;-</span> <span class=nx>j</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nb>close</span><span class=p>(</span><span class=nx>jobs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Main goroutine waits for results</span>
</span></span><span class=line><span class=cl>    <span class=c1>// It receives 5 results ‚Äî one for each job processed by the pool.</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>a</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>a</span> <span class=o>&lt;=</span> <span class=mi>5</span><span class=p>;</span> <span class=nx>a</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Result:&#34;</span><span class=p>,</span> <span class=o>&lt;-</span><span class=nx>results</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Example output (order may vary):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Worker 1 processing job 1
</span></span><span class=line><span class=cl>Worker 2 processing job 2
</span></span><span class=line><span class=cl>Worker 3 processing job 3
</span></span><span class=line><span class=cl>Worker 1 processing job 4
</span></span><span class=line><span class=cl>Worker 2 processing job 5
</span></span><span class=line><span class=cl>Result: 2
</span></span><span class=line><span class=cl>Result: 4
</span></span><span class=line><span class=cl>Result: 6
</span></span><span class=line><span class=cl>Result: 8
</span></span><span class=line><span class=cl>Result: 10
</span></span></code></pre></td></tr></table></div></div><p>Order isn‚Äôt guaranteed ‚Äî it depends on goroutine scheduling</p></li><li><p>Worker Pool</p><p>A worker pool is one of the most common and practical concurrency patterns in Go. It helps you:</p><ul><li><p>Control concurrency ‚Üí avoid spawning too many goroutines.</p><ul><li><p>Reuse workers ‚Üí instead of creating a goroutine per job.</p></li><li><p>Prevent resource exhaustion ‚Üí e.g. database connections, network sockets.</p></li></ul></li></ul><p>Think of it like a factory line: jobs come in, a fixed number of workers handle them, results are collected.</p><p>Basic Worker Pool Example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>worker</span><span class=p>(</span><span class=nx>id</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>jobs</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>results</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>wg</span> <span class=o>*</span><span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>jobs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Worker %d started job %d\n&#34;</span><span class=p>,</span> <span class=nx>id</span><span class=p>,</span> <span class=nx>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span> <span class=c1>// simulate work</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Worker %d finished job %d\n&#34;</span><span class=p>,</span> <span class=nx>id</span><span class=p>,</span> <span class=nx>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>results</span> <span class=o>&lt;-</span> <span class=nx>j</span> <span class=o>*</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>jobs</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>results</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// start workers</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>w</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>w</span> <span class=o>&lt;=</span> <span class=mi>5</span><span class=p>;</span> <span class=nx>w</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=nf>worker</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>jobs</span><span class=p>,</span> <span class=nx>results</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>wg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// send jobs</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>j</span> <span class=o>&lt;=</span> <span class=mi>5</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>jobs</span> <span class=o>&lt;-</span> <span class=nx>j</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nb>close</span><span class=p>(</span><span class=nx>jobs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// wait for workers to finish</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nb>close</span><span class=p>(</span><span class=nx>results</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// collect results</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>r</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>results</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Result:&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=-key-observations>üß† Key Observations</h3><ul><li><p><code>numWorkers</code> controls parallelism (not number of jobs).</p></li><li><p>Jobs are pushed into a channel ‚Üí workers pull them at their own pace.</p></li><li><p><code>sync.WaitGroup</code> ensures all workers finish before closing results.</p></li></ul><h3 id=-variations-in-production>‚ö° Variations in Production</h3><ul><li>Dynamic Pools ‚Üí adjust number of workers depending on load.</li></ul></li></ol><ul><li><p>Error Handling ‚Üí use an errChan to collect errors from workers.</p></li><li><p>Context-Aware Pools ‚Üí cancel all workers if one fails or timeout occurs.</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithTimeout</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=mi>5</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>defer</span> <span class=nf>cancel</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=-when-to-use-worker-pools>üìä When to Use Worker Pools</h3><p>‚úÖ Best for:</p><ul><li><p>CPU-bound tasks (e.g., image processing).</p><ul><li><p>I/O-bound tasks (e.g., HTTP requests, DB queries).</p></li><li><p>Batch jobs and pipelines.</p></li></ul></li></ul><p>‚ùå Not needed for:</p><ul><li><p>Small scripts.</p><ul><li>Lightweight goroutine fan-out without backpressure.</li></ul></li></ul><p>üëâ Rule of Thumb:</p><p>Start with goroutines + channels. If you notice too many goroutines or unbounded resource use, switch to a worker pool.</p><h3 id=-key-differences-summary>üîç Key Differences Summary</h3><table><thead><tr><th>Aspect</th><th>Without <code>WaitGroup</code></th><th>With <code>WaitGroup</code></th></tr></thead><tbody><tr><td><strong>Knowing how many results to read</strong></td><td>Must know exact count (<code>for i := 1; i &lt;= N</code>)</td><td>No need ‚Äî <code>for range</code> until closed</td></tr><tr><td><strong>Who closes <code>results</code></strong></td><td>Nobody (left open)</td><td>A goroutine after all workers finish</td></tr><tr><td><strong>When program ends</strong></td><td>Possibly before all workers finish</td><td>Guaranteed after all workers finish</td></tr><tr><td><strong>Synchronization</strong></td><td>Implicit (via job count)</td><td>Explicit (via <code>wg.Wait()</code>)</td></tr><tr><td><strong>Safety in large systems</strong></td><td>Not safe for unknown job counts</td><td>Safe and scalable</td></tr></tbody></table><h2 id=-timeout-with-select>‚è±Ô∏è Timeout with <code>select</code></h2><p>In Go, you can use the <code>select</code> statement with <code>time.After</code> to implement timeouts for channel operations.<br>This prevents your goroutine from blocking forever if no data arrives within a given duration.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span> <span class=o>&lt;-</span> <span class=s>&#34;done&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=nx>res</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>c</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>res</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=o>&lt;-</span><span class=nx>time</span><span class=p>.</span><span class=nf>After</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=-syncwaitgroup>‚öñÔ∏è sync.WaitGroup</h2><p>Use it to wait for all goroutines to finish before continuing execution.<br>A <code>WaitGroup</code> provides a simple way to coordinate concurrent tasks and ensure they complete before your program exits.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>id</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Worker %d done\n&#34;</span><span class=p>,</span> <span class=nx>id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;All workers finished.&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=-final-thoughts>üß† Final Thoughts</h2><p>Go makes concurrency not only powerful‚Äîbut approachable. You don&rsquo;t need threads or semaphores to build safe, concurrent systems.
‚úÖ Key Takeaways:</p><ul><li>Use goroutines for lightweight concurrency.</li><li>Use channels for safe communication.</li><li>Master select, worker pools, and timeouts for production-grade patterns.</li></ul><hr><p>üöÄ Follow me on <a href=https://norbix.dev>norbix.dev</a> for more insights on Go, Python, AI, system design, and engineering wisdom.</p></div><div class=post-subscribe><style>.subscribe-form{display:flex;gap:.5rem;margin-top:1rem;align-items:center}.subscribe-form input[type=email]{padding:.5rem;border-radius:6px;border:1px solid #ccc;background-color:#1f1f1f;color:#fff}.subscribe-form input[type=submit],.subscribe-form button{padding:.5rem 1rem;border-radius:6px;background-color:#facc15;color:#000;border:none;cursor:pointer;font-weight:700}.subscribe-form input[type=submit]:hover{background-color:#fcd34d}</style><form action=https://buttondown.email/api/emails/embed-subscribe/norbix method=post target=popupwindow onsubmit='window.open("https://buttondown.email/norbix","popupwindow")' class=subscribe-form><input type=email name=email placeholder="Enter your email" required>
<input type=submit value=Subscribe></form><p style=font-size:.875rem;opacity:.6>Powered by Buttondown.</p></div><div class=post-comments><script src=https://giscus.app/client.js data-repo=norbix/norbix.dev data-repo-id=R_kgDOOV_xMQ data-category=Announcements data-category-id=DIC_kwDOOV_xMc4CpF5M data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=dark data-lang=en crossorigin=anonymous async></script></div><nav class=paginav><a class=prev href=https://norbix.dev/posts/graph-theory-algorithms-4-competitive-programming/><span class=title>¬´ Prev</span><br><span>Graph Theory Algorithms 4 Competitive Programming</span>
</a><a class=next href=https://norbix.dev/posts/big-o-notation/><span class=title>Next ¬ª</span><br><span>Demystifying Big-O Notation in Software Engineering</span></a></nav></article></main></main><footer class=footer><span>&copy; 2025 <a href=https://norbix.dev/>norbix.dev - The log of my journey through code & software systems architecture</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script src=https://platform.linkedin.com/badges/js/profile.js async defer type=text/javascript></script></body></html>
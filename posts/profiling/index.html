<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><script>(function(){const e=localStorage.getItem("theme"),t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches;e==="dark"||!e&&t?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark"),window.setTheme=function(e){localStorage.setItem("theme",e),document.documentElement.classList.toggle("dark",e==="dark")}})()</script><title>Profiling Go Applications: CPU, Memory, and Concurrency Insights | norbix.dev
</title><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Profiling Go Applications: CPU, Memory, and Concurrency Insights | norbix.dev - The log of my journey through code & software systems architecture</title>
<meta name=keywords content="go,profiling,performance,pprof,concurrency"><meta name=description content="Learn how to profile Go applications using pprof, trace, and runtime tools to uncover bottlenecks, memory leaks, and concurrency issues in production and development."><meta name=author content><link rel=canonical href=https://norbix.dev/posts/profiling/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://norbix.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://norbix.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://norbix.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://norbix.dev/apple-touch-icon.png><link rel=mask-icon href=https://norbix.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://norbix.dev/posts/profiling/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=canonical href=https://norbix.dev/posts/profiling/><meta property="og:title" content="Profiling Go Applications: CPU, Memory, and Concurrency Insights"><meta property="og:url" content="https://norbix.dev/posts/profiling/"><meta property="og:image" content="https://norbix.dev/profiling-banner.jpg"><meta property="og:type" content="article"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Profiling Go Applications: CPU, Memory, and Concurrency Insights"><meta name=twitter:image content="https://norbix.dev/profiling-banner.jpg"><script data-goatcounter=https://norbix.goatcounter.com/count async src=//gc.zgo.at/count.js></script><link rel=alternate type=application/rss+xml title="RSS Feed for norbix.dev" href=/index.xml><meta property="og:title" content="Profiling Go Applications: CPU, Memory, and Concurrency Insights"><meta property="og:description" content="Learn how to profile Go applications using pprof, trace, and runtime tools to uncover bottlenecks, memory leaks, and concurrency issues in production and development."><meta property="og:type" content="article"><meta property="og:url" content="https://norbix.dev/posts/profiling/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-22T19:00:00+02:00"><meta property="article:modified_time" content="2025-04-22T19:00:00+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Profiling Go Applications: CPU, Memory, and Concurrency Insights"><meta name=twitter:description content="Learn how to profile Go applications using pprof, trace, and runtime tools to uncover bottlenecks, memory leaks, and concurrency issues in production and development."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://norbix.dev/posts/"},{"@type":"ListItem","position":2,"name":"Profiling Go Applications: CPU, Memory, and Concurrency Insights","item":"https://norbix.dev/posts/profiling/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Profiling Go Applications: CPU, Memory, and Concurrency Insights","name":"Profiling Go Applications: CPU, Memory, and Concurrency Insights","description":"Learn how to profile Go applications using pprof, trace, and runtime tools to uncover bottlenecks, memory leaks, and concurrency issues in production and development.","keywords":["go","profiling","performance","pprof","concurrency"],"articleBody":" ‚ÄúFast is fine, but profiling tells you why you‚Äôre slow.‚Äù\nPerformance issues are often hard to debug ‚Äî your app feels sluggish, CPU spikes randomly, or memory usage keeps growing. Fortunately, Go provides powerful built-in tools to profile applications and uncover these bottlenecks.\nIn this article, I‚Äôll walk through profiling techniques in Go, focusing on CPU, memory, goroutine, and concurrency analysis using tools like pprof and trace.\nüîç What Is Profiling? Profiling is the act of measuring the performance characteristics of your application:\nWhere is the CPU time being spent?\nHow much memory is being allocated?\nAre goroutines being leaked?\nIs concurrency causing contention?\nGo‚Äôs standard library includes everything you need to answer these questions.\n‚öôÔ∏è net/http/pprof: Built-in Profiler The simplest way to expose profiling data is to import:\n1 import _ \"net/http/pprof\" Add this to your HTTP server:\n1 http.ListenAndServe(\"localhost:6060\", nil) Then, access these endpoints:\n/debug/pprof/profile ‚Äî CPU profile\n/debug/pprof/heap ‚Äî memory profile\n/debug/pprof/goroutine ‚Äî goroutine dump\nüß† CPU Profiling Generate a CPU profile:\n1 curl http://localhost:6060/debug/pprof/profile?seconds=30 \u003e cpu.prof Analyze it with:\n1 2 3 go tool pprof cpu.prof (pprof) top (pprof) web **web opens a flame graph (requires Graphviz) **\nüß† Memory Profiling Generate a heap profile:\n1 curl http://localhost:6060/debug/pprof/heap \u003e heap.prof Look for high allocation counts and large retained objects.\nUse pprof -alloc_objects, -inuse_space to slice the data differently.\nüßµ Goroutines and Blocking Dump goroutines:\n1 curl http://localhost:6060/debug/pprof/goroutine?debug=2 Find out if:\nGoroutines are leaking\nSomething is blocking channels or mutexes\n‚ö° Execution Tracing Go also supports full execution traces:\n1 import \"runtime/trace\" Wrap your code:\n1 2 3 f, _ := os.Create(\"trace.out\") runtime/trace.Start(f) defer trace.Stop() Then run:\n1 go tool trace trace.out Use this to spot scheduling delays, GC pauses, network latency, etc.\nüß™ Benchmarking + Profiling You can combine unit tests and profiling:\n1 2 3 4 5 func BenchmarkXxx(b *testing.B) { for i := 0; i \u003c b.N; i++ { MyFunction() } } Run with profiling:\n1 go test -bench=. -cpuprofile=cpu.prof -memprofile=mem.prof üõ†Ô∏è Real-World Tips Profile in production with real workloads when possible\nUse flame graphs to spot hot loops and recursive calls\nCompare snapshots before and after changes\nCombine pprof with metrics (Prometheus, Grafana)\nüß≠ Summary Profiling Go applications is straightforward but incredibly powerful:\nUse pprof for CPU, memory, and goroutines\nUse trace for low-level runtime behavior\nBenchmark with go test to validate changes\nProfile before you optimize ‚Äî measure twice, cut once.\nüöÄ Follow me on norbix.dev for more insights on Go, system design, and engineering wisdom.\n","wordCount":"414","inLanguage":"en","datePublished":"2025-04-22T19:00:00+02:00","dateModified":"2025-04-22T19:00:00+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://norbix.dev/posts/profiling/"},"publisher":{"@type":"Organization","name":"norbix.dev - The log of my journey through code \u0026 software systems architecture","logo":{"@type":"ImageObject","url":"https://norbix.dev/favicon.ico"}}}</script></head><body><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://norbix.dev/ accesskey=h title="norbix.dev - The log of my journey through code & software systems architecture (Alt + H)">norbix.dev - The log of my journey through code & software systems architecture</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://norbix.dev/ title=Home><span>Home</span></a></li><li><a href=https://norbix.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://norbix.dev/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://norbix.dev/about/ title=About><span>About</span></a></li><li><a href=https://norbix.dev/index.xml title="üì° RSS"><span>üì° RSS</span></a></li></ul></nav></header><main><main id=main><article class=post-single><header class=post-header><h1 class=post-title>Profiling Go Applications: CPU, Memory, and Concurrency Insights</h1><span title='2025-04-22 19:00:00 +0200 +0200'>April 22, 2025</span></header><div class=post-content><nav class=table-of-contents><nav id=TableOfContents><ul><li><a href=#-what-is-profiling>üîç What Is Profiling?</a></li><li><a href=#-nethttppprof-built-in-profiler>‚öôÔ∏è net/http/pprof: Built-in Profiler</a></li><li><a href=#-cpu-profiling>üß† CPU Profiling</a></li><li><a href=#-memory-profiling>üß† Memory Profiling</a></li><li><a href=#-goroutines-and-blocking>üßµ Goroutines and Blocking</a></li><li><a href=#-execution-tracing>‚ö° Execution Tracing</a></li><li><a href=#-benchmarking--profiling>üß™ Benchmarking + Profiling</a></li><li><a href=#-real-world-tips>üõ†Ô∏è Real-World Tips</a></li><li><a href=#-summary>üß≠ Summary</a></li></ul></nav></nav><p><img loading=lazy src=banner.jpg alt=banner></p><p><strong>&ldquo;Fast is fine, but profiling tells you why you&rsquo;re slow.&rdquo;</strong></p><p>Performance issues are often hard to debug ‚Äî your app feels sluggish, CPU spikes randomly, or memory usage keeps growing. Fortunately, Go provides powerful built-in tools to profile applications and uncover these bottlenecks.</p><p>In this article, I&rsquo;ll walk through profiling techniques in <code>Go</code>, focusing on <code>CPU</code>, <code>memory</code>, <code>goroutine</code>, and <code>concurrency</code> analysis using tools like <code>pprof</code> and <code>trace</code>.</p><hr><h2 id=-what-is-profiling>üîç What Is Profiling?</h2><p>Profiling is the act of measuring the performance characteristics of your application:</p><ul><li><p>Where is the CPU time being spent?</p></li><li><p>How much memory is being allocated?</p></li><li><p>Are goroutines being leaked?</p></li><li><p>Is concurrency causing contention?</p></li></ul><p><strong>Go‚Äôs standard library includes everything you need to answer these questions.</strong></p><hr><h2 id=-nethttppprof-built-in-profiler>‚öôÔ∏è net/http/pprof: Built-in Profiler</h2><p>The simplest way to expose profiling data is to import:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=nx>_</span> <span class=s>&#34;net/http/pprof&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>Add this to your HTTP server:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>(</span><span class=s>&#34;localhost:6060&#34;</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Then, access these endpoints:</p><ul><li><p><code>/debug/pprof/profile</code> ‚Äî CPU profile</p></li><li><p><code>/debug/pprof/heap</code> ‚Äî memory profile</p></li><li><p><code>/debug/pprof/goroutine</code> ‚Äî goroutine dump</p></li></ul><hr><h2 id=-cpu-profiling>üß† CPU Profiling</h2><p>Generate a CPU profile:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>curl http://localhost:6060/debug/pprof/profile?seconds=30 &gt; cpu.prof
</span></span></code></pre></td></tr></table></div></div><p>Analyze it with:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>go tool pprof cpu.prof
</span></span><span class=line><span class=cl>(pprof) top
</span></span><span class=line><span class=cl>(pprof) web
</span></span></code></pre></td></tr></table></div></div><p>**<code>web</code> opens a flame graph (requires <code>Graphviz</code>) **</p><hr><h2 id=-memory-profiling>üß† Memory Profiling</h2><p>Generate a heap profile:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>curl http://localhost:6060/debug/pprof/heap &gt; heap.prof
</span></span></code></pre></td></tr></table></div></div><p>Look for high allocation counts and large retained objects.</p><p><strong>Use pprof -alloc_objects, -inuse_space to slice the data differently.</strong></p><hr><h2 id=-goroutines-and-blocking>üßµ Goroutines and Blocking</h2><p>Dump goroutines:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>curl http://localhost:6060/debug/pprof/goroutine?debug=2
</span></span></code></pre></td></tr></table></div></div><p>Find out if:</p><ul><li><p>Goroutines are leaking</p></li><li><p>Something is blocking channels or mutexes</p></li></ul><hr><h2 id=-execution-tracing>‚ö° Execution Tracing</h2><p>Go also supports full execution traces:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;runtime/trace&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>Wrap your code:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>f</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Create</span><span class=p>(</span><span class=s>&#34;trace.out&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>runtime</span><span class=o>/</span><span class=nx>trace</span><span class=p>.</span><span class=nf>Start</span><span class=p>(</span><span class=nx>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>defer</span> <span class=nx>trace</span><span class=p>.</span><span class=nf>Stop</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><p>Then run:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>go tool trace trace.out
</span></span></code></pre></td></tr></table></div></div><p><strong>Use this to spot scheduling delays, GC pauses, network latency, etc.</strong></p><hr><h2 id=-benchmarking--profiling>üß™ Benchmarking + Profiling</h2><p>You can combine unit tests and profiling:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BenchmarkXxx</span><span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>MyFunction</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Run with profiling:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>go test -bench=. -cpuprofile=cpu.prof -memprofile=mem.prof
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=-real-world-tips>üõ†Ô∏è Real-World Tips</h2><ul><li><p>Profile in production with real workloads when possible</p></li><li><p>Use flame graphs to spot hot loops and recursive calls</p></li><li><p>Compare snapshots before and after changes</p></li><li><p>Combine <code>pprof</code> with metrics (<code>Prometheus</code>, <code>Grafana</code>)</p></li></ul><hr><h2 id=-summary>üß≠ Summary</h2><p>Profiling Go applications is straightforward but incredibly powerful:</p><ul><li><p>Use pprof for CPU, memory, and goroutines</p></li><li><p>Use trace for low-level runtime behavior</p></li><li><p>Benchmark with go test to validate changes</p></li></ul><p><strong>Profile before you optimize ‚Äî measure twice, cut once.</strong></p><hr><p>üöÄ Follow me on <a href=https://norbix.dev>norbix.dev</a> for more insights on Go, system design, and engineering wisdom.</p></div><div class=post-subscribe><style>.subscribe-form{display:flex;gap:.5rem;margin-top:1rem;align-items:center}.subscribe-form input[type=email]{padding:.5rem;border-radius:6px;border:1px solid #ccc;background-color:#1f1f1f;color:#fff}.subscribe-form input[type=submit],.subscribe-form button{padding:.5rem 1rem;border-radius:6px;background-color:#facc15;color:#000;border:none;cursor:pointer;font-weight:700}.subscribe-form input[type=submit]:hover{background-color:#fcd34d}</style><form action=https://buttondown.email/api/emails/embed-subscribe/norbix method=post target=popupwindow onsubmit='window.open("https://buttondown.email/norbix","popupwindow")' class=subscribe-form><input type=email name=email placeholder="Enter your email" required>
<input type=submit value=Subscribe></form><p style=font-size:.875rem;opacity:.6>Powered by Buttondown.</p></div><div class=post-comments><script src=https://giscus.app/client.js data-repo=norbix/norbix.dev data-repo-id=R_kgDOOV_xMQ data-category=Announcements data-category-id=DIC_kwDOOV_xMc4CpF5M data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=dark data-lang=en crossorigin=anonymous async></script></div><nav class=paginav><a class=prev href=https://norbix.dev/posts/debugging/><span class=title>¬´ Prev</span><br><span>Debugging Go Code: Techniques, Tools, and IDE Support</span>
</a><a class=next href=https://norbix.dev/posts/extreme-programming/><span class=title>Next ¬ª</span><br><span>Extreme Programming (XP): Engineering Excellence on Speed</span></a></nav></article></main></main><footer class=footer><span>&copy; 2025 <a href=https://norbix.dev/>norbix.dev - The log of my journey through code & software systems architecture</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>
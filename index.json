[{"content":" Writing Go code that works is easy. Writing Go code that lasts? That takes practice.\nAfter working on production systems in Go for several years â€” across SaaS platforms, cloud-native backends, and developer tooling â€” Iâ€™ve collected a set of battle-tested best practices that have helped me write maintainable, clean, and scalable Go code.\nğŸ§­ 0. Agree on Code Style Before You Write a Line Before starting any development, align on a shared code style with your team.\nThis prevents unnecessary friction during code reviews, ensures consistency, and reduces the mental overhead of switching between files written by different developers.\nA great starting point is the Google Go Style Guide â€” it\u0026rsquo;s clear, opinionated, and battle-tested at scale. You can automate style enforcement with:\ngofmt / goimports for formatting golangci-lint to enforce idiomatic Go practices Establishing your code style early also makes onboarding faster and simplifies collaboration â€” especially in cross-functional teams or open source projects.\nâœ… 1. Keep it Simple Go is intentionally minimal â€” embrace it.\nAvoid over-engineering. Prefer composition over inheritance. Use plain interfaces and simple data structures. Donâ€™t abstract too early â€” write the concrete code first. ğŸ§± 2. Project Structure Matters Use a predictable layout:\n1 2 3 4 5 6 /cmd - entry points /internal - private packages /pkg - public, reusable packages /api - OpenAPI/proto definitions /config - config loading /scripts - helper scripts Stick to convention. Tools like golang-standards/project-layout are a great starting point â€” but adapt it to your teamâ€™s needs.\nğŸ§ª 3. Tests Are Not Optional Use table-driven tests Use testing, and only bring in libraries like testify if you really need them Keep unit tests fast and independent Use go test -cover to check coverage âœ¨ 4. Errors Are First-Class Citizens Always check errors â€” no exceptions. Wrap errors with context using fmt.Errorf(\u0026quot;failed to read config: %w\u0026quot;, err) For complex systems, consider using errors.Join or errors.Is/As for proper error handling. ğŸ“¦ 5. Use Interfaces at the Boundaries Keep interfaces small, and only expose them where needed:\n1 2 3 type Storer interface { Save(ctx context.Context, data Item) error } Donâ€™t write interfaces for everything â€” only where mocking or substitution matters (e.g. storage, HTTP clients, etc.).\nğŸ§° 6. Tooling Makes You Better Use go vet, staticcheck, and golangci-lint Automate formatting: gofmt, goimports Use go mod tidy to keep your dependencies clean Pin tool versions with a tools.go file ğŸ“Š Use SonarQube for static code analysis at scale SonarQube helps enforce code quality and security standards across large codebases. It can detect bugs, vulnerabilities, code smells, and even provide actionable remediation guidance. Integrate it into your CI pipeline to ensure every PR gets automatically analyzed.\nYou can use sonar-scanner or a Docker-based runner like:\n1 2 3 4 5 6 ```bash docker run --rm \\ -e SONAR_HOST_URL=\u0026#34;https://your-sonarqube-url\u0026#34; \\ -e SONAR_LOGIN=\u0026#34;your_token\u0026#34; \\ -v \u0026#34;$(pwd):/usr/src\u0026#34; \\ sonarsource/sonar-scanner-cli SonarQube works great alongside golangci-lint, giving you both quick feedback locally and deep insights via the web dashboard.\nğŸ” 7. Secure By Default Always set timeouts on HTTP clients and servers Avoid leaking secrets in logs Validate all inputs â€” especially on the API boundary Use context.Context consistently and propagate it properly ğŸŒ 8. Embrace the Go Ecosystem Use standard library wherever possible â€” it\u0026rsquo;s well-tested and fast Prefer established, well-maintained packages Read source code â€” Go makes it easy to learn from the best ğŸš€ 9. Performance Matters (but correctness first) Profile with pprof Avoid allocations in tight loops Use channels, but donâ€™t abuse goroutines Benchmark with go test -bench ğŸ§  10. Readability \u0026gt; Cleverness Your code will be read 10x more than itâ€™s written.\n\u0026quot;Write code for humans, not machines.\u0026quot; Stick to idiomatic Go â€” use golangci-lint to enforce consistency, and always code with your teammates in mind.\nğŸ™Œ Conclusion Go is an incredible tool for building fast, reliable software â€” but like any tool, it shines brightest in the hands of developers who respect its philosophy: clarity, simplicity, and composability.\nWhat are your favorite Go best practices? Let me know on Twitter or GitHub @norbix!\nğŸš€ Follow me on norbix.dev for more insights on Go, system design, and engineering wisdom.\n","permalink":"https://norbix.dev/posts/best-practicies-4-software-development-in-go/","summary":"A collection of real-world Go best practices from years of building backend systems, APIs, and cloud-native services.","title":"Best Practices for Software Development in Go"},{"content":"The whiteboard behind this article is more than just colorful notes â€” it\u0026rsquo;s a map of the mental models that drive clean, scalable, and maintainable software systems. Letâ€™s break down the core ideas and keywords captured in this visual brainstorm.\nğŸ§  Sub-Domains \u0026amp; Bounded Contexts Domain, Sub-Domain, Service Line of business, like Insurance, Banking, E-Commerce Visualized as logical boundaries for teams and services Inspired by Domain-Driven Design (DDD) â€œDesign your system around business capabilities, not technical constraints.â€\nğŸ§± Architectural Patterns Layered Architecture: DAO â†’ Service â†’ Controller Module / Component view Common design layers: Project Layer Objects / Classes Executable packaging: .JAR / .EXE / .ZIP âœï¸ Design Patterns (GoF) Grouped by intent:\nStructural: Facade Decorator Adapter Behavioral: Strategy Observer Command Creational: Singleton Factory Builder Each of these has a purpose in object lifecycle, behavior injection, or structural abstraction.\nğŸ“ SOLID Principles Each letter is a compass for clean design:\nS â€“ Single Responsibility O â€“ Open/Closed L â€“ Liskov Substitution I â€“ Interface Segregation D â€“ Dependency Inversion And donâ€™t forget the twin brother: DRY (Donâ€™t Repeat Yourself).\nğŸ›°ï¸ Communication Styles REST, gRPC, GraphQL, WebSocket Pub/Sub, Push, Poll Emphasizes event-driven, asynchronous models in distributed systems âš™ï¸ Buzzwords \u0026amp; Practices From delivery to deployment:\n#ShiftLeft #TestFirst, #ContractFirst, #DesignFirst #PlatformEngineering #ZeroTrust, #Resilience, #Observability ğŸ¯ Hashtags as Architecture Drivers A few standout philosophies and principles:\n#CompositionOverInheritance #LiftAndShift #KISS (Keep It Simple, Stupid) #DeferDecisions #AutomationIsProductivity #AnticorruptionLayer #BoundedContext #HexagonalArchitecture These tags arenâ€™t just trending on dev Twitter â€” theyâ€™re real-world practices for making software less fragile and more adaptive.\nğŸ“Œ TL;DR The whiteboard outlines an entire mental toolkit for system design:\nThink in domains, not just code Choose patterns and principles that solve business pain points Architect with change in mind â€” using SOLID, DDD, and event-driven paradigms Let #buzzwords like #DRY, #ShiftLeft, and #Resilience guide practical decisions, not dogma \u0026ldquo;Architecture is not about boxes and arrows. It\u0026rsquo;s about decisions and trade-offs.\u0026rdquo;\nâ€“ Norbert Jakubczak\nğŸ’¬ Got questions about any of the keywords? Want a breakdown on one of the patterns or practices? Drop a comment below â€” let\u0026rsquo;s talk architecture.\nğŸš€ Follow me on norbix.dev for more insights on Go, system design, and engineering wisdom.\n","permalink":"https://norbix.dev/posts/keywords/","summary":"A visual exploration of the core keywords and concepts in modern software architecture.","title":"Keywords in Software Architecture"},{"content":" ğŸ§­ Mermaid Syntax Highlights ğŸ”„ Flowcharts Direction:\nLR: Left to Right TB: Top to Bottom BT: Bottom to Top flowchart LR G[(Goals)] \u0026lt;===\u0026gt; P[(Projects)] P ---o PD(Deadline) PD ---- OV([Overdue]) ---\u0026gt; FOV{4 Days} PD ---x MT([Met]) P ---o PT(Tasks) PT ---- C([Complete]) PT ---x IC([Incomplete]) C ---\u0026gt; R[[Review]] R -..-\u0026gt; G ğŸ‘€ Comments:\n%% â€“ Comment not rendered in the chart |Label| â€“ Annotates arrows ğŸ¯ Example with styling, click links, and labels:\nflowchart LR; classDef blue fill:#2374f7,stroke:#000,color:#fff G[(Goals)]:::blue \u0026lt;===\u0026gt; |Connects To| P[(Projects)]:::blue click P \u0026#34;https://github.com/norbix\u0026#34; ğŸ§± Graph Diagrams (UML-style) graph TD a(content) --\u0026gt; b([hello]) b --\u0026gt; c[(world)] b --\u0026gt; d(branch) d --\u0026gt; e((circle)) d ==\u0026gt; f\u0026gt;flag] f --- g{diamond} Use subgraph to group elements:\ngraph TD subgraph Graph One A --\u0026gt; B end subgraph Graph Two C --\u0026gt; D end A --\u0026gt; D ğŸ¥§ Pie Charts pie title Content Breakdown \u0026#34;youtube\u0026#34; : 50 \u0026#34;twitch\u0026#34; : 20 \u0026#34;twitter\u0026#34; : 30 ğŸ§­ Journey Diagrams Track progress or workflows using narrative sections:\njourney title My Working Day section Work Wrote code: 3: me Reviewed PRs: 4: me section Twitch Streamed: 3: me ğŸ§© Class Diagrams Great for OOP design documentation.\nclassDiagram class Order { +OrderStatus status } class OrderStatus { \u0026lt;\u0026lt;enumeration\u0026gt;\u0026gt; FAILED PENDING PAID } class PaymentProcessor { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; -String apiKey +processPayment(Order order) OrderStatus } class Customer { +String name } Order o-- Customer Car *-- Engine PaymentProcessor \u0026lt;|-- StripePaymentProcessor ğŸ“œ Sequence Diagrams sequenceDiagram participant fe as Front-End participant be as Back-End participant auth as Auth fe --\u0026gt;\u0026gt; be: Login be --\u0026gt;\u0026gt; auth: Validate auth --\u0026gt;\u0026gt; be: Token be --\u0026gt;\u0026gt; fe: Success alt Invalid credentials be --\u0026gt;\u0026gt; fe: Error end âœ… Why Use Mermaid in Your Codebase? ğŸ“– Self-documenting code and architecture ğŸ‘¥ Team-wide clarity on workflows and design ğŸ” Easy to update and version control ğŸ§© Supports component trees, state machines, database schemas, and more ğŸ“¦ Resources ğŸ“š Official Repo (mermaid-js/mermaid) ğŸ“ YouTube Course âœ¨ Try live: Mermaid Live Editor ğŸš€ Follow me on norbix.dev for more insights on Go, system design, and engineering wisdom.\n","permalink":"https://norbix.dev/posts/diagrams/","summary":"A quick reference guide to using Mermaid syntax for creating various types of diagrams, including flowcharts, graphs, and more.","title":"Diagrams: Mermaid Syntax Highlights"},{"content":"\u0026ldquo;High-level modules should not depend on low-level modules. Both should depend on abstractions.\u0026rdquo;\nWelcome to a core principle of software architecture: Dependency Inversion, the \u0026ldquo;D\u0026rdquo; in SOLID. In this article, weâ€™ll explore what it means in practice, how to implement it in Go using interfaces and dependency injection, and why itâ€™s essential for writing unit-testable code.\nğŸ§  What Is the Dependency Inversion Principle? The Dependency Inversion Principle (DIP) flips the traditional dependency model:\nâŒ Traditional: High-level business logic depends directly on low-level implementation (e.g., a database).\nâœ… DIP: Both layers depend on abstractions â€” usually in the form of interfaces.\nItâ€™s about reversing the direction of dependency to reduce coupling and improve flexibility.\nğŸ’¡ A Quick Example: Tightly Coupled Code 1 2 3 4 5 6 7 8 type OrderService struct { db *sql.DB } func (o *OrderService) Save(order Order) error { _, err := o.db.Exec(\u0026#34;INSERT INTO orders ...\u0026#34;) return err } This code:\nTightly couples OrderService to a concrete *sql.DB\nIs hard to test in isolation\nâœ… Refactor with Dependency Inversion Letâ€™s invert the dependency:\n1 2 3 4 5 6 7 8 9 10 11 type OrderRepository interface { Save(order Order) error } type OrderService struct { repo OrderRepository } func (o *OrderService) Save(order Order) error { return o.repo.Save(order) } Now:\nOrderService depends on an interface\nOrderRepository can be backed by a real DB in prod or a mock in tests\nğŸ› ï¸ Enter Dependency Injection Weâ€™ve inverted dependencies â€” now we need a way to supply them. Manual constructor injection in Go:\n1 2 3 func NewOrderService(repo OrderRepository) *OrderService { return \u0026amp;OrderService{repo: repo} } At runtime, inject the actual implementation:\n1 service := NewOrderService(NewPostgresOrderRepository(db)) ğŸ§ª Why This Rocks for Testing DIP + interfaces = test-friendly code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type MockOrderRepository struct { SavedOrder Order } func (m *MockOrderRepository) Save(order Order) error { m.SavedOrder = order return nil } func TestOrderService_Save(t *testing.T) { mock := \u0026amp;MockOrderRepository{} service := NewOrderService(mock) order := Order{ID: 42} err := service.Save(order) require.NoError(t, err) require.Equal(t, 42, mock.SavedOrder.ID) } Youâ€™ve isolated business logic from infrastructure â€” the holy grail of testability.\nğŸ”„ Summary DIP inverts traditional dependency direction: high-level modules depend on interfaces, not implementations.\nInterfaces define contracts at the boundaries.\nDependency Injection supplies those interfaces at runtime.\nUnit Testing becomes effortless when your logic isnâ€™t tangled up in database, network, or file system concerns.\nğŸ§­ When to Use DIP in Go âœ… When abstracting IO, storage, APIs, or 3rd party integrations\nâœ… When writing business logic you want to test independently\nâŒ Not needed for everything â€” Go prefers concrete, simple code unless you need indirection\nğŸš€ Follow me on norbix.dev for more insights on Go, system design, and engineering wisdom.\n","permalink":"https://norbix.dev/posts/dependency-inversion-principle/","summary":"A deep dive into the Dependency Inversion Principle, its implementation with interfaces and dependency injection, and how it unlocks clean, testable Go code.","title":"Breaking the Chain: Dependency Inversion, Interfaces, and Testable Go Code"},{"content":"Design patterns are reusable solutions to common problems in software design.\nThey provide a shared language for developers and encourage best practices in system architecture.\nIn this article, we\u0026rsquo;ll explore some of the most widely used design patterns in Go, grouped into three categories: creational, structural, and behavioral.\nğŸ”§ Creational Patterns ğŸ”‚ Singleton\nEnsures a class has only one instance and provides a global point of access to it.\nâ€œWhen discussing which pattern to drop, we found that we still love them all. (Not really â€” I\u0026rsquo;m in favor of dropping Singleton. Its use is almost always a design smell.)â€\nâ€” Erich Gamma, Design Patterns: Elements of Reusable Object-Oriented Software\nWhile Singleton often gets a bad reputation, there are still valid use cases in Go:\nâœ… You only want one component in the system (e.g., database repository, object factory) â³ The object is expensive to construct, so you instantiate it only once ğŸš« You want to prevent the creation of additional instances ğŸ’¤ You want lazy instantiation (e.g. load config or connect to DB only when needed) Go makes this easy and thread-safe with sync.Once. To stay testable and modular, follow the Dependency Inversion Principle (DIP) â€” depend on interfaces, not concrete types.\nHint:\nSingleton quite often breaks the Dependency Inversion Principle!\nğŸ§‘â€ğŸ’» Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package singleton import ( \u0026#34;sync\u0026#34; ) var ( instance *singleton once sync.Once ) type singleton struct{} func GetInstance() *singleton { once.Do(func() { instance = \u0026amp;singleton{} }) return instance } ğŸ§ª Usage\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;singleton\u0026#34; ) func main() { a := singleton.GetInstance() b := singleton.GetInstance() fmt.Println(a.Value) // Output: I am the only one // Confirm both variables point to the same instance fmt.Println(a == b) // Output: true } ğŸ­ Factory\nCreates objects without specifying the exact class.\nA factory helps simplify object creation when:\nğŸŒ€ Object creation logic becomes too convoluted ğŸ§± A struct has too many fields that need to be correctly initialized ğŸ’¡ You want to delegate creation logic away from the calling code There are two flavors of factories in Go:\nğŸ”§ Factory function (also called a constructor): a helper function to initialize struct instances ğŸ—ï¸ Factory struct: a dedicated struct responsible for managing object creation Unlike the Builder pattern, which is piecewise, the Factory creates the object wholesale â€” usually in one go.\nğŸ§‘â€ğŸ’» Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package factory type Shape interface { Draw() string } type Circle struct{} func (c Circle) Draw() string { return \u0026#34;Drawing Circle\u0026#34; } type Square struct{} func (s Square) Draw() string { return \u0026#34;Drawing Square\u0026#34; } func GetShape(shapeType string) Shape { switch shapeType { case \u0026#34;circle\u0026#34;: return Circle{} case \u0026#34;square\u0026#34;: return Square{} default: return nil } } ğŸ§ª Usage\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;factory\u0026#34; ) func main() { circle := factory.GetShape(\u0026#34;circle\u0026#34;) square := factory.GetShape(\u0026#34;square\u0026#34;) fmt.Println(circle.Draw()) // Output: Drawing Circle fmt.Println(square.Draw()) // Output: Drawing Square } ğŸ§± Builder\nSeparates the construction of a complex object from its representation.\nNot all objects are created equal:\nâœ… Some are simple and can be created with a single constructor call âš ï¸ Others require a lot of ceremony to set up ğŸ§© Factory functions with 10+ parameters become hard to use and maintain When you want more flexibility and readability, use the Builder pattern.\nğŸ› ï¸ A Builder is a separate component used to construct an object step-by-step ğŸ”„ It exposes a fluent API â€” each method returns the receiver (*Builder) to enable chaining ğŸ§  In advanced designs, different builders can operate on different facets of the same object ğŸ§‘â€ğŸ’» Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package builder type Car struct { Engine string Wheels int Color string } type CarBuilder struct { car Car } func (b *CarBuilder) SetEngine(engine string) *CarBuilder { b.car.Engine = engine return b } func (b *CarBuilder) SetWheels(wheels int) *CarBuilder { b.car.Wheels = wheels return b } func (b *CarBuilder) SetColor(color string) *CarBuilder { b.car.Color = color return b } func (b *CarBuilder) Build() Car { return b.car } ğŸ§ª Usage\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;builder\u0026#34; ) func main() { car := builder.CarBuilder{}. SetEngine(\u0026#34;V8\u0026#34;). SetWheels(4). SetColor(\u0026#34;Red\u0026#34;). Build() fmt.Printf(\u0026#34;%+v\\n\u0026#34;, car) // Output: {Engine:V8 Wheels:4 Color:Red} } ğŸ§© Structural Patterns 1.ğŸ”Œ Adapter\nAllows incompatible interfaces to work together.\nAn Adapter is a design construct that adapts an existing interface X to conform to the required interface Y. It acts as a translator or bridge between two systems that otherwise couldnâ€™t work together.\nğŸ§­ To implement an adapter in Go:\n- ğŸ” Determine the **API you have** (e.g. `Adaptee`) - ğŸ¯ Define the **API you need** (e.g. `Target`) - ğŸ§© Create an adapter struct that **aggregates** the adaptee (usually via a pointer) - âš¡ Optimize when needed â€” adapters may introduce intermediate representations, so use **caching** or other performance strategies as required This is especially useful when integrating legacy code or 3rd-party libraries into a new system with different interfaces.\nğŸ§‘â€ğŸ’» Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package adapter type Target interface { Request() string } type Adaptee struct{} func (a Adaptee) SpecificRequest() string { return \u0026#34;Specific behavior\u0026#34; } type Adapter struct { adaptee Adaptee } func (a Adapter) Request() string { return a.adaptee.SpecificRequest() } ğŸ§ª Usage\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;adapter\u0026#34; ) func main() { adaptee := adapter.Adaptee{} adapterInstance := adapter.Adapter{Adaptee: adaptee} var target adapter.Target = adapterInstance fmt.Println(target.Request()) // Output: Specific behavior } ğŸ€ Decorator\nAdds behavior to objects dynamically by embedding and extending existing functionality.\nThe Decorator pattern is used when you want to:\nâ• Augment an object with additional behavior ğŸš« Avoid modifying existing code (âœ… Open/Closed Principle â€” OCP) ğŸ§¼ Keep new functionality separate and modular (âœ… Single Responsibility Principle â€” SRP) ğŸ”„ Retain the ability to interact with existing interfaces The solution is to embed the decorated object and override or extend its behavior. This lets you build stackable, reusable enhancements without altering the base struct.\nğŸ§‘â€ğŸ’» Example: wrapping a basic Coffee with a MilkDecorator:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package decorator type Coffee interface { Cost() float64 } type SimpleCoffee struct{} func (s SimpleCoffee) Cost() float64 { return 2.0 } type MilkDecorator struct { Coffee } func (m MilkDecorator) Cost() float64 { return m.Coffee.Cost() + 0.5 } ğŸ§ª Usage\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;decorator\u0026#34; ) func main() { var coffee decorator.Coffee = decorator.SimpleCoffee{} fmt.Println(\u0026#34;Base cost:\u0026#34;, coffee.Cost()) // Output: 2.0 coffeeWithMilk := decorator.MilkDecorator{Coffee: coffee} fmt.Println(\u0026#34;With milk:\u0026#34;, coffeeWithMilk.Cost()) // Output: 2.5 } ğŸ›¡ Proxy\nProvides a surrogate or placeholder.\nğŸ§‘â€ğŸ’» Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package proxy type Image interface { Display() string } type RealImage struct { filename string } func (r RealImage) Display() string { return \u0026#34;Displaying \u0026#34; + r.filename } type ProxyImage struct { realImage *RealImage filename string } func (p *ProxyImage) Display() string { if p.realImage == nil { p.realImage = \u0026amp;RealImage{filename: p.filename} } return p.realImage.Display() } ğŸ§ª Usage\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;proxy\u0026#34; ) func main() { img := \u0026amp;proxy.ProxyImage{filename: \u0026#34;cat.png\u0026#34;} // The real image is not loaded yet fmt.Println(img.Display()) // Output: Displaying cat.png // The real image is reused without reloading fmt.Println(img.Display()) // Output: Displaying cat.png } ğŸŒ³ Composite\nComposes objects into tree structures. Composes objects into tree structures and lets you treat individual and composite objects uniformly.\nThe Composite pattern is ideal when some components are single objects (like files), and others are containers of other components (like folders). Both should support a common interface so clients donâ€™t need to differentiate between them.\nğŸ§­ To implement a composite in Go:\nğŸ§± Define a common interface that all components implement.\nğŸŒ¿ Implement Leaf objects (e.g. File, Button, TextField).\nğŸ§º Implement Composite objects (e.g. Folder, Panel) that aggregate children and delegate behavior to them.\nğŸ” Add iteration if you need to traverse or walk the tree (e.g. using the Iterator pattern).\nThis pattern shines when building hierarchical or nested structures such as UI components, file systems, or organization charts.\nğŸ§‘â€ğŸ’» Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package composite type Component interface { Operation() string } type Leaf struct { name string } func (l Leaf) Operation() string { return l.name } type Composite struct { children []Component } func (c *Composite) Add(child Component) { c.children = append(c.children, child) } func (c *Composite) Operation() string { result := \u0026#34;\u0026#34; for _, child := range c.children { result += child.Operation() + \u0026#34; \u0026#34; } return result } ğŸ“¦ Example usage:\n1 2 3 4 5 6 7 8 9 10 func main() { file1 := Leaf{name: \u0026#34;FileA.txt\u0026#34;} file2 := Leaf{name: \u0026#34;FileB.txt\u0026#34;} folder := \u0026amp;Composite{} folder.Add(file1) folder.Add(file2) fmt.Println(folder.Operation()) // Output: FileA.txt FileB.txt } âœ… When to use Composite:\nYou want to treat individual and group objects the same way You have recursive or nested structures You want to delegate behavior to child components ğŸ” Bonus: Pair with the Iterator pattern to walk tree structures cleanly without exposing their internal representation.\nğŸ§  Behavioral Patterns ğŸ§® Strategy\nDefines a family of algorithms.\nEncapsulates a family of algorithms and allows them to be selected and swapped at runtime.\nThe Strategy pattern is used when you want to:\nğŸ§  Separate an algorithm into its skeleton and implementation steps ğŸ§© Decompose behavior into high-level workflows and low-level operations ğŸ”„ Swap logic dynamically without changing the calling code âœ… Adhere to the Open/Closed Principle (OCP) â€” new strategies without changing the high-level logic The solution is to define a high-level algorithm that delegates part of its logic to an injected strategy. This strategy follows a shared interface, so any implementation can be plugged in without breaking the algorithm. ğŸµ Analogy: making a hot beverage\nMany real-world algorithms follow this structure. Take making tea as an example:\nSkeleton algorithm: Boil water â†’ Pour into cup â†’ Add ingredient Concrete implementation: Add tea bag, coffee grounds, or cocoa powder The high-level process is reusable, and the final step is delegated to a drink-specific strategy. This is exactly how Strategy works.\nğŸ§‘â€ğŸ’» Example: Choosing an operation strategy\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package strategy type Strategy interface { Execute(a, b int) int } type Add struct{} func (Add) Execute(a, b int) int { return a + b } type Multiply struct{} func (Multiply) Execute(a, b int) int { return a * b } type Context struct { strategy Strategy } func (c *Context) SetStrategy(s Strategy) { c.strategy = s } func (c Context) ExecuteStrategy(a, b int) int { return c.strategy.Execute(a, b) } ğŸ§ª Usage\n1 2 3 4 5 6 7 ctx := strategy.Context{} ctx.SetStrategy(strategy.Add{}) fmt.Println(ctx.ExecuteStrategy(3, 4)) // Output: 7 ctx.SetStrategy(strategy.Multiply{}) fmt.Println(ctx.ExecuteStrategy(3, 4)) // Output: 12 By:\nDefining a common interface (Strategy) Creating multiple concrete strategies (Add, Multiply) Supporting runtime injection into a reusable context (Context) You separate the structure of the algorithm from its implementation. Just like boiling water and pouring it into a cup â€” what happens next depends on the drink you\u0026rsquo;re making.\nThis makes your code modular, extensible, and easy to adapt to new behaviors without touching your existing flow.\nğŸ‘€ Observer\nWants to listen to events and be notified when something happens.\nThe Observer pattern is used when you want to:\nğŸ“£ Be informed when a particular object changes state, does something, or reacts to an external event ğŸ‘‚ Let other objects (observers) subscribe to and react to those changes ğŸ”„ Decouple the source of truth from those reacting to it âœ… Support dynamic subscription and unsubscription The solution is to have two participants:\nğŸŸ¢ Observable: emits events and holds a list of observers ğŸŸ¡ Observer: subscribes and reacts to events When the observable changes, it notifies all observers â€” sending event data (commonly as interface{} in Go) to each subscriber. This is an intrusive approach since the observable must provide explicit subscription management.\nğŸ§‘â€ğŸ’» Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package observer type Observer interface { Update(string) } type Subject interface { Attach(Observer) Notify() } type ConcreteSubject struct { observers []Observer state string } func (s *ConcreteSubject) Attach(o Observer) { s.observers = append(s.observers, o) } func (s *ConcreteSubject) SetState(state string) { s.state = state s.Notify() } func (s *ConcreteSubject) Notify() { for _, o := range s.observers { o.Update(s.state) } } type ConcreteObserver struct { id string } func (o ConcreteObserver) Update(state string) { println(\u0026#34;Observer\u0026#34;, o.id, \u0026#34;received new state:\u0026#34;, state) } ğŸ§ª Usage\n1 2 3 4 5 6 7 8 9 10 11 12 subject := \u0026amp;observer.ConcreteSubject{} observer1 := observer.ConcreteObserver{id: \u0026#34;A\u0026#34;} observer2 := observer.ConcreteObserver{id: \u0026#34;B\u0026#34;} subject.Attach(observer1) subject.Attach(observer2) subject.SetState(\u0026#34;ğŸš€ Launching\u0026#34;) // Output: // Observer A received new state: ğŸš€ Launching // Observer B received new state: ğŸš€ Launching With Observer, you give objects the ability to react automatically to changes elsewhere, without tightly coupling them together. This pattern is especially helpful for:\nUIs reacting to data changes Logging and monitoring Event-based systems Hint:\nThis approach is intrusive â€” the observable must explicitly support subscriptions and notify logic.\nğŸ” State\nAllows an object to alter its behavior when its internal state changes â€” effectively changing its class at runtime.\nThe State pattern is used when you want to:\nğŸ”„ Let an object change behavior dynamically based on its current state ğŸ“² Model real-world systems where actions depend on state ğŸ§  Manage complex state logic in a modular, maintainable way The solution is to encapsulate each state in its own type and let the context object delegate behavior to the current state. When the state changes, so does the object\u0026rsquo;s behavior â€” without conditionals scattered throughout the code.\nThese transitions are triggered by events (e.g. dialing, picking up, hanging up), and actions vary depending on the state. This is a perfect fit for a state machine â€” a formal model that defines:\nğŸ“¥ Entry/exit actions for each state ğŸ”„ Transitions between states, often triggered by events âœ… Guards that control whether a transition is allowed âš™ï¸ A default behavior if no transition is found When systems grow in complexity, it pays to define states and transitions explicitly to keep logic clean and modular.\nğŸ§‘â€ğŸ’» Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package state type State interface { Handle() string } type Context struct { state State } func (c *Context) SetState(s State) { c.state = s } func (c Context) Request() string { return c.state.Handle() } type OnState struct{} func (OnState) Handle() string { return \u0026#34;State is ON\u0026#34; } type OffState struct{} func (OffState) Handle() string { return \u0026#34;State is OFF\u0026#34; } ğŸ§ª Usage\n1 2 3 4 5 6 7 ctx := state.Context{} ctx.SetState(state.OnState{}) fmt.Println(ctx.Request()) // Output: State is ON ctx.SetState(state.OffState{}) fmt.Println(ctx.Request()) // Output: State is OFF With the State pattern:\nYou encapsulate each state and its logic in a separate type The object transitions explicitly in response to triggers Behavior is cleanly modular, without long chains of if or switch Whether you\u0026rsquo;re modeling a telephone, a TCP connection, or a video player, state machines help you handle transitions with clarity, flexibility, and control.\nâœ… Conclusion Design patterns are powerful tools in every Go developerâ€™s toolkit. While Go encourages simplicity, these patterns still applyâ€”especially in large-scale systems or when writing reusable libraries. Using patterns like Singleton, Adapter, and Strategy can lead to cleaner, more testable, and maintainable code.\nHappy Go coding! ğŸ¹\nğŸš€ Follow me on norbix.dev for more insights on Go, system design, and engineering wisdom.\n","permalink":"https://norbix.dev/posts/design-patterns/","summary":"Explore creational, structural, and behavioral design patterns in Go with clear explanations and code snippets.","title":"Design Patterns in Go: Practical Examples"},{"content":" ğŸ§  Mastering Data Structures and Algorithms (DSA) with Go Whether you\u0026rsquo;re preparing for technical interviews, optimizing backend systems, or simply sharpening your problem-solving chops, Data Structures and Algorithms (DSA) are foundational to your success as a developer.\nIn this article, Iâ€™ll walk you through core DSA concepts using Golang, a language praised for its simplicity, performance, and concurrency model. You\u0026rsquo;ll see how Go makes understanding DSA both intuitive and powerful.\nğŸš€ What is DSA? Data Structures organize and store data efficiently, while Algorithms define step-by-step instructions to solve problems or manipulate data.\nTogether, DSA provides the backbone for high-performance applications.\nğŸ“¦ Essential Data Structures in Go Arrays \u0026amp; Slices\n1 2 3 4 5 arr := [5]int{1, 2, 3, 4, 5} // Fixed-size array slice := []int{1, 2, 3} // Dynamic size slice = append(slice, 4) fmt.Println(slice) // [1 2 3 4] Slices are the idiomatic way to work with collections in Go. They offer flexibility while leveraging arrays under the hood.\nLinked List\nGo doesnâ€™t have a built-in linked list, but the container/list package provides one.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;container/list\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { l := list.New() l.PushBack(\u0026#34;Go\u0026#34;) l.PushBack(\u0026#34;DSA\u0026#34;) for e := l.Front(); e != nil; e = e.Next() { fmt.Println(e.Value) } } Stack (LIFO)\nA stack can be easily implemented using slices.\n1 2 3 4 5 6 7 8 9 10 11 12 type Stack []int func (s *Stack) Push(v int) { *s = append(*s, v) } func (s *Stack) Pop() int { n := len(*s) val := (*s)[n-1] *s = (*s)[:n-1] return val } Queue (FIFO)\nQueues can also be implemented using slices.\n1 2 3 4 5 6 7 8 9 10 11 type Queue []int func (q *Queue) Enqueue(v int) { *q = append(*q, v) } func (q *Queue) Dequeue() int { val := (*q)[0] *q = (*q)[1:] return val } Hash Map (Go's map)\n1 2 3 4 5 m := map[string]int{ \u0026#34;apple\u0026#34;: 5, \u0026#34;banana\u0026#34;: 3, } fmt.Println(m[\u0026#34;apple\u0026#34;]) // 5 Hint: Goâ€™s built-in map is a powerful hash table implementation for key-value pairs.\nğŸ§© Must-Know Algorithms in Go Binary Search\nEfficient O(log n) search on sorted arrays.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func binarySearch(arr []int, target int) int { low, high := 0, len(arr)-1 for low \u0026lt;= high { mid := (low + high) / 2 if arr[mid] == target { return mid } else if arr[mid] \u0026lt; target { low = mid + 1 } else { high = mid - 1 } } return -1 } Sorting (Bubble Sort Example)\n1 2 3 4 5 6 7 8 9 10 func bubbleSort(arr []int) { n := len(arr) for i := 0; i \u0026lt; n-1; i++ { for j := 0; j \u0026lt; n-i-1; j++ { if arr[j] \u0026gt; arr[j+1] { arr[j], arr[j+1] = arr[j+1], arr[j] } } } } For real projects, use Goâ€™s built-in sorting:\n1 sort.Ints(arr) Recursion: Factorial\n1 2 3 4 5 6 7 func factorial(n int) int { if n == 0 { return 1 } return n * factorial(n-1) } Graph and Trees\nFor binary trees, you define custom structures.\n1 2 3 4 5 type Node struct { Value int Left *Node Right *Node } Depth-first traversal:\n1 2 3 4 5 6 7 8 9 func dfs(n *Node) { if n == nil { return } fmt.Println(n.Value) dfs(n.Left) dfs(n.Right) } ğŸ§  Tips for Learning DSA with Go Practice problems: Use platforms like LeetCode, HackerRank, or Exercism. Understand time complexity: Know Big-O analysis for every structure and algorithm. Build mini-projects: Implement your own LRU Cache, Trie, or Priority Queue. ğŸ¯ Final Thoughts Mastering DSA not only sharpens your coding skills but also prepares you for systems design, performance optimization, and real-world problem-solving.\nWith Goâ€™s clean syntax and powerful standard library, you\u0026rsquo;re equipped to tackle DSA challenges efficiently and idiomatically.\nğŸš€ Follow me on norbix.dev for more insights on Go, system design, and engineering wisdom.\n","permalink":"https://norbix.dev/posts/algorithms-and-data-structures/","summary":"A deep dive into Data Structures and Algorithms (DSA) using Go, covering essential concepts, implementations, and best practices.","title":"DSA - Data Structures and Algorithms"},{"content":" ğŸ§  Graph Theory for Competitive Programming In competitive programming, few topics are as powerfulâ€”and sometimes intimidatingâ€”as graph theory. Whether itâ€™s shortest paths, connected components, or cycles, graphs appear everywhere from Google Maps to dependency resolution.\nIn this article, weâ€™ll explore the essential graph concepts, common problems, and Go (Golang) code snippets to help you handle any graph-based challenge on coding platforms like Codeforces, LeetCode, or AtCoder.\nğŸ•¸ï¸ What Is a Graph? A graph is a collection of nodes (vertices) and edges (connections between nodes). It can be:\nDirected or Undirected Weighted or Unweighted Connected or Disconnected Cyclic or Acyclic A simple undirected graph looks like:\ngraph TD A(1) -- 2 â†” 1 --\u0026gt; B(2) B -- 3 â†” 2 --\u0026gt; C(3) C -- 4 â†” 3 --\u0026gt; D(4) D -- 1 â†” 4 --\u0026gt; A In Go, we typically represent graphs using an adjacency list.\n1 2 3 4 5 6 graph := map[int][]int{ 1: {2, 4}, 2: {1, 3}, 3: {2, 4}, 4: {1, 3}, } ğŸ” DFS and BFS â€“ Graph Traversal Use DFS for problems involving backtracking, connected components, and cycle detection.\nUse BFS for shortest paths in unweighted graphs or level-order traversal\nDepth-First Search (DFS)\n1 2 3 4 5 6 7 8 9 10 11 func dfs(node int, visited map[int]bool, graph map[int][]int) { if visited[node] { return } visited[node] = true fmt.Println(node) for _, neighbor := range graph[node] { dfs(neighbor, visited, graph) } } Breadth-First Search (BFS)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func bfs(start int, graph map[int][]int) { visited := map[int]bool{} queue := []int{start} for len(queue) \u0026gt; 0 { node := queue[0] queue = queue[1:] if visited[node] { continue } visited[node] = true fmt.Println(node) for _, neighbor := range graph[node] { if !visited[neighbor] { queue = append(queue, neighbor) } } } } ğŸ”— Connected Components In an undirected graph, you can find connected components by running DFS from each unvisited node.\n1 2 3 4 5 6 7 8 9 10 11 12 func countComponents(graph map[int][]int, n int) int { visited := make(map[int]bool) count := 0 for i := 1; i \u0026lt;= n; i++ { if !visited[i] { dfs(i, visited, graph) count++ } } return count } â›“ï¸ Cycle Detection (Undirected Graph) DFS with parent tracking:\n1 2 3 4 5 6 7 8 9 10 11 12 13 func hasCycle(node, parent int, visited map[int]bool, graph map[int][]int) bool { visited[node] = true for _, neighbor := range graph[node] { if !visited[neighbor] { if hasCycle(neighbor, node, visited, graph) { return true } } else if neighbor != parent { return true } } return false } ğŸ“ Topological Sort (Directed Acyclic Graph) Used in task scheduling or course dependency problems.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func topologicalSort(graph map[int][]int, n int) []int { visited := make(map[int]bool) stack := []int{} var dfs func(int) dfs = func(node int) { visited[node] = true for _, neighbor := range graph[node] { if !visited[neighbor] { dfs(neighbor) } } stack = append(stack, node) } for i := 1; i \u0026lt;= n; i++ { if !visited[i] { dfs(i) } } // Reverse the stack for i, j := 0, len(stack)-1; i \u0026lt; j; i, j = i+1, j-1 { stack[i], stack[j] = stack[j], stack[i] } return stack } ğŸ›£ï¸ Dijkstraâ€™s Algorithm (Shortest Path) Used in weighted graphs with non-negative edges.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 type Item struct { node, dist int } func dijkstra(graph map[int][]Item, start int, n int) []int { const INF = int(1e9) dist := make([]int, n+1) for i := range dist { dist[i] = INF } dist[start] = 0 pq := \u0026amp;MinHeap{} heap.Init(pq) heap.Push(pq, Item{start, 0}) for pq.Len() \u0026gt; 0 { curr := heap.Pop(pq).(Item) if curr.dist \u0026gt; dist[curr.node] { continue } for _, neighbor := range graph[curr.node] { newDist := dist[curr.node] + neighbor.dist if newDist \u0026lt; dist[neighbor.node] { dist[neighbor.node] = newDist heap.Push(pq, Item{neighbor.node, newDist}) } } } return dist } Hint\nYouâ€™ll need a priority queue with container/heap.\nğŸ¯ Key Problem Patterns Problem Technique Find if a graph is connected DFS / BFS Shortest path (unweighted graph) BFS Shortest path (weighted graph) Dijkstraâ€™s All-pairs shortest paths Floyd-Warshall Topological sort DFS / Kahn\u0026rsquo;s Algo Cycle detection (undirected graph) DFS + parent Bipartite graph check BFS + coloring ğŸ§  Final Thoughts Graph problems may seem tough at first, but they become second nature with practice. Whether itâ€™s mapping networks, detecting cycles, or optimizing routes, graph theory is a core skill that unlocks deep algorithmic power.\nâœï¸ Practice Tip: Solve 10â€“15 problems covering DFS, BFS, topological sort, and shortest path. Then go deeper into Union-Find, Bridges, and Articulation Points.\nğŸš€ Follow me on norbix.dev for more insights on Go, system design, and engineering wisdom.\n","permalink":"https://norbix.dev/posts/graph-theory-algorithms-4-competitive-programming/","summary":"A comprehensive guide to graph theory algorithms in Go, covering essential concepts, implementations, and best practices for competitive programming.","title":"Graph Theory Algorithms 4 Competitive Programming"},{"content":" ğŸ§  Concurrency in Go: Goroutines, Channels, and Patterns Go was designed with concurrency as a first-class citizen. Unlike many other languages that bolt on concurrency, Go\u0026rsquo;s modelâ€”centered around goroutines and channelsâ€”is simple, elegant, and incredibly powerful.\nIn this article, weâ€™ll break down:\nWhat concurrency is in Go How goroutines and channels work Real-world concurrency patterns Code examples you can plug into your own projects ğŸš¦ Concurrency vs. Parallelism Concurrency is about managing multiple tasks at once. Parallelism is about doing multiple tasks simultaneously. Go lets you write concurrent code easily, and if your CPU allows, it can also run in parallel.\nğŸŒ€ Goroutines A goroutine is a lightweight thread managed by the Go runtime.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func sayHello() { fmt.Println(\u0026#34;Hello from goroutine!\u0026#34;) } func main() { go sayHello() // runs concurrently time.Sleep(time.Second) fmt.Println(\u0026#34;Main finished.\u0026#34;) } go sayHello() starts the function in the background.\nâš ï¸ Without time.Sleep, the main function may exit before the goroutine finishes.\nğŸ“¡ Channels Channels allow goroutines to communicate safely.\n1 2 3 4 5 6 7 8 ch := make(chan string) go func() { ch \u0026lt;- \u0026#34;ping\u0026#34; }() msg := \u0026lt;-ch fmt.Println(msg) // prints: ping chan T is a channel of type T \u0026lt;-ch receives ch \u0026lt;- sends ğŸ”„ Buffered Channels Buffered channels donâ€™t block until full.\n1 2 3 4 5 6 ch := make(chan int, 2) ch \u0026lt;- 1 ch \u0026lt;- 2 fmt.Println(\u0026lt;-ch) fmt.Println(\u0026lt;-ch) âŒ Closing Channels You can close a channel to indicate no more values will be sent.\n1 2 3 4 5 6 7 8 9 10 11 ch := make(chan int) go func() { for i := 0; i \u0026lt; 3; i++ { ch \u0026lt;- i } close(ch) }() for val := range ch { fmt.Println(val) } ğŸ§± Select Statement select lets you wait on multiple channel operations.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ch1 := make(chan string) ch2 := make(chan string) go func() { time.Sleep(1 * time.Second) ch1 \u0026lt;- \u0026#34;one\u0026#34; }() go func() { time.Sleep(2 * time.Second) ch2 \u0026lt;- \u0026#34;two\u0026#34; }() select { case msg1 := \u0026lt;-ch1: fmt.Println(\u0026#34;Received\u0026#34;, msg1) case msg2 := \u0026lt;-ch2: fmt.Println(\u0026#34;Received\u0026#34;, msg2) } ğŸ› ï¸ Concurrency Patterns Fan-Out / Fan-In\nFan-Out: Multiple goroutines read from the same channel.\nFan-In: Multiple goroutines send into a single channel.\n1 2 3 4 5 6 7 8 func worker(id int, jobs \u0026lt;-chan int, results chan\u0026lt;- int) { for j := range jobs { fmt.Printf(\u0026#34;Worker %d processing job %d\\n\u0026#34;, id, j) time.Sleep(time.Second) results \u0026lt;- j * 2 } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func main() { jobs := make(chan int, 5) results := make(chan int, 5) for w := 1; w \u0026lt;= 3; w++ { go worker(w, jobs, results) } for j := 1; j \u0026lt;= 5; j++ { jobs \u0026lt;- j } close(jobs) for a := 1; a \u0026lt;= 5; a++ { fmt.Println(\u0026#34;Result:\u0026#34;, \u0026lt;-results) } } Worker Pool\nYou can create a pool of workers that handle jobs concurrently with limited resources.\nâœ… Use buffered channels and sync.WaitGroup for coordination.\nTimeout with select\n1 2 3 4 5 6 7 8 9 10 11 12 13 c := make(chan string) go func() { time.Sleep(2 * time.Second) c \u0026lt;- \u0026#34;done\u0026#34; }() select { case res := \u0026lt;-c: fmt.Println(res) case \u0026lt;-time.After(1 * time.Second): fmt.Println(\u0026#34;timeout\u0026#34;) } âš–ï¸ sync.WaitGroup Use it to wait for all goroutines to finish.\n1 2 3 4 5 6 7 8 9 10 11 12 var wg sync.WaitGroup for i := 0; i \u0026lt; 3; i++ { wg.Add(1) go func(id int) { defer wg.Done() fmt.Printf(\u0026#34;Worker %d done\\n\u0026#34;, id) }(i) } wg.Wait() fmt.Println(\u0026#34;All workers finished.\u0026#34;) ğŸ§  Final Thoughts Go makes concurrency not only powerfulâ€”but approachable. You don\u0026rsquo;t need threads or semaphores to build safe, concurrent systems. âœ… Key Takeaways:\nUse goroutines for lightweight concurrency. Use channels for safe communication. Master select, worker pools, and timeouts for production-grade patterns. ğŸš€ Follow me on norbix.dev for more insights on Go, system design, and engineering wisdom.\n","permalink":"https://norbix.dev/posts/concurrency-in-go/","summary":"A deep dive into concurrency in Go, covering goroutines, channels, and real-world patterns.","title":"Concurrency in Go"},{"content":" \u0026ldquo;Fast code isnâ€™t always good code â€” but slow code is always bad code when it scales.\u0026rdquo;\nIn this article, weâ€™ll explore Big-O from first principles, map it to practical code examples (in Go), and cover the performance implications that can make or break your system at scale.\nğŸš€ What Is Big-O Notation? Big-O notation is a mathematical shorthand to describe how the runtime or space requirements of an algorithm grow relative to input size.\nIt doesn\u0026rsquo;t give exact timings â€” instead, it describes the upper bound of complexity, helping us compare algorithms independent of hardware or compiler optimizations.\nThink of Big-O as a lens to understand the scalability of your code.\nğŸ’¡ Why Software Engineers Should Care Letâ€™s say your app runs fine in staging. But once it hits 100k+ users in production, it slows to a crawl. The culprit? A nested loop you wrote that unknowingly behaves like O(nÂ²).\nUnderstanding Big-O helps you:\nWrite code that scales\nChoose efficient data structures (e.g., maps vs lists)\nMake better architectural trade-offs (e.g., caching, sharding, indexing)\nPass system design interviews with confidence\nğŸ“ˆ Common Big-O Complexities\nBig-0 Name Example Scenario\nBig-0 Name Example Scenario O(1) Constant Time Hash table lookup: map[\u0026quot;key\u0026quot;] in Go O(log n) Logarithmic Time Binary search in a sorted array O(n) Linear Time Looping through an array O(n log n) Linearithmic Time Merge sort or quicksort O(nÂ²) Quadratic Time Nested loops over an array O(2^n) Exponential Time Recursive Fibonacci calculation ğŸ§ª Go Code Examples O(1) â€” Constant Time 1 2 m := map[string]int{\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2} val := m[\u0026#34;b\u0026#34;] // Always takes constant time O(n) â€” Linear Time 1 2 3 for _, v := range nums { fmt.Println(v) } O(nÂ²) â€” Quadratic Time 1 2 3 4 5 6 7 for i := range nums { for j := range nums { if nums[i] == nums[j] { fmt.Println(\u0026#34;Duplicate found\u0026#34;) } } } ğŸ’¾ Space Complexity Itâ€™s not just about time. Some algorithms use more memory to gain speed.\nExample: Merge sort has O(n log n) time but O(n) space due to temporary arrays.\nğŸ§  When Big-O Isnâ€™t Everything Big-O tells you how your code scales â€” not how it performs right now. A poorly written O(n) function can still be slower than a well-optimized O(nÂ²) one for small datasets.\nUse profilers and benchmarks to measure real performance. Use Big-O to think about growth.\nğŸ”§ Pro Tips Map performance bottlenecks to algorithmic complexity.\nChoose the right data structure: prefer map (O(1)) over slice lookup (O(n)).\nCache expensive operations if you canâ€™t improve complexity.\nRead standard library code â€” it often uses optimal algorithms under the hood.\nOptimize only when necessary â€” premature optimization is still a trap.\nğŸ§­ Summary Big-O notation is your guide to writing code that doesnâ€™t just work â€” it scales.\nWhether youâ€™re building a high-throughput API, wrangling large datasets, or preparing for interviews, understanding Big-O will help you make better, more informed decisions about how your code behaves as your system grows.\nğŸš€ Follow me on norbix.dev for more insights on Go, system design, and engineering wisdom.\n","permalink":"https://norbix.dev/posts/big-o-notation/","summary":"Understand Big-O notation through real-world Go examples and discover how algorithmic complexity impacts code scalability, performance, and design choices.","title":"Demystifying Big-O Notation in Software Engineering"},{"content":" \u0026ldquo;Code never lies. Comments sometimes do. Logs often scream.\u0026rdquo;\nDebugging is a core skill for any Go developer. Whether you\u0026rsquo;re fixing a crashing service, tracking down performance bottlenecks, or just figuring out what your code is actually doing, knowing how to debug effectively can save hours of pain.\nIn this article, I\u0026rsquo;ll explore practical debugging techniques in Go, the role of Delve (Go\u0026rsquo;s debugger), and how modern IDEs like VSCode and IntelliJ IDEA (GoLand) can make your life easier.\nğŸ§  Start With the Basics: Logging and Println The oldest (and still very effective) debugging technique: adding fmt.Println() or log.Printf() statements. While not fancy, it can be fast and powerful, especially for quick investigations or local development.\nğŸ”¥ Tip: Use structured logging (log/slog, zap, zerolog) for real-world debugging â€” especially in distributed systems.\nğŸ› ï¸ Delve: The Go Debugger Delve is the official debugger for Go. It allows you to:\nSet breakpoints\nStep through code (step in, over, out)\nInspect variables and stack frames\nEvaluate expressions at runtime\nğŸ“¦ Install Delve 1 go install github.com/go-delve/delve/cmd/dlv@latest ğŸ” Basic Usage (CLI) 1 2 3 4 dlv debug \u0026gt; break main.go:42 \u0026gt; continue \u0026gt; print someVar Use dlv test to debug test functions interactively.\nğŸ–¥ï¸ Debugging in Visual Studio Code VSCode with the Go extension by the Go team supports Delve under the hood.\nâœ… Features: Interactive breakpoints\nVariable watches\nStep-by-step execution\nDebug test files directly\nâš™ï¸ Quick Setup: Install the Go extension.\nAdd a .vscode/launch.json file:\n1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Launch Main\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;go\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;mode\u0026#34;: \u0026#34;debug\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/main.go\u0026#34; } ] } Hit F5 or click the debug icon.\nğŸ§  Debugging in IntelliJ IDEA / GoLand JetBrainsâ€™ GoLand or the Go plugin for IntelliJ IDEA Ultimate offers a premium Go debugging experience.\nâœ… Features: Visual breakpoints with conditions\nInline variable values\nGoroutine inspection\nSmart watches and expression evaluation\nğŸš€ How to Use: Set breakpoints in the left margin\nRight-click your Go file â†’ Debug\nUse the debug tool window to inspect state\nğŸ’¡ GoLand integrates with dlv and offers a rich UI on top of it.\nğŸ§ª Debugging Tests Both VSCode and GoLand support debugging test cases individually.\nVSCode: Right-click TestXxx â†’ Debug Test\nGoLand: Click the green bug icon next to the test function\nAdd t.Log() and use -v for more visibility.\nğŸ“ˆ Advanced Techniques pprof: Profile CPU, memory, goroutines, and more\ntrace: Detailed execution traces for concurrency issues\npanic stack traces: Analyze logs to trace the root of panics\nrace detector: Run with go run -race or go test -race\nğŸ” Summary Use fmt.Println() and logging for quick insights\nLearn Delve â€” it\u0026rsquo;s your best friend in deep debugging\nLeverage IDEs like VSCode or GoLand for full-featured debugging\nDon\u0026rsquo;t forget Goâ€™s built-in tools like pprof, trace, and the race detector\nHappy debugging â€” may your bugs be shallow and your stack traces meaningful ğŸ\nğŸš€ Follow me on norbix.dev for more insights on Go, system design, and engineering wisdom.\n","permalink":"https://norbix.dev/posts/debugging/","summary":"Learn effective debugging techniques for Go code using tools like Delve, and how to leverage modern IDEs such as VSCode and IntelliJ IDEA for faster diagnosis and fixes.","title":"Debugging Go Code: Techniques, Tools, and IDE Support"},{"content":" \u0026ldquo;Fast is fine, but profiling tells you why you\u0026rsquo;re slow.\u0026rdquo;\nPerformance issues are often hard to debug â€” your app feels sluggish, CPU spikes randomly, or memory usage keeps growing. Fortunately, Go provides powerful built-in tools to profile applications and uncover these bottlenecks.\nIn this article, I\u0026rsquo;ll walk through profiling techniques in Go, focusing on CPU, memory, goroutine, and concurrency analysis using tools like pprof and trace.\nğŸ” What Is Profiling? Profiling is the act of measuring the performance characteristics of your application:\nWhere is the CPU time being spent?\nHow much memory is being allocated?\nAre goroutines being leaked?\nIs concurrency causing contention?\nGoâ€™s standard library includes everything you need to answer these questions.\nâš™ï¸ net/http/pprof: Built-in Profiler The simplest way to expose profiling data is to import:\n1 import _ \u0026#34;net/http/pprof\u0026#34; Add this to your HTTP server:\n1 http.ListenAndServe(\u0026#34;localhost:6060\u0026#34;, nil) Then, access these endpoints:\n/debug/pprof/profile â€” CPU profile\n/debug/pprof/heap â€” memory profile\n/debug/pprof/goroutine â€” goroutine dump\nğŸ§  CPU Profiling Generate a CPU profile:\n1 curl http://localhost:6060/debug/pprof/profile?seconds=30 \u0026gt; cpu.prof Analyze it with:\n1 2 3 go tool pprof cpu.prof (pprof) top (pprof) web **web opens a flame graph (requires Graphviz) **\nğŸ§  Memory Profiling Generate a heap profile:\n1 curl http://localhost:6060/debug/pprof/heap \u0026gt; heap.prof Look for high allocation counts and large retained objects.\nUse pprof -alloc_objects, -inuse_space to slice the data differently.\nğŸ§µ Goroutines and Blocking Dump goroutines:\n1 curl http://localhost:6060/debug/pprof/goroutine?debug=2 Find out if:\nGoroutines are leaking\nSomething is blocking channels or mutexes\nâš¡ Execution Tracing Go also supports full execution traces:\n1 import \u0026#34;runtime/trace\u0026#34; Wrap your code:\n1 2 3 f, _ := os.Create(\u0026#34;trace.out\u0026#34;) runtime/trace.Start(f) defer trace.Stop() Then run:\n1 go tool trace trace.out Use this to spot scheduling delays, GC pauses, network latency, etc.\nğŸ§ª Benchmarking + Profiling You can combine unit tests and profiling:\n1 2 3 4 5 func BenchmarkXxx(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { MyFunction() } } Run with profiling:\n1 go test -bench=. -cpuprofile=cpu.prof -memprofile=mem.prof ğŸ› ï¸ Real-World Tips Profile in production with real workloads when possible\nUse flame graphs to spot hot loops and recursive calls\nCompare snapshots before and after changes\nCombine pprof with metrics (Prometheus, Grafana)\nğŸ§­ Summary Profiling Go applications is straightforward but incredibly powerful:\nUse pprof for CPU, memory, and goroutines\nUse trace for low-level runtime behavior\nBenchmark with go test to validate changes\nProfile before you optimize â€” measure twice, cut once.\nğŸš€ Follow me on norbix.dev for more insights on Go, system design, and engineering wisdom.\n","permalink":"https://norbix.dev/posts/profiling/","summary":"Learn how to profile Go applications using pprof, trace, and runtime tools to uncover bottlenecks, memory leaks, and concurrency issues in production and development.","title":"Profiling Go Applications: CPU, Memory, and Concurrency Insights"},{"content":" \u0026ldquo;If it hurts, do it more often.\u0026rdquo;\nThat provocative quote lies at the heart of Extreme Programming (XP) â€” an Agile software development methodology focused on frequent releases, tight feedback loops, and engineering excellence.\nXP turns the dial up to 11. It takes software best practices â€” like testing, iteration, and customer feedback â€” and applies them more frequently, more consistently, and more rigorously.\nğŸ§­ What Is Extreme Programming (XP)? XP is an Agile methodology created by Kent Beck in the late 1990s while working at Chrysler. It emphasizes communication, simplicity, feedback, courage, and respect, and it thrives in environments where requirements are constantly changing.\nThe core idea: deliver software in small, frequent iterations, with feedback guiding every step.\nğŸ”‘ XP Core Practices XP is built on a set of interconnected practices that reinforce one another:\nâœ… Test-Driven Development (TDD) Write tests before writing code. This leads to better design, faster feedback, and fewer regressions.\nğŸ‘¯â€â™‚ï¸ Pair Programming Two developers, one keyboard. One writes, one reviews â€” in real time. It boosts code quality and knowledge sharing.\nğŸ” Continuous Integration Integrate and test code frequently (many times a day). This minimizes merge conflicts and surfaces bugs early.\nğŸ“ User Stories Capture requirements as short, customer-centric narratives. Keep them simple, estimable, and testable.\nğŸ§ª Acceptance Testing Automated tests define when a feature is done from a userâ€™s point of view.\nâ±ï¸ Short Iterations Work in 1â€“2 week cycles with regular planning, feedback, and retrospectives.\nğŸ™‹ On-site Customer Have a real user or domain expert embedded with the team to answer questions and guide priorities.\nğŸ’¡ XP Values Communication â€” Constant collaboration between team members.\nSimplicity â€” Do the simplest thing that could possibly work.\nFeedback â€” Fast feedback from tests, peers, and users.\nCourage â€” Refactor aggressively, delete dead code, and speak up.\nRespect â€” Build trust and treat all roles with dignity.\nğŸš€ Why XP Works (Especially in Startups and Scale-Ups) XP excels in environments that are:\nFast-paced and evolving\nRich in collaboration\nDriven by user needs\nIts tight feedback loops and focus on simplicity mean you get working software quickly â€” and keep improving it.\nXP isnâ€™t just about speed. Itâ€™s about sustainable speed with quality.\nğŸ¤” XP vs Scrum vs Kanban Feature XP Scrum Kanban Iteration Length 1â€“2 weeks 2â€“4 weeks Continuous Focus Engineering practices Roles and ceremonies Flow \u0026amp; WIP limits Testing TDD, CI, automation Optional Optional Customer Involvement Daily of possible Product Owner Varies XP is the most engineering-heavy of the Agile methodologies.\nğŸ› ï¸ Tools That Support XP Version Control: Git, GitHub, GitLab\nCI/CD: GitHub Actions, Jenkins, CircleCI\nTesting: Go test, JUnit, Cypress, Playwright\nPairing: Tuple, Visual Studio Live Share, JetBrains Code With Me\nPlanning: Jira, Trello, Linear (for user stories)\nğŸ“Œ Final Thoughts Extreme Programming pushes your team to build better software faster, but not recklessly. It demands discipline, tests, pairing, and constant communication. Done well, XP leads to confident releases and a healthy, high-trust team culture.\nğŸš€ Follow me on norbix.dev for more insights on Go, system design, and engineering wisdom.\n","permalink":"https://norbix.dev/posts/extreme-programming/","summary":"What is Extreme Programming (XP)? Explore its core practices, values, and how it helps teams deliver high-quality software with speed, feedback, and sustainability.","title":"Extreme Programming (XP): Engineering Excellence on Speed"},{"content":" ğŸš€ DevOps Deployment: Dockerize and Deploy a 3-Tier App with Helm on Kubernetes As modern applications evolve, DevOps workflows bridge the gap between development and operations. In this post, weâ€™ll walk through how to Dockerize a 3-tier web applicationâ€”consisting of a frontend, backend, and PostgreSQL databaseâ€”and deploy it to a Kubernetes cluster using a custom Helm chart.\nYouâ€™ll learn:\nHow to structure a 3-tier app for containerization Dockerfile tips for Go-based services Kubernetes deployment best practices How to create a reusable Helm chart for real-world deployments ğŸ§± 3-Tier Architecture Overview We\u0026rsquo;ll build and deploy the following:\nFrontend â€“ a static site (React, Vue, or Hugo) Backend â€“ a Go HTTP API Database â€“ PostgreSQL graph TD client[Browser] client --\u0026gt; nginx[Frontend Nginx] nginx --\u0026gt; goapi[Backend Go App] goapi --\u0026gt; pg[PostgreSQL DB] ğŸ“¦ Step 1: Dockerize Each Tier ğŸ”¹ Frontend Dockerfile (e.g., Hugo + Nginx) 1 2 3 4 5 6 7 8 9 # Stage 1 â€“ Build Hugo site FROM klakegg/hugo:0.120.0-ext AS builder WORKDIR /app COPY . . RUN hugo # Stage 2 â€“ Serve with Nginx FROM nginx:alpine COPY --from=builder /app/public /usr/share/nginx/html ğŸ”¹ Backend Dockerfile (Go API) 1 2 3 4 5 6 7 8 9 10 11 # Stage 1 â€“ Build FROM golang:1.21 AS builder WORKDIR /app COPY . . RUN go build -o server . # Stage 2 â€“ Run FROM alpine COPY --from=builder /app/server /server EXPOSE 8080 ENTRYPOINT [\u0026#34;/server\u0026#34;] ğŸ”¹ PostgreSQL (Official Image) No Dockerfile needed, just reference postgres:15-alpine in your docker-compose.yml or Kubernetes deployment.\nğŸ§ª Step 2: Local Testing with Docker Compose Use Compose to test locally before pushing to Kubernetes:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 version: \u0026#39;3.9\u0026#39; services: frontend: build: ./frontend ports: [ \u0026#34;80:80\u0026#34; ] depends_on: [ backend ] backend: build: ./backend ports: [ \u0026#34;8080:8080\u0026#34; ] environment: DB_HOST: postgres depends_on: [ postgres ] postgres: image: postgres:15-alpine environment: POSTGRES_DB: app POSTGRES_USER: user POSTGRES_PASSWORD: pass volumes: - dbdata:/var/lib/postgresql/data volumes: dbdata: âœ… Once confirmed working, you\u0026rsquo;re ready for the cluster.\nâ˜¸ï¸ Step 3: Prepare Kubernetes Manifests Break deployments into individual resources: Deployment, Service, ConfigMap, and Secret. Then, template them using Helm.\nğŸ“¦ Step 4: Create a Custom Helm Chart 1 helm create myapp This generates:\n1 2 3 4 5 6 7 8 9 10 myapp/ â”œâ”€â”€ charts/ â”œâ”€â”€ templates/ â”‚ â”œâ”€â”€ frontend-deployment.yaml â”‚ â”œâ”€â”€ backend-deployment.yaml â”‚ â”œâ”€â”€ postgres-deployment.yaml â”‚ â”œâ”€â”€ _helpers.tpl â”‚ â”œâ”€â”€ service.yaml â”‚ â””â”€â”€ ingress.yaml â”œâ”€â”€ values.yaml Example: frontend-deployment.yaml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 apiVersion: apps/v1 kind: Deployment metadata: name: {{ .Release.Name }}-frontend spec: replicas: 1 selector: matchLabels: app: {{ .Release.Name }}-frontend template: metadata: labels: app: {{ .Release.Name }}-frontend spec: containers: - name: frontend image: \u0026#34;{{ .Values.frontend.image.repository }}:{{ .Values.frontend.image.tag }}\u0026#34; ports: - containerPort: 80 Example: values.yaml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 frontend: image: repository: myregistry/frontend tag: \u0026#34;latest\u0026#34; backend: image: repository: myregistry/backend tag: \u0026#34;latest\u0026#34; postgres: image: repository: postgres tag: \u0026#34;15-alpine\u0026#34; env: POSTGRES_DB: app POSTGRES_USER: user POSTGRES_PASSWORD: pass ğŸš¢ Step 5: Deploy to Kubernetes 1 helm install myapp ./myapp --namespace my-namespace --create-namespace Need to update?\n1 helm upgrade myapp ./myapp ğŸ§¹ Cleanup 1 2 helm uninstall myapp --namespace my-namespace kubectl delete namespace my-namespace ğŸ¯ Final Thoughts By combining Docker, Kubernetes, and Helm, you get:\nA repeatable deployment pipeline Configurable environments per stage (via Helm) Easy rollbacks and upgrades Helm lets you treat infrastructure like codeâ€”enabling DevOps best practices like versioning, templating, and CI/CD automation.\nğŸš€ Follow me on norbix.dev for more insights on Go, system design, and engineering wisdom.\n","permalink":"https://norbix.dev/posts/devops-deployment/","summary":"A comprehensive guide to deploying a 3-tier application using Docker, Kubernetes, and Helm.","title":"DevOps Deployment"},{"content":" \u0026ldquo;Hope is not a strategy. Reliability is engineered.\u0026rdquo;\nWelcome to the world of Site Reliability Engineering (SRE) â€” where software engineering meets operations to ensure systems are not just functional, but reliably scalable and observable. In this article, weâ€™ll break down what SRE is, how it goes beyond observability, and how you can apply its principles to build resilient systems.\nğŸ” What is SRE? SRE is an engineering discipline developed at Google to help manage large-scale services. It applies software engineering principles to operations work with the goal of creating ultra-reliable systems.\nThink of it as treating ops like a feature: design, build, measure, and improve it continuously.\nğŸ§± Core Pillars of SRE ğŸ¯ SLIs, SLOs, and Error Budgets SLIs (Service Level Indicators): Quantitative metrics like latency, availability, and throughput.\nSLOs (Service Level Objectives): Targets for SLIs (e.g., 99.9% availability).\nError Budgets: The allowable threshold for failure within an SLO. When exceeded, itâ€™s a signal to slow down releases and fix reliability issues.\nSRE accepts failure â€” but it quantifies and manages it.\nğŸ¤– Eliminating Toil Through Automation Toil is manual, repetitive, and automatable work that doesnâ€™t scale. SREs aim to automate:\nDeployments\nOn-call tasks\nMonitoring setups\nCapacity planning\nThe golden rule: No one should be on-call for something a script can handle.\nğŸ›°ï¸ Observability: Beyond Monitoring Monitoring tells you when somethingâ€™s wrong. Observability helps you understand why.\nSRE builds robust observability through:\nMetrics (Prometheus, Grafana)\nLogs (ELK, Loki)\nTraces (Jaeger, OpenTelemetry)\n\u0026ldquo;If you canâ€™t explain your system by looking at its output, youâ€™re flying blind.\u0026rdquo;\nğŸ§¯ Incident Response \u0026amp; Blameless Postmortems When things break, SREs:\nDetect fast Respond methodically Restore quickly Then they write blameless postmortems to:\nDocument the incident Share learnings Prevent recurrence Focus on fixing systems, not assigning blame.\nğŸš¦ Change Management \u0026amp; Safe Releases Shipping code safely is core to SRE. This includes:\nCI/CD pipelines Canary deployments Feature flags Rollbacks Reliability isnâ€™t just about uptime â€” itâ€™s about safe change velocity.\nğŸ¤ SRE vs DevOps DevOps is a culture. SRE is an implementation.\nDevOps says \u0026ldquo;Developers and Ops should collaborate.\u0026rdquo; SRE says \u0026ldquo;Hereâ€™s the engineering playbook to do that.\u0026rdquo; DevOps is the philosophy. SRE is the practice.\nğŸ› ï¸ Getting Started with SRE in Your Org Hereâ€™s a roadmap to start adopting SRE practices:\nDefine critical SLIs \u0026amp; SLOs.\nSet up observability tools (logs, metrics, traces).\nTrack error budgets.\nAutomate repetitive ops work.\nEstablish incident response playbooks.\nCreate a culture of blameless learning.\nğŸ§­ When SRE Makes Sense âœ… Youâ€™re managing systems at scale âœ… Your team suffers from alert fatigue âœ… Deployments are risky and painful âœ… Incidents lack structured response Not every team needs a dedicated SRE, but every team can benefit from thinking like one.\nğŸ“Œ Final Thoughts SRE isnâ€™t just about observability or uptime â€” itâ€™s a way to build and operate systems with reliability as a first-class concern. Whether you\u0026rsquo;re scaling a startup or taming legacy systems, embracing SRE principles will help you ship faster, sleep better, and build trust with users.\nğŸš€ Follow me on norbix.dev for more insights on Go, system design, and engineering wisdom.\n","permalink":"https://norbix.dev/posts/site-reliability-engineering/","summary":"An in-depth look into Site Reliability Engineering (SRE): its core principles, how it\u0026rsquo;s different from DevOps, and how teams can adopt SRE to build reliable, scalable systems.","title":"Engineering for Reliability: What SRE Is Really About"},{"content":" \u0026ldquo;Great platforms donâ€™t abstract power. They enable it.\u0026rdquo;\nYouâ€™ve probably heard the term Platform Engineering thrown around. But is it just rebranded DevOps? Is it SRE with a cooler name? Or cloud automation with some swagger?\nLetâ€™s set the record straight â€” and show why platform engineering is becoming the backbone of modern engineering organizations.\nğŸš€ What Is Platform Engineering? Platform Engineering is the discipline of designing, building, and maintaining internal platforms that streamline and scale software delivery. It brings together principles from DevOps, SRE, and cloud engineering into a cohesive, developer-friendly toolkit.\nThink of it as building \u0026ldquo;paved roads\u0026rdquo; that teams can confidently deploy on â€” without needing to reinvent infrastructure, pipelines, or observability every time.\nThe end goal? Enable dev teams to ship faster and safer â€” without needing to be Kubernetes, Terraform, or AWS experts.\nğŸ§± What Goes Into a Platform? Platform engineers often build and maintain:\nğŸ—ï¸ Internal Developer Platforms (IDPs): Self-service interfaces and APIs for provisioning, deploying, and managing services e.g. container8.io.\nğŸ” CI/CD Pipelines: Standardized, reusable workflows for testing and deploying code.\nâ˜ï¸ Infrastructure as Code (IaC): Terraform, Pulumi, Crossplane, etc.\nğŸ” Observability Tools: Centralized logging, metrics, and tracing integrations.\nğŸ”’ Security and Compliance Controls: Guardrails, not roadblocks.\nğŸ§© How It Relates to DevOps, SRE, and Cloud DevOps âœ… DevOps is a culture of collaboration and automation.\nPlatform engineering productizes DevOps by building internal tools and workflows that developers can actually use.\nSRE âœ… SRE focuses on reliability, automation, and incident response.\nPlatform teams embed SRE principles into the platform: error budgets, golden signals, runbooks.\nCloud Engineering âœ… Cloud engineering provides the infrastructure foundation.\nPlatform engineers abstract that complexity into reusable modules and templates.\nPlatform Engineering = DevOps + SRE + Cloud + DX (Developer Experience)\nğŸ§  Why Platform Engineering Matters In complex environments â€” multiple teams, microservices, polyglot stacks â€” platform engineering provides:\nğŸ”„ Consistency: Standardized pipelines and infra reduce cognitive load.\nğŸ§ª Safety: Guardrails prevent footguns and accelerate onboarding.\nğŸ› ï¸ Developer Enablement: Engineers focus on features, not YAML.\nâš–ï¸ Scalability: Platforms scale better than hero engineers.\nGreat platform teams act like product teams: listen to users, iterate fast, and deliver value continuously.\nğŸ›¤ï¸ Golden Paths: The Secret Sauce Platform engineering isnâ€™t just about tools â€” itâ€™s about opinionated defaults. The best platforms offer \u0026ldquo;golden paths\u0026rdquo;:\nRecommended ways to build, test, and deploy apps\nTemplates for services, jobs, infrastructure\nStandardized observability and alerting\nGive devs superpowers â€” not blank canvases.\nğŸ“¦ Tools of the Trade Some common tools and patterns used by platform teams:\nIaC: Terraform, Pulumi, CDK\nCI/CD: GitHub Actions, ArgoCD, Tekton, Spinnaker\nContainers \u0026amp; K8s: Helm, Crossplane, Kubernetes Operators\nDeveloper Portals: Backstage, Port, Humanitec\nObservability: Prometheus, Grafana, OpenTelemetry\nğŸ’¬ Final Thoughts Platform Engineering is not a fad. Itâ€™s a response to real-world complexity at scale. As orgs grow, they need paved roads, not paved-over tickets.\nThe future of software delivery is internal platforms that combine speed, reliability, and safety â€” all with a developer-first mindset.\nğŸš€ Follow me on norbix.dev for more insights on Go, system design, and engineering wisdom.\n","permalink":"https://norbix.dev/posts/platform-engineering/","summary":"What is Platform Engineering? How is it different from DevOps or SRE? This article unpacks the role of platform teams, why they\u0026rsquo;re critical in modern software delivery, and how they bring together cloud, automation, and developer experience.","title":"Platform Engineering: The DevOps You Productize"},{"content":" \u0026ldquo;SaaS products scale with services that talk â€” efficiently, flexibly, and reliably.\u0026rdquo;\nGo (Golang) has become a top-tier language for building scalable, cloud-native microservices â€” especially in the SaaS world. Its speed, simplicity, and rich concurrency model make it ideal for high-performance backends and multi-tenant systems.\nIn this article, weâ€™ll explore how to build SaaS microservices in Go, focusing on different API approaches â€” REST, gRPC, GraphQL, and WebSockets â€” and when to use each.\nğŸ—ï¸ Why Use Go for SaaS Microservices? âš¡ Performance: Native compilation, low memory usage, fast startup.\nğŸ§µ Concurrency: Goroutines + channels = lightweight multitasking.\nğŸ”§ Tooling: Rich stdlib, simple testing, static binaries, fast CI/CD.\nâ˜ï¸ Cloud Native: Ideal for containerization and Kubernetes deployments.\nGo hits the sweet spot between systems-level control and developer productivity.\nğŸ§± SaaS Architecture Essentials Service isolation (multi-tenant or multi-instance)\nStateless compute (for scalability)\nSecure authentication and authorization\nObservability (metrics, logs, traces)\nInter-service communication (APIs!)\nğŸŒ REST API: The Classic Workhorse âœ… Use When: You need browser and mobile-friendly APIs\nYour consumers prefer HTTP+JSON\nYou prioritize simplicity and developer ergonomics\nğŸ› ï¸ Go Libraries: net/http (stdlib)\ngin, chi, echo, fiber (routers)\nopenapi, swagger, goa (spec + docs)\nREST API is battle-tested, easy to cache, and easy to debug â€” ideal for public APIs or integrations.\nâš¡ gRPC API: High-Performance Internal Comms âœ… Use When: You need fast, efficient, binary communication\nYou control both client and server\nYou\u0026rsquo;re building service-to-service comms in a large SaaS platform\nğŸ› ï¸ Go Libraries: google.golang.org/grpc\nProtocol Buffers (protoc, protoc-gen-go)\nEnvoy / gRPC-Gateway for REST interop\ngRPC API shines in polyglot, high-throughput microservice environments.\nğŸ” GraphQL: Flexible Queries for Frontend Teams âœ… Use When: Frontend teams need control over data shape\nYou want to reduce overfetching/underfetching\nYou serve multiple frontends with different needs\nğŸ› ï¸ Go Libraries: 99designs/gqlgen\ngraphql-go/graphql\nGraphQL API is great for B2B SaaS dashboards, admin panels, or multi-platform apps.\nğŸ”„ WebSockets: Real-Time, Bi-Directional APIs âœ… Use When: You need real-time updates (chat, collaboration, notifications)\nClients push and receive events\nğŸ› ï¸ Go Libraries: gorilla/websocket\nnhooyr/websocket\nWebSockets APIs are ideal for modern SaaS apps with live user interactions.\nğŸ“ CQRS: Separating Read and Write Paths The Command Query Responsibility Segregation (CQRS) pattern is often a great fit for SaaS microservices â€” especially when paired with event-driven architectures.\nâœ… Use When: You have complex domain logic or heavy reads vs light writes (or vice versa)\nYou want to decouple write models from read-optimized projections\nYou\u0026rsquo;re building event-sourced systems\nâš™ï¸ Tools \u0026amp; Patterns in Go: Use separate structs/services for CommandHandlers and QueryHandlers\nEvent buses (e.g. go-nats, kafka-go, watermill)\nProjection stores (Postgres, Redis, Elasticsearch, etc.)\nCQRS enables scalability, flexibility, and clear separation of concerns â€” perfect for SaaS systems with evolving business logic and reporting needs.\nğŸ§© Putting It All Together In a real SaaS platform, youâ€™ll likely mix protocols:\nREST for public APIs and onboarding\ngRPC for internal service mesh\nGraphQL for flexible frontend backends\nWebSocket for interactive features\nUse each where it fits best â€” Go makes switching easy.\nğŸ› ï¸ Dev Stack for SaaS Microservices in Go API Gateways: Kong, Envoy, Traefik\nAuth: OAuth2, OIDC, JWT (with golang-jwt/jwt)\nService Discovery: Consul, etcd, Kubernetes\nObservability: Prometheus, OpenTelemetry, Grafana\nCI/CD: GitHub Actions, Drone, ArgoCD\nğŸ“Œ Final Thoughts Go makes it easy to build fast, scalable, and maintainable SaaS microservices â€” no matter which API protocol you\u0026rsquo;re working with. Understanding the strengths and trade-offs of REST, gRPC, GraphQL, WebSockets, and architectural patterns like CQRS helps you design the right interface for each part of your product.\nğŸš€ Follow me on norbix.dev for more insights on Go, system design, and engineering wisdom.\n","permalink":"https://norbix.dev/posts/saas-microservices/","summary":"Explore how to build SaaS-ready microservices in Go using REST, gRPC, GraphQL, and WebSockets. Learn the trade-offs, use cases, and tooling for each API style.","title":"Building SaaS Microservices in Go: REST, gRPC, GraphQL, and WebSocket APIs"},{"content":" \u0026ldquo;Bad data ruins good applications. Good databases build great systems.\u0026rdquo;\nDatabases are the silent powerhouse behind most modern applications. Whether youâ€™re building a simple blog, an enterprise CRM, or a distributed IoT system, understanding database fundamentals can dramatically improve the quality and scalability of your software.\nIn this article, Iâ€™ll walk through essential database concepts every engineer should master: B-Trees, SQL, NoSQL, ACID properties, and normalization.\nğŸ“š B-Trees: The Backbone of Indexing Efficient data retrieval is crucial, and that\u0026rsquo;s where B-Trees come in. B-Trees are balanced tree structures that allow fast search, insert, and delete operations in logarithmic time.\nIn databases like MySQL (InnoDB) and PostgreSQL, indexes are often implemented as B-Trees, making queries much faster by avoiding full table scans.\nğŸ”¹ Tip: Always index columns used in WHERE, JOIN, and ORDER BY clauses to leverage B-Tree advantages.\nğŸ“‚ SQL: Structured Query Language SQL is the standard language for querying and manipulating relational databases.\nKey operations:\nSELECT: Retrieve data INSERT: Add new records UPDATE: Modify existing records DELETE: Remove records SQL enforces a strict schema and supports relationships, making it ideal for structured data.\nPopular SQL databases: PostgreSQL, MySQL, MariaDB, Microsoft SQL Server.\nğŸ”¹ Tip: Master JOIN operations and subqueries to unlock SQL\u0026rsquo;s full power.\nğŸ”„ NoSQL: Flexibility at Scale NoSQL databases emerged to handle massive, unstructured, and rapidly changing data.\nTypes of NoSQL databases:\nDocument stores: MongoDB, Couchbase Key-value stores: Redis, DynamoDB Wide-column stores: Cassandra, HBase Graph databases: Neo4j, Amazon Neptune NoSQL systems often prioritize availability and partition tolerance (CAP theorem) over strict consistency.\nğŸ”¹ Tip: Choose NoSQL when your application requires high write throughput, horizontal scaling, or flexible schemas.\nğŸ’ª ACID Properties: Reliability You Can Trust ACID is a set of properties that guarantee reliable database transactions:\nAtomicity: All operations succeed or none do. Consistency: Data remains valid after transactions. Isolation: Concurrent transactions don\u0026rsquo;t interfere. Durability: Committed data persists even after crashes. Relational databases excel at enforcing ACID properties, which are critical for financial systems, order processing, and anywhere data integrity matters.\nğŸ”¹ Tip: In distributed systems, understand when relaxing ACID is acceptable for performance gains (e.g., eventual consistency).\nğŸ“ Database Normalization: Design for Integrity Normalization organizes data to reduce redundancy and improve integrity.\nKey normal forms:\n1NF: Eliminate repeating groups. 2NF: Remove partial dependencies. 3NF: Remove transitive dependencies. While normalization ensures clean data design, sometimes selective denormalization is necessary for performance reasons in read-heavy systems.\nğŸ”¹ Tip: Normalize for clarity, denormalize for performance â€” based on access patterns.\nğŸ”„ Wrapping Up Understanding databases isn\u0026rsquo;t just about memorizing SQL queries. Itâ€™s about knowing how data structures (like B-Trees), transaction guarantees (ACID), and design principles (normalization) affect your applicationâ€™s performance, reliability, and scalability.\nWhether you\u0026rsquo;re architecting a high-availability service or fine-tuning a reporting dashboard, strong database knowledge will elevate your solutions.\nğŸš€ Follow me on norbix.dev for more insights on Go, system design, and engineering wisdom.\n","permalink":"https://norbix.dev/posts/databases/","summary":"Learn the key database concepts every software engineer should know: B-Trees, SQL, NoSQL, ACID properties, and database normalization principles.","title":"Understanding Databases: B-Trees, SQL, NoSQL, ACID, and Normalization"},{"content":"Hi, I\u0026rsquo;m Norbert Jakubczak â€” aka Norbix ğŸ‘‹\nWelcome to my tech blog â€” where code, systems thinking, and engineering mindset meet. ğŸš€ I\u0026rsquo;m a polyglot Software Engineer with a strong focus on Golang and Python, working across the full stack â€” from backend and cloud infrastructure to frontend integration and developer tooling.\nI specialize in building Internal Developer Platforms (IDPs) and architecting scalable Software-as-a-Service (SaaS) systems using microservices and modern cloud-native technologies.\nBefore stepping fully into tech, I was a professional basketball player â€” a path that taught me discipline, team dynamics, and what it means to perform under pressure. That mindset still drives how I build software today.\n\u0026ldquo;Never say never, because limits, like fears, are often just an illusion.\u0026rdquo;\nâ€” Michael Jordan\nğŸ› ï¸ Areas of Expertise ğŸ \u0026amp; ğŸ¦« Polyglot systems in Python and Go ğŸ§± Internal Developer Platforms (IDP) ğŸ§© SaaS Microservices architecture â˜ï¸ Kubernetes (K8s) and cloud-native platforms ğŸ” DevSecOps and secure CI/CD pipelines âš™ï¸ Full lifecycle delivery: from analysis \u0026amp; architecture â†’ development â†’ deployment â†’ production support âœï¸ What this blog is about This blog is a logbook of my journey building and maintaining resilient systems â€” sharing both wins and war stories from the world of platform engineering, cloud automation, and product delivery.\nExpect deep dives on:\nGo/Python code patterns API and system design Developer experience (DevEx) best practices CI/CD orchestration Infrastructure-as-Code (IaC) Real code. Real lessons. Honest write-ups.\nğŸ“£ Featured In My fullstack Go starter was featured on PitchHut â€” a curated platform that showcases developer-built projects.\nğŸ‘‰ Check it out here\nâ­ Reviews Curious what it\u0026rsquo;s like working with me?\nHere\u0026rsquo;s what my clients and collaborators say on Google:\nğŸ‘‰ Read my reviews on Google\nTip: Click \u0026lsquo;Sort by â†’ Newest\u0026rsquo; to see the latest feedback.\nğŸŒ Connect with me GitHub: @norbix Twitter: @norbixjakubczak Email: norbert.jakubczak@gmail.com Mobile: +48 885 259 225 Thanks for stopping by. Whether you\u0026rsquo;re a developer, architect, or fellow ex-athlete turned engineer â€” I hope something here helps you build better systems.\n","permalink":"https://norbix.dev/about/","summary":"\u003cp\u003eHi, I\u0026rsquo;m \u003cstrong\u003eNorbert Jakubczak\u003c/strong\u003e â€” aka \u003cstrong\u003eNorbix\u003c/strong\u003e ğŸ‘‹\u003c/p\u003e\n  \u003cfigcaption style=\"text-align: center; font-style: italic; color: #aaa;\"\u003e\n    Welcome to my tech blog â€” where code, systems thinking, and engineering mindset meet. ğŸš€\n  \u003c/figcaption\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/my_photo.jpg\" alt=\"my_photo.jgp\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m a polyglot \u003cstrong\u003eSoftware Engineer\u003c/strong\u003e with a strong focus on \u003cstrong\u003eGolang\u003c/strong\u003e and \u003cstrong\u003ePython\u003c/strong\u003e, working across the full stack â€” from backend and cloud infrastructure to frontend integration and developer tooling.\u003c/p\u003e\n\u003cp\u003eI specialize in building \u003cstrong\u003eInternal Developer Platforms (IDPs)\u003c/strong\u003e and architecting scalable \u003cstrong\u003eSoftware-as-a-Service (SaaS)\u003c/strong\u003e systems using microservices and modern cloud-native technologies.\u003c/p\u003e","title":"About"}]
[{"content":" ğŸ§  Mastering Data Structures and Algorithms (DSA) with Go Whether you\u0026rsquo;re preparing for technical interviews, optimizing backend systems, or simply sharpening your problem-solving chops, Data Structures and Algorithms (DSA) are foundational to your success as a developer.\nIn this article, Iâ€™ll walk you through core DSA concepts using Golang, a language praised for its simplicity, performance, and concurrency model. You\u0026rsquo;ll see how Go makes understanding DSA both intuitive and powerful.\nğŸš€ What is DSA? Data Structures organize and store data efficiently, while Algorithms define step-by-step instructions to solve problems or manipulate data.\nTogether, DSA provides the backbone for high-performance applications.\nğŸ“¦ Essential Data Structures in Go Arrays \u0026amp; Slices\n1 2 3 4 5 arr := [5]int{1, 2, 3, 4, 5} // Fixed-size array slice := []int{1, 2, 3} // Dynamic size slice = append(slice, 4) fmt.Println(slice) // [1 2 3 4] Slices are the idiomatic way to work with collections in Go. They offer flexibility while leveraging arrays under the hood.\nLinked List\nGo doesnâ€™t have a built-in linked list, but the container/list package provides one.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;container/list\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { l := list.New() l.PushBack(\u0026#34;Go\u0026#34;) l.PushBack(\u0026#34;DSA\u0026#34;) for e := l.Front(); e != nil; e = e.Next() { fmt.Println(e.Value) } } Stack (LIFO)\nA stack can be easily implemented using slices.\n1 2 3 4 5 6 7 8 9 10 11 12 type Stack []int func (s *Stack) Push(v int) { *s = append(*s, v) } func (s *Stack) Pop() int { n := len(*s) val := (*s)[n-1] *s = (*s)[:n-1] return val } Queue (FIFO)\nQueues can also be implemented using slices.\n1 2 3 4 5 6 7 8 9 10 11 type Queue []int func (q *Queue) Enqueue(v int) { *q = append(*q, v) } func (q *Queue) Dequeue() int { val := (*q)[0] *q = (*q)[1:] return val } Hash Map (Go's map)\n1 2 3 4 5 m := map[string]int{ \u0026#34;apple\u0026#34;: 5, \u0026#34;banana\u0026#34;: 3, } fmt.Println(m[\u0026#34;apple\u0026#34;]) // 5 Hint: Goâ€™s built-in map is a powerful hash table implementation for key-value pairs.\nğŸ§© Must-Know Algorithms in Go Binary Search\nEfficient O(log n) search on sorted arrays.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func binarySearch(arr []int, target int) int { low, high := 0, len(arr)-1 for low \u0026lt;= high { mid := (low + high) / 2 if arr[mid] == target { return mid } else if arr[mid] \u0026lt; target { low = mid + 1 } else { high = mid - 1 } } return -1 } Sorting (Bubble Sort Example)\n1 2 3 4 5 6 7 8 9 10 func bubbleSort(arr []int) { n := len(arr) for i := 0; i \u0026lt; n-1; i++ { for j := 0; j \u0026lt; n-i-1; j++ { if arr[j] \u0026gt; arr[j+1] { arr[j], arr[j+1] = arr[j+1], arr[j] } } } } For real projects, use Goâ€™s built-in sorting:\n1 sort.Ints(arr) Recursion: Factorial\n1 2 3 4 5 6 7 func factorial(n int) int { if n == 0 { return 1 } return n * factorial(n-1) } Graph and Trees\nFor binary trees, you define custom structures.\n1 2 3 4 5 type Node struct { Value int Left *Node Right *Node } Depth-first traversal:\n1 2 3 4 5 6 7 8 9 func dfs(n *Node) { if n == nil { return } fmt.Println(n.Value) dfs(n.Left) dfs(n.Right) } ğŸ§  Tips for Learning DSA with Go Practice problems: Use platforms like LeetCode, HackerRank, or Exercism. Understand time complexity: Know Big-O analysis for every structure and algorithm. Build mini-projects: Implement your own LRU Cache, Trie, or Priority Queue. ğŸ¯ Final Thoughts Mastering DSA not only sharpens your coding skills but also prepares you for systems design, performance optimization, and real-world problem-solving.\nWith Goâ€™s clean syntax and powerful standard library, you\u0026rsquo;re equipped to tackle DSA challenges efficiently and idiomatically.\nğŸš€ Follow me on norbix.dev for more insights on Go, system design, and engineering wisdom.\n","permalink":"https://norbix.dev/posts/algorithms-and-data-structures/","summary":"A deep dive into Data Structures and Algorithms (DSA) using Go, covering essential concepts, implementations, and best practices.","title":"DSA- Algorithms and Data Structures"},{"content":" ğŸ§­ Mermaid Syntax Highlights ğŸ”„ Flowcharts Direction:\nLR: Left to Right TB: Top to Bottom BT: Bottom to Top flowchart LR G[(Goals)] \u0026lt;===\u0026gt; P[(Projects)] P ---o PD(Deadline) PD ---- OV([Overdue]) ---\u0026gt; FOV{4 Days} PD ---x MT([Met]) P ---o PT(Tasks) PT ---- C([Complete]) PT ---x IC([Incomplete]) C ---\u0026gt; R[[Review]] R -..-\u0026gt; G ğŸ‘€ Comments:\n%% â€“ Comment not rendered in the chart |Label| â€“ Annotates arrows ğŸ¯ Example with styling, click links, and labels:\nflowchart LR; classDef blue fill:#2374f7,stroke:#000,color:#fff G[(Goals)]:::blue \u0026lt;===\u0026gt; |Connects To| P[(Projects)]:::blue click P \u0026#34;https://github.com/norbix\u0026#34; ğŸ§± Graph Diagrams (UML-style) graph TD a(content) --\u0026gt; b([hello]) b --\u0026gt; c[(world)] b --\u0026gt; d(branch) d --\u0026gt; e((circle)) d ==\u0026gt; f\u0026gt;flag] f --- g{diamond} Use subgraph to group elements:\ngraph TD subgraph Graph One A --\u0026gt; B end subgraph Graph Two C --\u0026gt; D end A --\u0026gt; D ğŸ¥§ Pie Charts pie title Content Breakdown \u0026#34;youtube\u0026#34; : 50 \u0026#34;twitch\u0026#34; : 20 \u0026#34;twitter\u0026#34; : 30 ğŸ§­ Journey Diagrams Track progress or workflows using narrative sections:\njourney title My Working Day section Work Wrote code: 3: me Reviewed PRs: 4: me section Twitch Streamed: 3: me ğŸ§© Class Diagrams Great for OOP design documentation.\nclassDiagram class Order { +OrderStatus status } class OrderStatus { \u0026lt;\u0026lt;enumeration\u0026gt;\u0026gt; FAILED PENDING PAID } class PaymentProcessor { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; -String apiKey +processPayment(Order order) OrderStatus } class Customer { +String name } Order o-- Customer Car *-- Engine PaymentProcessor \u0026lt;|-- StripePaymentProcessor ğŸ“œ Sequence Diagrams sequenceDiagram participant fe as Front-End participant be as Back-End participant auth as Auth fe --\u0026gt;\u0026gt; be: Login be --\u0026gt;\u0026gt; auth: Validate auth --\u0026gt;\u0026gt; be: Token be --\u0026gt;\u0026gt; fe: Success alt Invalid credentials be --\u0026gt;\u0026gt; fe: Error end âœ… Why Use Mermaid in Your Codebase? ğŸ“– Self-documenting code and architecture ğŸ‘¥ Team-wide clarity on workflows and design ğŸ” Easy to update and version control ğŸ§© Supports component trees, state machines, database schemas, and more ğŸ“¦ Resources ğŸ“š Official Repo (mermaid-js/mermaid) ğŸ“ YouTube Course âœ¨ Try live: Mermaid Live Editor ","permalink":"https://norbix.dev/posts/diagrams/","summary":"A quick reference guide to using Mermaid syntax for creating various types of diagrams, including flowcharts, graphs, and more.","title":"Diagrams: Mermaid Syntax Highlights"},{"content":"Design patterns are reusable solutions to common problems in software design.\nThey provide a shared language for developers and encourage best practices in system architecture.\nIn this article, we\u0026rsquo;ll explore some of the most widely used design patterns in Go, grouped into three categories: creational, structural, and behavioral.\nğŸ”§ Creational Patterns ğŸ”‚ Singleton\nEnsures a class has only one instance and provides a global point of access to it.\nâ€œWhen discussing which pattern to drop, we found that we still love them all. (Not really â€” I\u0026rsquo;m in favor of dropping Singleton. Its use is almost always a design smell.)â€\nâ€” Erich Gamma, Design Patterns: Elements of Reusable Object-Oriented Software\nWhile Singleton often gets a bad reputation, there are still valid use cases in Go:\nâœ… You only want one component in the system (e.g., database repository, object factory) â³ The object is expensive to construct, so you instantiate it only once ğŸš« You want to prevent the creation of additional instances ğŸ’¤ You want lazy instantiation (e.g. load config or connect to DB only when needed) Go makes this easy and thread-safe with sync.Once. To stay testable and modular, follow the Dependency Inversion Principle (DIP) â€” depend on interfaces, not concrete types.\nHint:\nSingleton quite often breaks the Dependency Inversion Principle!\nğŸ§‘â€ğŸ’» Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package singleton import ( \u0026#34;sync\u0026#34; ) var ( instance *singleton once sync.Once ) type singleton struct{} func GetInstance() *singleton { once.Do(func() { instance = \u0026amp;singleton{} }) return instance } ğŸ§ª Usage\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;singleton\u0026#34; ) func main() { a := singleton.GetInstance() b := singleton.GetInstance() fmt.Println(a.Value) // Output: I am the only one // Confirm both variables point to the same instance fmt.Println(a == b) // Output: true } ğŸ­ Factory\nCreates objects without specifying the exact class.\nA factory helps simplify object creation when:\nğŸŒ€ Object creation logic becomes too convoluted ğŸ§± A struct has too many fields that need to be correctly initialized ğŸ’¡ You want to delegate creation logic away from the calling code There are two flavors of factories in Go:\nğŸ”§ Factory function (also called a constructor): a helper function to initialize struct instances ğŸ—ï¸ Factory struct: a dedicated struct responsible for managing object creation Unlike the Builder pattern, which is piecewise, the Factory creates the object wholesale â€” usually in one go.\nğŸ§‘â€ğŸ’» Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package factory type Shape interface { Draw() string } type Circle struct{} func (c Circle) Draw() string { return \u0026#34;Drawing Circle\u0026#34; } type Square struct{} func (s Square) Draw() string { return \u0026#34;Drawing Square\u0026#34; } func GetShape(shapeType string) Shape { switch shapeType { case \u0026#34;circle\u0026#34;: return Circle{} case \u0026#34;square\u0026#34;: return Square{} default: return nil } } ğŸ§ª Usage\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;factory\u0026#34; ) func main() { circle := factory.GetShape(\u0026#34;circle\u0026#34;) square := factory.GetShape(\u0026#34;square\u0026#34;) fmt.Println(circle.Draw()) // Output: Drawing Circle fmt.Println(square.Draw()) // Output: Drawing Square } ğŸ§± Builder\nSeparates the construction of a complex object from its representation.\nNot all objects are created equal:\nâœ… Some are simple and can be created with a single constructor call âš ï¸ Others require a lot of ceremony to set up ğŸ§© Factory functions with 10+ parameters become hard to use and maintain When you want more flexibility and readability, use the Builder pattern.\nğŸ› ï¸ A Builder is a separate component used to construct an object step-by-step ğŸ”„ It exposes a fluent API â€” each method returns the receiver (*Builder) to enable chaining ğŸ§  In advanced designs, different builders can operate on different facets of the same object ğŸ§‘â€ğŸ’» Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package builder type Car struct { Engine string Wheels int Color string } type CarBuilder struct { car Car } func (b *CarBuilder) SetEngine(engine string) *CarBuilder { b.car.Engine = engine return b } func (b *CarBuilder) SetWheels(wheels int) *CarBuilder { b.car.Wheels = wheels return b } func (b *CarBuilder) SetColor(color string) *CarBuilder { b.car.Color = color return b } func (b *CarBuilder) Build() Car { return b.car } ğŸ§ª Usage\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;builder\u0026#34; ) func main() { car := builder.CarBuilder{}. SetEngine(\u0026#34;V8\u0026#34;). SetWheels(4). SetColor(\u0026#34;Red\u0026#34;). Build() fmt.Printf(\u0026#34;%+v\\n\u0026#34;, car) // Output: {Engine:V8 Wheels:4 Color:Red} } ğŸ§© Structural Patterns 1.ğŸ”Œ Adapter\nAllows incompatible interfaces to work together.\nAn Adapter is a design construct that adapts an existing interface X to conform to the required interface Y. It acts as a translator or bridge between two systems that otherwise couldnâ€™t work together.\nğŸ§­ To implement an adapter in Go:\n- ğŸ” Determine the **API you have** (e.g. `Adaptee`) - ğŸ¯ Define the **API you need** (e.g. `Target`) - ğŸ§© Create an adapter struct that **aggregates** the adaptee (usually via a pointer) - âš¡ Optimize when needed â€” adapters may introduce intermediate representations, so use **caching** or other performance strategies as required This is especially useful when integrating legacy code or 3rd-party libraries into a new system with different interfaces.\nğŸ§‘â€ğŸ’» Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package adapter type Target interface { Request() string } type Adaptee struct{} func (a Adaptee) SpecificRequest() string { return \u0026#34;Specific behavior\u0026#34; } type Adapter struct { adaptee Adaptee } func (a Adapter) Request() string { return a.adaptee.SpecificRequest() } ğŸ§ª Usage\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;adapter\u0026#34; ) func main() { adaptee := adapter.Adaptee{} adapterInstance := adapter.Adapter{Adaptee: adaptee} var target adapter.Target = adapterInstance fmt.Println(target.Request()) // Output: Specific behavior } ğŸ€ Decorator\nAdds behavior to objects dynamically by embedding and extending existing functionality.\nThe Decorator pattern is used when you want to:\nâ• Augment an object with additional behavior ğŸš« Avoid modifying existing code (âœ… Open/Closed Principle â€” OCP) ğŸ§¼ Keep new functionality separate and modular (âœ… Single Responsibility Principle â€” SRP) ğŸ”„ Retain the ability to interact with existing interfaces The solution is to embed the decorated object and override or extend its behavior. This lets you build stackable, reusable enhancements without altering the base struct.\nğŸ§‘â€ğŸ’» Example: wrapping a basic Coffee with a MilkDecorator:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package decorator type Coffee interface { Cost() float64 } type SimpleCoffee struct{} func (s SimpleCoffee) Cost() float64 { return 2.0 } type MilkDecorator struct { Coffee } func (m MilkDecorator) Cost() float64 { return m.Coffee.Cost() + 0.5 } ğŸ§ª Usage\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;decorator\u0026#34; ) func main() { var coffee decorator.Coffee = decorator.SimpleCoffee{} fmt.Println(\u0026#34;Base cost:\u0026#34;, coffee.Cost()) // Output: 2.0 coffeeWithMilk := decorator.MilkDecorator{Coffee: coffee} fmt.Println(\u0026#34;With milk:\u0026#34;, coffeeWithMilk.Cost()) // Output: 2.5 } ğŸ›¡ Proxy\nProvides a surrogate or placeholder.\nğŸ§‘â€ğŸ’» Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package proxy type Image interface { Display() string } type RealImage struct { filename string } func (r RealImage) Display() string { return \u0026#34;Displaying \u0026#34; + r.filename } type ProxyImage struct { realImage *RealImage filename string } func (p *ProxyImage) Display() string { if p.realImage == nil { p.realImage = \u0026amp;RealImage{filename: p.filename} } return p.realImage.Display() } ğŸ§ª Usage\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;proxy\u0026#34; ) func main() { img := \u0026amp;proxy.ProxyImage{filename: \u0026#34;cat.png\u0026#34;} // The real image is not loaded yet fmt.Println(img.Display()) // Output: Displaying cat.png // The real image is reused without reloading fmt.Println(img.Display()) // Output: Displaying cat.png } ğŸŒ³ Composite\nComposes objects into tree structures. Composes objects into tree structures and lets you treat individual and composite objects uniformly.\nThe Composite pattern is ideal when some components are single objects (like files), and others are containers of other components (like folders). Both should support a common interface so clients donâ€™t need to differentiate between them.\nğŸ§­ To implement a composite in Go:\nğŸ§± Define a common interface that all components implement.\nğŸŒ¿ Implement Leaf objects (e.g. File, Button, TextField).\nğŸ§º Implement Composite objects (e.g. Folder, Panel) that aggregate children and delegate behavior to them.\nğŸ” Add iteration if you need to traverse or walk the tree (e.g. using the Iterator pattern).\nThis pattern shines when building hierarchical or nested structures such as UI components, file systems, or organization charts.\nğŸ§‘â€ğŸ’» Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package composite type Component interface { Operation() string } type Leaf struct { name string } func (l Leaf) Operation() string { return l.name } type Composite struct { children []Component } func (c *Composite) Add(child Component) { c.children = append(c.children, child) } func (c *Composite) Operation() string { result := \u0026#34;\u0026#34; for _, child := range c.children { result += child.Operation() + \u0026#34; \u0026#34; } return result } ğŸ“¦ Example usage:\n1 2 3 4 5 6 7 8 9 10 func main() { file1 := Leaf{name: \u0026#34;FileA.txt\u0026#34;} file2 := Leaf{name: \u0026#34;FileB.txt\u0026#34;} folder := \u0026amp;Composite{} folder.Add(file1) folder.Add(file2) fmt.Println(folder.Operation()) // Output: FileA.txt FileB.txt } âœ… When to use Composite:\nYou want to treat individual and group objects the same way You have recursive or nested structures You want to delegate behavior to child components ğŸ” Bonus: Pair with the Iterator pattern to walk tree structures cleanly without exposing their internal representation.\nğŸ§  Behavioral Patterns ğŸ§® Strategy\nDefines a family of algorithms.\nEncapsulates a family of algorithms and allows them to be selected and swapped at runtime.\nThe Strategy pattern is used when you want to:\nğŸ§  Separate an algorithm into its skeleton and implementation steps ğŸ§© Decompose behavior into high-level workflows and low-level operations ğŸ”„ Swap logic dynamically without changing the calling code âœ… Adhere to the Open/Closed Principle (OCP) â€” new strategies without changing the high-level logic The solution is to define a high-level algorithm that delegates part of its logic to an injected strategy. This strategy follows a shared interface, so any implementation can be plugged in without breaking the algorithm. ğŸµ Analogy: making a hot beverage\nMany real-world algorithms follow this structure. Take making tea as an example:\nSkeleton algorithm: Boil water â†’ Pour into cup â†’ Add ingredient Concrete implementation: Add tea bag, coffee grounds, or cocoa powder The high-level process is reusable, and the final step is delegated to a drink-specific strategy. This is exactly how Strategy works.\nğŸ§‘â€ğŸ’» Example: Choosing an operation strategy\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package strategy type Strategy interface { Execute(a, b int) int } type Add struct{} func (Add) Execute(a, b int) int { return a + b } type Multiply struct{} func (Multiply) Execute(a, b int) int { return a * b } type Context struct { strategy Strategy } func (c *Context) SetStrategy(s Strategy) { c.strategy = s } func (c Context) ExecuteStrategy(a, b int) int { return c.strategy.Execute(a, b) } ğŸ§ª Usage\n1 2 3 4 5 6 7 ctx := strategy.Context{} ctx.SetStrategy(strategy.Add{}) fmt.Println(ctx.ExecuteStrategy(3, 4)) // Output: 7 ctx.SetStrategy(strategy.Multiply{}) fmt.Println(ctx.ExecuteStrategy(3, 4)) // Output: 12 By:\nDefining a common interface (Strategy) Creating multiple concrete strategies (Add, Multiply) Supporting runtime injection into a reusable context (Context) You separate the structure of the algorithm from its implementation. Just like boiling water and pouring it into a cup â€” what happens next depends on the drink you\u0026rsquo;re making.\nThis makes your code modular, extensible, and easy to adapt to new behaviors without touching your existing flow.\nğŸ‘€ Observer\nWants to listen to events and be notified when something happens.\nThe Observer pattern is used when you want to:\nğŸ“£ Be informed when a particular object changes state, does something, or reacts to an external event ğŸ‘‚ Let other objects (observers) subscribe to and react to those changes ğŸ”„ Decouple the source of truth from those reacting to it âœ… Support dynamic subscription and unsubscription The solution is to have two participants:\nğŸŸ¢ Observable: emits events and holds a list of observers ğŸŸ¡ Observer: subscribes and reacts to events When the observable changes, it notifies all observers â€” sending event data (commonly as interface{} in Go) to each subscriber. This is an intrusive approach since the observable must provide explicit subscription management.\nğŸ§‘â€ğŸ’» Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package observer type Observer interface { Update(string) } type Subject interface { Attach(Observer) Notify() } type ConcreteSubject struct { observers []Observer state string } func (s *ConcreteSubject) Attach(o Observer) { s.observers = append(s.observers, o) } func (s *ConcreteSubject) SetState(state string) { s.state = state s.Notify() } func (s *ConcreteSubject) Notify() { for _, o := range s.observers { o.Update(s.state) } } type ConcreteObserver struct { id string } func (o ConcreteObserver) Update(state string) { println(\u0026#34;Observer\u0026#34;, o.id, \u0026#34;received new state:\u0026#34;, state) } ğŸ§ª Usage\n1 2 3 4 5 6 7 8 9 10 11 12 subject := \u0026amp;observer.ConcreteSubject{} observer1 := observer.ConcreteObserver{id: \u0026#34;A\u0026#34;} observer2 := observer.ConcreteObserver{id: \u0026#34;B\u0026#34;} subject.Attach(observer1) subject.Attach(observer2) subject.SetState(\u0026#34;ğŸš€ Launching\u0026#34;) // Output: // Observer A received new state: ğŸš€ Launching // Observer B received new state: ğŸš€ Launching With Observer, you give objects the ability to react automatically to changes elsewhere, without tightly coupling them together. This pattern is especially helpful for:\nUIs reacting to data changes Logging and monitoring Event-based systems Hint:\nThis approach is intrusive â€” the observable must explicitly support subscriptions and notify logic.\nğŸ” State\nAllows an object to alter its behavior when its internal state changes â€” effectively changing its class at runtime.\nThe State pattern is used when you want to:\nğŸ”„ Let an object change behavior dynamically based on its current state ğŸ“² Model real-world systems where actions depend on state ğŸ§  Manage complex state logic in a modular, maintainable way The solution is to encapsulate each state in its own type and let the context object delegate behavior to the current state. When the state changes, so does the object\u0026rsquo;s behavior â€” without conditionals scattered throughout the code.\nThese transitions are triggered by events (e.g. dialing, picking up, hanging up), and actions vary depending on the state. This is a perfect fit for a state machine â€” a formal model that defines:\nğŸ“¥ Entry/exit actions for each state ğŸ”„ Transitions between states, often triggered by events âœ… Guards that control whether a transition is allowed âš™ï¸ A default behavior if no transition is found When systems grow in complexity, it pays to define states and transitions explicitly to keep logic clean and modular.\nğŸ§‘â€ğŸ’» Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package state type State interface { Handle() string } type Context struct { state State } func (c *Context) SetState(s State) { c.state = s } func (c Context) Request() string { return c.state.Handle() } type OnState struct{} func (OnState) Handle() string { return \u0026#34;State is ON\u0026#34; } type OffState struct{} func (OffState) Handle() string { return \u0026#34;State is OFF\u0026#34; } ğŸ§ª Usage\n1 2 3 4 5 6 7 ctx := state.Context{} ctx.SetState(state.OnState{}) fmt.Println(ctx.Request()) // Output: State is ON ctx.SetState(state.OffState{}) fmt.Println(ctx.Request()) // Output: State is OFF With the State pattern:\nYou encapsulate each state and its logic in a separate type The object transitions explicitly in response to triggers Behavior is cleanly modular, without long chains of if or switch Whether you\u0026rsquo;re modeling a telephone, a TCP connection, or a video player, state machines help you handle transitions with clarity, flexibility, and control.\nâœ… Conclusion Design patterns are powerful tools in every Go developerâ€™s toolkit. While Go encourages simplicity, these patterns still applyâ€”especially in large-scale systems or when writing reusable libraries. Using patterns like Singleton, Adapter, and Strategy can lead to cleaner, more testable, and maintainable code.\nHappy Go coding! ğŸ¹\n","permalink":"https://norbix.dev/posts/design-patterns/","summary":"Explore creational, structural, and behavioral design patterns in Go with clear explanations and code snippets.","title":"Design Patterns in Go: Practical Examples"},{"content":"\u0026ldquo;High-level modules should not depend on low-level modules. Both should depend on abstractions.\u0026rdquo;\nWelcome to a core principle of software architecture: Dependency Inversion, the \u0026ldquo;D\u0026rdquo; in SOLID. In this article, weâ€™ll explore what it means in practice, how to implement it in Go using interfaces and dependency injection, and why itâ€™s essential for writing unit-testable code.\nğŸ§  What Is the Dependency Inversion Principle? The Dependency Inversion Principle (DIP) flips the traditional dependency model:\nâŒ Traditional: High-level business logic depends directly on low-level implementation (e.g., a database).\nâœ… DIP: Both layers depend on abstractions â€” usually in the form of interfaces.\nItâ€™s about reversing the direction of dependency to reduce coupling and improve flexibility.\nğŸ’¡ A Quick Example: Tightly Coupled Code 1 2 3 4 5 6 7 8 type OrderService struct { db *sql.DB } func (o *OrderService) Save(order Order) error { _, err := o.db.Exec(\u0026#34;INSERT INTO orders ...\u0026#34;) return err } This code:\nTightly couples OrderService to a concrete *sql.DB\nIs hard to test in isolation\nâœ… Refactor with Dependency Inversion Letâ€™s invert the dependency:\n1 2 3 4 5 6 7 8 9 10 11 type OrderRepository interface { Save(order Order) error } type OrderService struct { repo OrderRepository } func (o *OrderService) Save(order Order) error { return o.repo.Save(order) } Now:\nOrderService depends on an interface\nOrderRepository can be backed by a real DB in prod or a mock in tests\nğŸ› ï¸ Enter Dependency Injection Weâ€™ve inverted dependencies â€” now we need a way to supply them. Manual constructor injection in Go:\n1 2 3 func NewOrderService(repo OrderRepository) *OrderService { return \u0026amp;OrderService{repo: repo} } At runtime, inject the actual implementation:\n1 service := NewOrderService(NewPostgresOrderRepository(db)) ğŸ§ª Why This Rocks for Testing DIP + interfaces = test-friendly code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type MockOrderRepository struct { SavedOrder Order } func (m *MockOrderRepository) Save(order Order) error { m.SavedOrder = order return nil } func TestOrderService_Save(t *testing.T) { mock := \u0026amp;MockOrderRepository{} service := NewOrderService(mock) order := Order{ID: 42} err := service.Save(order) require.NoError(t, err) require.Equal(t, 42, mock.SavedOrder.ID) } Youâ€™ve isolated business logic from infrastructure â€” the holy grail of testability.\nğŸ”„ Summary DIP inverts traditional dependency direction: high-level modules depend on interfaces, not implementations.\nInterfaces define contracts at the boundaries.\nDependency Injection supplies those interfaces at runtime.\nUnit Testing becomes effortless when your logic isnâ€™t tangled up in database, network, or file system concerns.\nğŸ§­ When to Use DIP in Go âœ… When abstracting IO, storage, APIs, or 3rd party integrations\nâœ… When writing business logic you want to test independently\nâŒ Not needed for everything â€” Go prefers concrete, simple code unless you need indirection\n","permalink":"https://norbix.dev/posts/dependency-inversion-principle/","summary":"A deep dive into the Dependency Inversion Principle, its implementation with interfaces and dependency injection, and how it unlocks clean, testable Go code.","title":"Breaking the Chain: Dependency Inversion, Interfaces, and Testable Go Code"},{"content":"The whiteboard behind this article is more than just colorful notes â€” it\u0026rsquo;s a map of the mental models that drive clean, scalable, and maintainable software systems. Letâ€™s break down the core ideas and keywords captured in this visual brainstorm.\nğŸ§  Sub-Domains \u0026amp; Bounded Contexts Domain, Sub-Domain, Service Line of business, like Insurance, Banking, E-Commerce Visualized as logical boundaries for teams and services Inspired by Domain-Driven Design (DDD) â€œDesign your system around business capabilities, not technical constraints.â€\nğŸ§± Architectural Patterns Layered Architecture: DAO â†’ Service â†’ Controller Module / Component view Common design layers: Project Layer Objects / Classes Executable packaging: .JAR / .EXE / .ZIP âœï¸ Design Patterns (GoF) Grouped by intent:\nStructural: Facade Decorator Adapter Behavioral: Strategy Observer Command Creational: Singleton Factory Builder Each of these has a purpose in object lifecycle, behavior injection, or structural abstraction.\nğŸ“ SOLID Principles Each letter is a compass for clean design:\nS â€“ Single Responsibility O â€“ Open/Closed L â€“ Liskov Substitution I â€“ Interface Segregation D â€“ Dependency Inversion And donâ€™t forget the twin brother: DRY (Donâ€™t Repeat Yourself).\nğŸ›°ï¸ Communication Styles REST, gRPC, GraphQL, WebSocket Pub/Sub, Push, Poll Emphasizes event-driven, asynchronous models in distributed systems âš™ï¸ Buzzwords \u0026amp; Practices From delivery to deployment:\n#ShiftLeft #TestFirst, #ContractFirst, #DesignFirst #PlatformEngineering #ZeroTrust, #Resilience, #Observability ğŸ¯ Hashtags as Architecture Drivers A few standout philosophies and principles:\n#CompositionOverInheritance #LiftAndShift #KISS (Keep It Simple, Stupid) #DeferDecisions #AutomationIsProductivity #AnticorruptionLayer #BoundedContext #HexagonalArchitecture These tags arenâ€™t just trending on dev Twitter â€” theyâ€™re real-world practices for making software less fragile and more adaptive.\nğŸ“Œ TL;DR The whiteboard outlines an entire mental toolkit for system design:\nThink in domains, not just code Choose patterns and principles that solve business pain points Architect with change in mind â€” using SOLID, DDD, and event-driven paradigms Let #buzzwords like #DRY, #ShiftLeft, and #Resilience guide practical decisions, not dogma \u0026ldquo;Architecture is not about boxes and arrows. It\u0026rsquo;s about decisions and trade-offs.\u0026rdquo;\nâ€“ Norbert Jakubczak\nğŸ’¬ Got questions about any of the keywords? Want a breakdown on one of the patterns or practices? Drop a comment below â€” let\u0026rsquo;s talk architecture.\n","permalink":"https://norbix.dev/posts/keywords/","summary":"A visual exploration of the core keywords and concepts in modern software architecture.","title":"Keywords in Software Architecture"},{"content":" Writing Go code that works is easy. Writing Go code that lasts? That takes practice.\nAfter working on production systems in Go for several years â€” across SaaS platforms, cloud-native backends, and developer tooling â€” Iâ€™ve collected a set of battle-tested best practices that have helped me write maintainable, clean, and scalable Go code.\nğŸ§­ 0. Agree on Code Style Before You Write a Line Before starting any development, align on a shared code style with your team.\nThis prevents unnecessary friction during code reviews, ensures consistency, and reduces the mental overhead of switching between files written by different developers.\nA great starting point is the Google Go Style Guide â€” it\u0026rsquo;s clear, opinionated, and battle-tested at scale. You can automate style enforcement with:\ngofmt / goimports for formatting golangci-lint to enforce idiomatic Go practices Establishing your code style early also makes onboarding faster and simplifies collaboration â€” especially in cross-functional teams or open source projects.\nâœ… 1. Keep it Simple Go is intentionally minimal â€” embrace it.\nAvoid over-engineering. Prefer composition over inheritance. Use plain interfaces and simple data structures. Donâ€™t abstract too early â€” write the concrete code first. ğŸ§± 2. Project Structure Matters Use a predictable layout:\n1 2 3 4 5 6 /cmd - entry points /internal - private packages /pkg - public, reusable packages /api - OpenAPI/proto definitions /config - config loading /scripts - helper scripts Stick to convention. Tools like golang-standards/project-layout are a great starting point â€” but adapt it to your teamâ€™s needs.\nğŸ§ª 3. Tests Are Not Optional Use table-driven tests Use testing, and only bring in libraries like testify if you really need them Keep unit tests fast and independent Use go test -cover to check coverage âœ¨ 4. Errors Are First-Class Citizens Always check errors â€” no exceptions. Wrap errors with context using fmt.Errorf(\u0026quot;failed to read config: %w\u0026quot;, err) For complex systems, consider using errors.Join or errors.Is/As for proper error handling. ğŸ“¦ 5. Use Interfaces at the Boundaries Keep interfaces small, and only expose them where needed:\n1 2 3 type Storer interface { Save(ctx context.Context, data Item) error } Donâ€™t write interfaces for everything â€” only where mocking or substitution matters (e.g. storage, HTTP clients, etc.).\nğŸ§° 6. Tooling Makes You Better Use go vet, staticcheck, and golangci-lint Automate formatting: gofmt, goimports Use go mod tidy to keep your dependencies clean Pin tool versions with a tools.go file ğŸ“Š Use SonarQube for static code analysis at scale SonarQube helps enforce code quality and security standards across large codebases. It can detect bugs, vulnerabilities, code smells, and even provide actionable remediation guidance. Integrate it into your CI pipeline to ensure every PR gets automatically analyzed.\nYou can use sonar-scanner or a Docker-based runner like:\n1 2 3 4 5 6 ```bash docker run --rm \\ -e SONAR_HOST_URL=\u0026#34;https://your-sonarqube-url\u0026#34; \\ -e SONAR_LOGIN=\u0026#34;your_token\u0026#34; \\ -v \u0026#34;$(pwd):/usr/src\u0026#34; \\ sonarsource/sonar-scanner-cli SonarQube works great alongside golangci-lint, giving you both quick feedback locally and deep insights via the web dashboard.\nğŸ” 7. Secure By Default Always set timeouts on HTTP clients and servers Avoid leaking secrets in logs Validate all inputs â€” especially on the API boundary Use context.Context consistently and propagate it properly ğŸŒ 8. Embrace the Go Ecosystem Use standard library wherever possible â€” it\u0026rsquo;s well-tested and fast Prefer established, well-maintained packages Read source code â€” Go makes it easy to learn from the best ğŸš€ 9. Performance Matters (but correctness first) Profile with pprof Avoid allocations in tight loops Use channels, but donâ€™t abuse goroutines Benchmark with go test -bench ğŸ§  10. Readability \u0026gt; Cleverness Your code will be read 10x more than itâ€™s written.\n\u0026quot;Write code for humans, not machines.\u0026quot; Stick to idiomatic Go â€” use golangci-lint to enforce consistency, and always code with your teammates in mind.\nğŸ™Œ Conclusion Go is an incredible tool for building fast, reliable software â€” but like any tool, it shines brightest in the hands of developers who respect its philosophy: clarity, simplicity, and composability.\nWhat are your favorite Go best practices? Let me know on Twitter or GitHub @norbix!\n","permalink":"https://norbix.dev/posts/best-practicies-4-software-development-in-go/","summary":"A collection of real-world Go best practices from years of building backend systems, APIs, and cloud-native services.","title":"Best Practices for Software Development in Go"},{"content":"This is a test page. This is a test page for the Hugo blog. It is used to verify the setup and configuration of the Hugo site. The content here is not meant to be permanent and will be replaced with actual blog posts in the future.\n","permalink":"https://norbix.dev/docs/test/","summary":"\u003ch1 id=\"this-is-a-test-page\"\u003eThis is a test page.\u003c/h1\u003e\n\u003cp\u003eThis is a test page for the Hugo blog. It is used to verify the setup and configuration of the Hugo site. The content here is not meant to be permanent and will be replaced with actual blog posts in the future.\u003c/p\u003e","title":"Test"},{"content":"Hi, I\u0026rsquo;m Norbert Jakubczak â€” aka Norbix ğŸ‘‹\nI\u0026rsquo;m a polyglot Software Engineer with a strong focus on Golang and Python, working across the full stack â€” from backend and cloud infrastructure to frontend integration and developer tooling.\nI specialize in building Internal Developer Platforms (IDPs) and architecting scalable Software-as-a-Service (SaaS) systems using microservices and modern cloud-native technologies.\nBefore stepping fully into tech, I was a professional basketball player â€” a path that taught me discipline, team dynamics, and what it means to perform under pressure. That mindset still drives how I build software today.\n\u0026ldquo;Never say never, because limits, like fears, are often just an illusion.\u0026rdquo;\nâ€” Michael Jordan\nğŸ› ï¸ Areas of Expertise ğŸ \u0026amp; ğŸ¦« Polyglot systems in Python and Go ğŸ§± Internal Developer Platforms (IDP) ğŸ§© SaaS Microservices architecture â˜ï¸ Kubernetes (K8s) and cloud-native platforms ğŸ” DevSecOps and secure CI/CD pipelines âš™ï¸ Full lifecycle delivery: from analysis \u0026amp; architecture â†’ development â†’ deployment â†’ production support âœï¸ What this blog is about This blog is a logbook of my journey building and maintaining resilient systems â€” sharing both wins and war stories from the world of platform engineering, cloud automation, and product delivery.\nExpect deep dives on:\nGo/Python code patterns API and system design Developer experience (DevEx) best practices CI/CD orchestration Infrastructure-as-Code (IaC) Real code. Real lessons. Honest write-ups.\nğŸŒ Connect with me GitHub: @norbix Twitter: @norbixjakubczak Email: norbert.jakubczak@gmail.com Mobile: +48 885 259 225 Thanks for stopping by. Whether you\u0026rsquo;re a developer, architect, or fellow ex-athlete turned engineer â€” I hope something here helps you build better systems.\n","permalink":"https://norbix.dev/about/","summary":"\u003cp\u003eHi, I\u0026rsquo;m \u003cstrong\u003eNorbert Jakubczak\u003c/strong\u003e â€” aka \u003cstrong\u003eNorbix\u003c/strong\u003e ğŸ‘‹\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m a polyglot \u003cstrong\u003eSoftware Engineer\u003c/strong\u003e with a strong focus on \u003cstrong\u003eGolang\u003c/strong\u003e and \u003cstrong\u003ePython\u003c/strong\u003e, working across the full stack â€” from backend and cloud infrastructure to frontend integration and developer tooling.\u003c/p\u003e\n\u003cp\u003eI specialize in building \u003cstrong\u003eInternal Developer Platforms (IDPs)\u003c/strong\u003e and architecting scalable \u003cstrong\u003eSoftware-as-a-Service (SaaS)\u003c/strong\u003e systems using microservices and modern cloud-native technologies.\u003c/p\u003e\n\u003cp\u003eBefore stepping fully into tech, I was a \u003cstrong\u003eprofessional basketball player\u003c/strong\u003e â€” a path that taught me discipline, team dynamics, and what it means to perform under pressure. That mindset still drives how I build software today.\u003c/p\u003e","title":"About"}]
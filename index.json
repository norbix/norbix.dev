[{"content":"Design patterns are reusable solutions to common problems in software design.\nThey provide a shared language for developers and encourage best practices in system architecture.\nIn this article, we\u0026rsquo;ll explore some of the most widely used design patterns in Go, grouped into three categories: creational, structural, and behavioral.\n🔧 Creational Patterns 🔂 Singleton\nEnsures a class has only one instance and provides a global point of access to it.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package singleton import ( \u0026#34;sync\u0026#34; ) var ( instance *singleton once sync.Once ) type singleton struct{} func GetInstance() *singleton { once.Do(func() { instance = \u0026amp;singleton{} }) return instance } 🏭 Factory\nCreates objects without specifying the exact class.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package factory type Shape interface { Draw() string } type Circle struct{} func (c Circle) Draw() string { return \u0026#34;Drawing Circle\u0026#34; } type Square struct{} func (s Square) Draw() string { return \u0026#34;Drawing Square\u0026#34; } func GetShape(shapeType string) Shape { switch shapeType { case \u0026#34;circle\u0026#34;: return Circle{} case \u0026#34;square\u0026#34;: return Square{} default: return nil } } 🧱 Builder\nSeparates the construction of a complex object from its representation.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package builder type Car struct { Engine string Wheels int Color string } type CarBuilder struct { car Car } func (b *CarBuilder) SetEngine(engine string) *CarBuilder { b.car.Engine = engine return b } func (b *CarBuilder) SetWheels(wheels int) *CarBuilder { b.car.Wheels = wheels return b } func (b *CarBuilder) SetColor(color string) *CarBuilder { b.car.Color = color return b } func (b *CarBuilder) Build() Car { return b.car } 🧩 Structural Patterns 🔌 Adapter\nAllows incompatible interfaces to work together.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package adapter type Target interface { Request() string } type Adaptee struct{} func (a Adaptee) SpecificRequest() string { return \u0026#34;Specific behavior\u0026#34; } type Adapter struct { adaptee Adaptee } func (a Adapter) Request() string { return a.adaptee.SpecificRequest() } 🎀 Decorator\nAdds behavior to objects dynamically.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package decorator type Coffee interface { Cost() float64 } type SimpleCoffee struct{} func (s SimpleCoffee) Cost() float64 { return 2.0 } type MilkDecorator struct { Coffee } func (m MilkDecorator) Cost() float64 { return m.Coffee.Cost() + 0.5 } 🛡 Proxy\nProvides a surrogate or placeholder.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package proxy type Image interface { Display() string } type RealImage struct { filename string } func (r RealImage) Display() string { return \u0026#34;Displaying \u0026#34; + r.filename } type ProxyImage struct { realImage *RealImage filename string } func (p *ProxyImage) Display() string { if p.realImage == nil { p.realImage = \u0026amp;RealImage{filename: p.filename} } return p.realImage.Display() } 🌳 Composite\nComposes objects into tree structures.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package composite type Component interface { Operation() string } type Leaf struct { name string } func (l Leaf) Operation() string { return l.name } type Composite struct { children []Component } func (c *Composite) Add(child Component) { c.children = append(c.children, child) } func (c *Composite) Operation() string { result := \u0026#34;\u0026#34; for _, child := range c.children { result += child.Operation() + \u0026#34; \u0026#34; } return result } 🧠 Behavioral Patterns 🧮 Strategy\nDefines a family of algorithms.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package strategy type Strategy interface { Execute(a, b int) int } type Add struct{} func (Add) Execute(a, b int) int { return a + b } type Multiply struct{} func (Multiply) Execute(a, b int) int { return a * b } type Context struct { strategy Strategy } func (c *Context) SetStrategy(s Strategy) { c.strategy = s } func (c Context) ExecuteStrategy(a, b int) int { return c.strategy.Execute(a, b) } 👀 Observer\nNotifies dependents of state changes.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package observer type Observer interface { Update(string) } type Subject interface { Attach(Observer) Notify() } type ConcreteSubject struct { observers []Observer state string } func (s *ConcreteSubject) Attach(o Observer) { s.observers = append(s.observers, o) } func (s *ConcreteSubject) SetState(state string) { s.state = state s.Notify() } func (s *ConcreteSubject) Notify() { for _, o := range s.observers { o.Update(s.state) } } type ConcreteObserver struct { id string } func (o ConcreteObserver) Update(state string) { println(\u0026#34;Observer\u0026#34;, o.id, \u0026#34;received new state:\u0026#34;, state) } 🔁 State\nAllows an object to alter its behavior when its internal state changes.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package state type State interface { Handle() string } type Context struct { state State } func (c *Context) SetState(s State) { c.state = s } func (c Context) Request() string { return c.state.Handle() } type OnState struct{} func (OnState) Handle() string { return \u0026#34;State is ON\u0026#34; } type OffState struct{} func (OffState) Handle() string { return \u0026#34;State is OFF\u0026#34; } ✅ Conclusion Design patterns are powerful tools in every Go developer’s toolkit. While Go encourages simplicity, these patterns still apply—especially in large-scale systems or when writing reusable libraries. Using patterns like Singleton, Adapter, and Strategy can lead to cleaner, more testable, and maintainable code.\nHappy Go coding! 🐹\n","permalink":"https://norbix.dev/posts/design-patterns/","summary":"Explore creational, structural, and behavioral design patterns in Go with clear explanations and code snippets.","title":"Design Patterns in Go: Practical Examples"},{"content":"\u0026ldquo;High-level modules should not depend on low-level modules. Both should depend on abstractions.\u0026rdquo;\nWelcome to a core principle of software architecture: Dependency Inversion, the \u0026ldquo;D\u0026rdquo; in SOLID. In this article, we’ll explore what it means in practice, how to implement it in Go using interfaces and dependency injection, and why it’s essential for writing unit-testable code.\n🧠 What Is the Dependency Inversion Principle? The Dependency Inversion Principle (DIP) flips the traditional dependency model:\n❌ Traditional: High-level business logic depends directly on low-level implementation (e.g., a database).\n✅ DIP: Both layers depend on abstractions — usually in the form of interfaces.\nIt’s about reversing the direction of dependency to reduce coupling and improve flexibility.\n💡 A Quick Example: Tightly Coupled Code 1 2 3 4 5 6 7 8 type OrderService struct { db *sql.DB } func (o *OrderService) Save(order Order) error { _, err := o.db.Exec(\u0026#34;INSERT INTO orders ...\u0026#34;) return err } This code:\nTightly couples OrderService to a concrete *sql.DB\nIs hard to test in isolation\n✅ Refactor with Dependency Inversion Let’s invert the dependency:\n1 2 3 4 5 6 7 8 9 10 11 type OrderRepository interface { Save(order Order) error } type OrderService struct { repo OrderRepository } func (o *OrderService) Save(order Order) error { return o.repo.Save(order) } Now:\nOrderService depends on an interface\nOrderRepository can be backed by a real DB in prod or a mock in tests\n🛠️ Enter Dependency Injection We’ve inverted dependencies — now we need a way to supply them. Manual constructor injection in Go:\n1 2 3 func NewOrderService(repo OrderRepository) *OrderService { return \u0026amp;OrderService{repo: repo} } At runtime, inject the actual implementation:\n1 service := NewOrderService(NewPostgresOrderRepository(db)) 🧪 Why This Rocks for Testing DIP + interfaces = test-friendly code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type MockOrderRepository struct { SavedOrder Order } func (m *MockOrderRepository) Save(order Order) error { m.SavedOrder = order return nil } func TestOrderService_Save(t *testing.T) { mock := \u0026amp;MockOrderRepository{} service := NewOrderService(mock) order := Order{ID: 42} err := service.Save(order) require.NoError(t, err) require.Equal(t, 42, mock.SavedOrder.ID) } You’ve isolated business logic from infrastructure — the holy grail of testability.\n🔄 Summary DIP inverts traditional dependency direction: high-level modules depend on interfaces, not implementations.\nInterfaces define contracts at the boundaries.\nDependency Injection supplies those interfaces at runtime.\nUnit Testing becomes effortless when your logic isn’t tangled up in database, network, or file system concerns.\n🧭 When to Use DIP in Go ✅ When abstracting IO, storage, APIs, or 3rd party integrations\n✅ When writing business logic you want to test independently\n❌ Not needed for everything — Go prefers concrete, simple code unless you need indirection\n","permalink":"https://norbix.dev/posts/dependency-inversion-principle/","summary":"A deep dive into the Dependency Inversion Principle, its implementation with interfaces and dependency injection, and how it unlocks clean, testable Go code.","title":"Breaking the Chain: Dependency Inversion, Interfaces, and Testable Go Code"},{"content":"The whiteboard behind this article is more than just colorful notes — it\u0026rsquo;s a map of the mental models that drive clean, scalable, and maintainable software systems. Let’s break down the core ideas and keywords captured in this visual brainstorm.\n🧠 Sub-Domains \u0026amp; Bounded Contexts Domain, Sub-Domain, Service Line of business, like Insurance, Banking, E-Commerce Visualized as logical boundaries for teams and services Inspired by Domain-Driven Design (DDD) “Design your system around business capabilities, not technical constraints.”\n🧱 Architectural Patterns Layered Architecture: DAO → Service → Controller Module / Component view Common design layers: Project Layer Objects / Classes Executable packaging: .JAR / .EXE / .ZIP ✍️ Design Patterns (GoF) Grouped by intent:\nStructural: Facade Decorator Adapter Behavioral: Strategy Observer Command Creational: Singleton Factory Builder Each of these has a purpose in object lifecycle, behavior injection, or structural abstraction.\n📐 SOLID Principles Each letter is a compass for clean design:\nS – Single Responsibility O – Open/Closed L – Liskov Substitution I – Interface Segregation D – Dependency Inversion And don’t forget the twin brother: DRY (Don’t Repeat Yourself).\n🛰️ Communication Styles REST, gRPC, GraphQL, WebSocket Pub/Sub, Push, Poll Emphasizes event-driven, asynchronous models in distributed systems ⚙️ Buzzwords \u0026amp; Practices From delivery to deployment:\n#ShiftLeft #TestFirst, #ContractFirst, #DesignFirst #PlatformEngineering #ZeroTrust, #Resilience, #Observability 🎯 Hashtags as Architecture Drivers A few standout philosophies and principles:\n#CompositionOverInheritance #LiftAndShift #KISS (Keep It Simple, Stupid) #DeferDecisions #AutomationIsProductivity #AnticorruptionLayer #BoundedContext #HexagonalArchitecture These tags aren’t just trending on dev Twitter — they’re real-world practices for making software less fragile and more adaptive.\n📌 TL;DR The whiteboard outlines an entire mental toolkit for system design:\nThink in domains, not just code Choose patterns and principles that solve business pain points Architect with change in mind — using SOLID, DDD, and event-driven paradigms Let #buzzwords like #DRY, #ShiftLeft, and #Resilience guide practical decisions, not dogma \u0026ldquo;Architecture is not about boxes and arrows. It\u0026rsquo;s about decisions and trade-offs.\u0026rdquo;\n– Norbert Jakubczak\n💬 Got questions about any of the keywords? Want a breakdown on one of the patterns or practices? Drop a comment below — let\u0026rsquo;s talk architecture.\n","permalink":"https://norbix.dev/posts/keywords/","summary":"A visual exploration of the core keywords and concepts in modern software architecture.","title":"Keywords in Software Architecture"},{"content":" Writing Go code that works is easy. Writing Go code that lasts? That takes practice.\nAfter working on production systems in Go for several years — across SaaS platforms, cloud-native backends, and developer tooling — I’ve collected a set of battle-tested best practices that have helped me write maintainable, clean, and scalable Go code.\n🧭 0. Agree on Code Style Before You Write a Line Before starting any development, align on a shared code style with your team.\nThis prevents unnecessary friction during code reviews, ensures consistency, and reduces the mental overhead of switching between files written by different developers.\nA great starting point is the Google Go Style Guide — it\u0026rsquo;s clear, opinionated, and battle-tested at scale. You can automate style enforcement with:\ngofmt / goimports for formatting golangci-lint to enforce idiomatic Go practices Establishing your code style early also makes onboarding faster and simplifies collaboration — especially in cross-functional teams or open source projects.\n✅ 1. Keep it Simple Go is intentionally minimal — embrace it.\nAvoid over-engineering. Prefer composition over inheritance. Use plain interfaces and simple data structures. Don’t abstract too early — write the concrete code first. 🧱 2. Project Structure Matters Use a predictable layout:\n1 2 3 4 5 6 /cmd - entry points /internal - private packages /pkg - public, reusable packages /api - OpenAPI/proto definitions /config - config loading /scripts - helper scripts Stick to convention. Tools like golang-standards/project-layout are a great starting point — but adapt it to your team’s needs.\n🧪 3. Tests Are Not Optional Use table-driven tests Use testing, and only bring in libraries like testify if you really need them Keep unit tests fast and independent Use go test -cover to check coverage ✨ 4. Errors Are First-Class Citizens Always check errors — no exceptions. Wrap errors with context using fmt.Errorf(\u0026quot;failed to read config: %w\u0026quot;, err) For complex systems, consider using errors.Join or errors.Is/As for proper error handling. 📦 5. Use Interfaces at the Boundaries Keep interfaces small, and only expose them where needed:\n1 2 3 type Storer interface { Save(ctx context.Context, data Item) error } Don’t write interfaces for everything — only where mocking or substitution matters (e.g. storage, HTTP clients, etc.).\n🧰 6. Tooling Makes You Better Use go vet, staticcheck, and golangci-lint Automate formatting: gofmt, goimports Use go mod tidy to keep your dependencies clean Pin tool versions with a tools.go file 📊 Use SonarQube for static code analysis at scale SonarQube helps enforce code quality and security standards across large codebases. It can detect bugs, vulnerabilities, code smells, and even provide actionable remediation guidance. Integrate it into your CI pipeline to ensure every PR gets automatically analyzed.\nYou can use sonar-scanner or a Docker-based runner like:\n1 2 3 4 5 6 ```bash docker run --rm \\ -e SONAR_HOST_URL=\u0026#34;https://your-sonarqube-url\u0026#34; \\ -e SONAR_LOGIN=\u0026#34;your_token\u0026#34; \\ -v \u0026#34;$(pwd):/usr/src\u0026#34; \\ sonarsource/sonar-scanner-cli SonarQube works great alongside golangci-lint, giving you both quick feedback locally and deep insights via the web dashboard.\n🔐 7. Secure By Default Always set timeouts on HTTP clients and servers Avoid leaking secrets in logs Validate all inputs — especially on the API boundary Use context.Context consistently and propagate it properly 🌐 8. Embrace the Go Ecosystem Use standard library wherever possible — it\u0026rsquo;s well-tested and fast Prefer established, well-maintained packages Read source code — Go makes it easy to learn from the best 🚀 9. Performance Matters (but correctness first) Profile with pprof Avoid allocations in tight loops Use channels, but don’t abuse goroutines Benchmark with go test -bench 🧠 10. Readability \u0026gt; Cleverness Your code will be read 10x more than it’s written.\n\u0026quot;Write code for humans, not machines.\u0026quot; Stick to idiomatic Go — use golangci-lint to enforce consistency, and always code with your teammates in mind.\n🙌 Conclusion Go is an incredible tool for building fast, reliable software — but like any tool, it shines brightest in the hands of developers who respect its philosophy: clarity, simplicity, and composability.\nWhat are your favorite Go best practices? Let me know on Twitter or GitHub @norbix!\n","permalink":"https://norbix.dev/posts/best-practicies-4-software-development-in-go/","summary":"A collection of real-world Go best practices from years of building backend systems, APIs, and cloud-native services.","title":"Best Practices for Software Development in Go"},{"content":"This is a test page. This is a test page for the Hugo blog. It is used to verify the setup and configuration of the Hugo site. The content here is not meant to be permanent and will be replaced with actual blog posts in the future.\n","permalink":"https://norbix.dev/docs/test/","summary":"\u003ch1 id=\"this-is-a-test-page\"\u003eThis is a test page.\u003c/h1\u003e\n\u003cp\u003eThis is a test page for the Hugo blog. It is used to verify the setup and configuration of the Hugo site. The content here is not meant to be permanent and will be replaced with actual blog posts in the future.\u003c/p\u003e","title":"Test"},{"content":"Hi, I\u0026rsquo;m Norbert Jakubczak — aka Norbix 👋\nI\u0026rsquo;m a polyglot Software Engineer with a strong focus on Golang and Python, working across the full stack — from backend and cloud infrastructure to frontend integration and developer tooling.\nI specialize in building Internal Developer Platforms (IDPs) and architecting scalable Software-as-a-Service (SaaS) systems using microservices and modern cloud-native technologies.\nBefore stepping fully into tech, I was a professional basketball player — a path that taught me discipline, team dynamics, and what it means to perform under pressure. That mindset still drives how I build software today.\n\u0026ldquo;Never say never, because limits, like fears, are often just an illusion.\u0026rdquo;\n— Michael Jordan\n🛠️ Areas of Expertise 🐍 \u0026amp; 🦫 Polyglot systems in Python and Go 🧱 Internal Developer Platforms (IDP) 🧩 SaaS Microservices architecture ☁️ Kubernetes (K8s) and cloud-native platforms 🔐 DevSecOps and secure CI/CD pipelines ⚙️ Full lifecycle delivery: from analysis \u0026amp; architecture → development → deployment → production support ✍️ What this blog is about This blog is a logbook of my journey building and maintaining resilient systems — sharing both wins and war stories from the world of platform engineering, cloud automation, and product delivery.\nExpect deep dives on:\nGo/Python code patterns API and system design Developer experience (DevEx) best practices CI/CD orchestration Infrastructure-as-Code (IaC) Real code. Real lessons. Honest write-ups.\n🌍 Connect with me GitHub: @norbix Twitter: @norbixjakubczak Email: norbert.jakubczak@gmail.com Mobile: +48 885 259 225 Thanks for stopping by. Whether you\u0026rsquo;re a developer, architect, or fellow ex-athlete turned engineer — I hope something here helps you build better systems.\n","permalink":"https://norbix.dev/about/","summary":"\u003cp\u003eHi, I\u0026rsquo;m \u003cstrong\u003eNorbert Jakubczak\u003c/strong\u003e — aka \u003cstrong\u003eNorbix\u003c/strong\u003e 👋\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m a polyglot \u003cstrong\u003eSoftware Engineer\u003c/strong\u003e with a strong focus on \u003cstrong\u003eGolang\u003c/strong\u003e and \u003cstrong\u003ePython\u003c/strong\u003e, working across the full stack — from backend and cloud infrastructure to frontend integration and developer tooling.\u003c/p\u003e\n\u003cp\u003eI specialize in building \u003cstrong\u003eInternal Developer Platforms (IDPs)\u003c/strong\u003e and architecting scalable \u003cstrong\u003eSoftware-as-a-Service (SaaS)\u003c/strong\u003e systems using microservices and modern cloud-native technologies.\u003c/p\u003e\n\u003cp\u003eBefore stepping fully into tech, I was a \u003cstrong\u003eprofessional basketball player\u003c/strong\u003e — a path that taught me discipline, team dynamics, and what it means to perform under pressure. That mindset still drives how I build software today.\u003c/p\u003e","title":"About"}]